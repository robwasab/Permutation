<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<meta name="generator" content="HTML Tidy, see www.w3.org">
<title>Expect for Windows - User Guide</title>
<link rel="stylesheet" type="text/css" href="aspn.css">
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
</head>
<body marginheight="5" topmargin="5" marginwidth="10" leftmargin=
"10">
<div class="banner">
<table width="100%" border="0" cellspacing="0" cellpadding="3">
<tr>
<td align="left"><a target="_blank" href=
"http://www.activestate.com/Products/Expect/"><img src=
"images/expect_logo.gif" border="0" align="left" alt="Expect"></a>
</td>
<td align="center" class="heading">Expect for
Windows<sup><small>&reg;</small></sup> User Guide</td>
<td align="right"><a target="_blank" href=
"http://www.activestate.com"><img src="images/AS_logo.gif" border=
"0" align="right" alt="ActiveState Software Inc."></a> </td>
</tr>
</table>
</div>

<a name="top"></a> 

<h1>Expect for Windows Reference</h1>

<ul>
<li><a href="#intro">Introduction</a></li>

<li><a href="#usage">Usage</a></li>

<li><a href="#commands">Commands</a></li>

<li><a href="#libraries">Libraries</a></li>

<!--<li><a href="#differences">Differences between the Unix and Windows Versions</a></li>-->
</ul>

<h2><a name="intro">Introduction</a></h2>

<p>This command reference outlines the basic usage of Expect for
Windows. It provides descriptions of the commands in the Expect
package and some short examples of how these commands can be
used.</p>

<p>In this document, "Expect" with an uppercase "E" refers to the
Expect package while "expect" with a lowercase "e" refers to the
<code>expect</code> command within the Expect package</p>

<p>For differences between the Windows and Unix versions of Expect,
see <a class="doc" href="ex_usage.html#cross_platform">Porting
Expect Scripts to Windows</a> in the Expect for Windows Usage
section.</p>

<a class="topText" href="#top"><img alt="Top" src="images/top.gif"
height="11" width="11" border="0">Top</a> 

<h2><a name="usage"><strong>Usage</strong></a></h2>

<p>Expect for Windows is implemented as a Tcl package (as opposed
to as a stand-alone executable). It must be called with a
<code>package require Expect</code> statement. For example:</p>

<pre>
    #!/bin/sh
    # \
    exec tclsh "$0" ${1+"$@"}
    package require Expect
    . . .
</pre>

<p>A <a href="ex_tut.html">Tutorial</a> and <a href=
"demos.html">Demos</a> are available to show how to build Expect
scripts in Tcl. A detailed guide on how to use Expect can be found
in <a href="ex_usage.html">Using ActiveState Expect for
Windows</a>.</p>

<a class="topText" href="#top"><img alt="Top" src="images/top.gif"
height="11" width="11" border="0">Top</a> 

<h2><a name="commands"><strong>Commands</strong></a></h2>

<table summary="toc" cellpadding="2" cellspacing="2">
<tbody>
<tr>
<td valign="top">
<ul>
<li><a href="#exp_close">exp_close</a></li>

<li><a href="#exp_continue">exp_continue</a></li>

<li><a href="#exp_disconnect">exp_disconnect</a></li>

<li><a href="#exp_exit">exp_exit</a></li>

<li><a href="#exp_fork">exp_fork</a></li>

<li><a href="#exp_getpid">exp_getpid</a></li>

<li><a href="#exp_inter_return">exp_inter_return</a></li>

<li><a href="#exp_interact">exp_interact</a></li>

<li><a href="#exp_internal">exp_internal</a></li>

<li><a href="#exp_interpreter">exp_interpreter</a></li>

<li><a href="#exp_log_file">exp_log_file</a></li>

<li><a href="#exp_log_user">exp_log_user</a></li>

<li><a href="#exp_match_max">exp_match_max</a></li>
</ul>
</td>
<td valign="top">
<ul>
<li><a href="#exp_open">exp_open</a></li>

<li><a href="#exp_overlay">exp_overlay</a></li>

<li><a href="#exp_parity">exp_parity</a></li>

<li><a href="#exp_pid">exp_pid</a></li>

<li><a href="#exp_remove_nulls">exp_remove_nulls</a></li>

<li><a href="#exp_send">exp_send</a></li>

<li><a href="#exp_send_error">exp_send_error</a></li>

<li><a href="#exp_send_log">exp_send_log</a></li>

<li><a href="#exp_send_tty">exp_send_tty</a></li>

<li><a href="#exp_send_user">exp_send_user</a></li>

<li><a href="#exp_sleep">exp_sleep</a></li>

<li><a href="#exp_spawn">exp_spawn</a></li>

<li><a href="#exp_strace">exp_strace</a></li>
</ul>
</td>
<td valign="top">
<ul>
<li><a href="#exp_stty">exp_stty</a></li>

<li><a href="#exp_system">exp_system</a></li>

<li><a href="#exp_timestamp">exp_timestamp</a></li>

<li><a href="#exp_trap">exp_trap</a></li>

<li><a href="#exp_version">exp_version</a></li>

<li><a href="#exp_wait">exp_wait</a></li>

<li><a href="#expect">expect</a></li>

<li><a href="#expect_after">expect_after</a></li>

<li><a href="#expect_background">expect_background</a></li>

<li><a href="#expect_before">expect_before</a></li>

<li><a href="#expect_tty">expect_tty</a></li>

<li><a href="#expect_user">expect_user</a></li>
</ul>
</td>
</tr>
</tbody>
</table>

<p>Expect uses <em>Tcl</em> (Tool Command Language). Tcl provides
control flow, expression evaluation and several other features such
as recursion, procedure definition, etc. Commands used here but not
defined (e.g., <code>set</code>, <code>if</code>,
<code>exec</code>) are Tcl commands (described in the <a target=
"_blank" href=
"http://tcl.ActiveState.com/man/tcl8.4/TclCmd/contents.htm">Tcl
documentation</a>). Expect supports additional commands, described
below. Unless otherwise specified, commands return the empty
string.</p>

<p>For quick reference, commands are listed alphabetically. New
users may find it easier to start by reading the descriptions of
<code>exp_spawn</code>, <code>exp_send</code>, and
<code>expect</code>, <!--and <code>interact</code>,-->in that
order.</p>

<p>With the exception of the <code>expect</code> command, all
commands listed are prefixed with "exp_" or "expect_". Though most
of them can be called without these prefixes, they are generally
used in the form presented in order to clearly differentiate them
from other global commands in Tcl. The reason for the command name
overlap is that Expect was the very first extension to Tcl, and
several of the command names it uses were Expect commands before
they were core Tcl commands.</p>

<dl>
<dt><a name="exp_close"><strong>exp_close</strong> <em>[-onexec
0|1] [-i spawn_id]</em></a></dt>

<dd>
<p>This command closes the connection to the current process. Most
interactive programs will detect EOF on their stdin and exit; thus
<code>exp_close</code> usually suffices to kill the process as
well. The <code>-i</code> flag declares the process to close
corresponding to the named spawn_id.</p>

<p>The <code><a href="#expect">expect</a></code> command will
detect when the current process exits and implicitly do an
<code>exp_close</code>. But if you kill the process by another
method such as "<code>exec kill $pid</code>", you will need to
explicitly call <code>exp_close</code>.</p>

<p>The <code>-onexec</code> flag determines whether the spawn id
will be closed in any new spawned processes or if the process is
overlaid. To leave a spawn id open, use the value 0. A non-zero
integer value will force the spawn closed (the default) in any new
processes.</p>

<p><em>The <code>-slave</code> flag is not supported on
Windows.</em> On Unix systems, this closes the slave associated
with the spawn id. (See "<code><a href="#exp_spawn">exp_spawn</a>
-pty</code>".) When the connection is closed, the slave is
automatically closed as well if still open.</p>

<p>Regardless of whether the connection is closed implicitly or
explicitly, you should call <code><a href=
"#exp_wait">exp_wait</a></code> to clear up the corresponding
kernel process slot. The <code>exp_close</code> command does not
call <code>exp_wait</code> since there is no guarantee that closing
a process connection will cause it to exit. See
<code>exp_wait</code> for more information.</p>
</dd>

<dt><a name="exp_continue"><strong>exp_continue</strong>
<em>[-continue_timer]</em></a></dt>

<dd>
<p>The command <code>exp_continue</code> allows <code>expect</code>
itself to continue executing rather than returning as it normally
would. By default <code>exp_continue</code> resets the timeout
timer. The <em>-continue_timer</em> flag prevents the timer from
being restarted. See <code><a href="#expect">expect</a></code> for
more information.</p>
</dd>

<dt><a name="exp_disconnect"><strong><span class=
"doccmddeprecated">exp_disconnect</span></strong></a></dt>

<dd>
<p><em>Not applicable on Windows.</em> On Unix systems, this
disconnects a forked process from the terminal and continues
running in the background.</p>

<!--VERIFY: not available on Windows?

<dt>
<a name="debug"><strong>debug</strong> <em>[[-now]</em> <em>0|1]</em></a>
<dd>
<p>controls a Tcl debugger allowing you to step through statements, set
   breakpoints, etc.</p>

<p>With no arguments, a 1 is returned if the debugger is not running,
   otherwise a 0 is returned.</p>

<p>With a 1 argument, the debugger is started. With a 0 argument, the
   debugger is stopped. If a 1 argument is preceded by the <strong>-
   now</strong> flag, the debugger is started immediately (i.e., in the
   middle of the <code>debug</code> command itself). Otherwise, the
   debugger is started with the next Tcl statement.</p>

<p>The <code>debug</code> command does not change any traps. Compare
   this to starting Expect with the <code>-D</code> flag (see
   above).</p>
-->
</dd>

<dt><a name="exp_exit"><strong>exp_exit</strong> <em>[-opts]
[status]</em></a></dt>

<dd>
<p>This command causes Expect to exit or otherwise prepare to do
so.</p>

<p>The <code>-onexit</code> flag causes the next argument to be
used as an exit handler. Without an argument, the current exit
handler is returned.</p>

<p>The <code>-noexit</code> flag causes Expect to prepare to exit
but stop short of actually returning control to the operating
system. The user-defined exit handler is run as well as Expect's
own internal handlers. No further Expect commands should be
executed. This is useful if you are running Expect with other Tcl
extensions. The current interpreter remains (as does the main
window in the Tk environment) so that other Tcl extensions can
clean up. If Expect's <code>exp_exit</code> is called again
(however this might occur), the handlers are not rerun.</p>

<p>Upon exiting, all connections to spawned processes are closed.
Closure will be detected as an EOF by spawned processes. The
<code>exp_exit</code> command takes no other actions beyond what
the normal <code>_exit</code> procedure does. <!-- VERIFY:How much
of this is applicable on Windows? Is there some _exit documentation for
Windows that could be linked to? Thus, spawned processes that do not
check for EOF may continue to run. (A variety of conditions are
important to determining, for example, what signals a spawned process
will be sent, but these are system-dependent, typically documented under
<a href="man:exit(3)">exit(3)</a>.) Spawned processes that continue to
run will be inherited by init.</p>
-->
</p>

<p>The <em>status</em> (or 0 if not specified) is returned as the
exit status of Expect. The <code>exp_exit</code> command is
implicitly executed if the end of the script is reached.</p>
</dd>

<dt><a name="exp_fork"><strong><span class=
"doccmddeprecated">exp_fork</span></strong></a></dt>

<dd>
<p><em>Not applicable on Windows.</em> On Unix systems, this
command creates a new copy of the current Expect process.</p>

<!--On success, <code>exp_fork</code> returns 0 to the new (child)
process and returns the process ID of the child process to the parent
process. On failure (invariably due to lack of resources, e.g., swap
space, memory), <code>exp_fork</code> returns -1 to the parent
process, and no child process is created.</p>

<p>Forked processes exit via the <code>exp_exit</code> command, just
like the original process. Forked processes are allowed to write to the
log files. If you do not disable debugging or logging in most of the
processes, the result can be confusing.</p>

<p>Some pty implementations may be confused by multiple readers and
writers, even momentarily. Thus, it is safest to <code>fork</code> before
spawning processes.</p>
-->
</dd>

<dt><a name="exp_getpid"><strong>exp_getpid</strong></a></dt>

<dd>
<p>The <code>exp_getpid</code> command is deprecated. Tcl's
<code><a target="_blank" href=
"http://tcl.activestate.com/man/tcl8.4/TclCmd/pid.htm">pid</a></code>
command should be used instead.</p>
</dd>

<dt><a name=
"exp_inter_return"><strong>exp_inter_return</strong></a></dt>

<dd>
<p><em>Not currently implemented on Windows.</em> On Unix systems,
<code>exp_inter_return</code> causes <code>interact</code> to cause
a return in its caller.</p>
</dd>

<dt><a name="exp_interact"><strong>exp_interact</strong></a>
<em>[string1 body1] ... [stringn [bodyn]]</em></dt>

<dd>
<p><em>Not currently implemented on Windows.</em> On Unix systems,
this command gives control of the current process to the user, so
that keystrokes are sent to the current process, and the stdout and
stderr of the current process are returned.</p>

<!--
<p>String-body pairs may be specified as arguments, in which case the
   body is executed when the corresponding string is entered. (By
   default, the string is not sent to the current process.) The
   <code>interpreter</code> command is assumed, if the final body is
   missing.</p>

<p>If the arguments to the entire <code>interact</code> statement
   require more than one line, all the arguments may be "braced" into
   one so as to avoid terminating each line with a backslash. In this
   one case, the usual Tcl substitutions will occur despite the
   braces.</p>

<p>For example, the following command runs interact with the following
   string-body pairs defined: When ^Z is pressed, Expect is suspended.
   (The <code>-reset</code> flag restores the terminal modes.) When ^A
   is pressed, the user sees "you typed a control-A" and the process is
   sent a ^A. When $ is pressed, the user sees the date. When ^C is
   pressed, Expect exits. If "foo" is entered, the user sees "bar". When
   ~~ is pressed, the Expect interpreter runs interactively.</p>

<pre>
    set CTRLZ \032
    interact {
        -reset $CTRLZ {exec kill -STOP [pid]}
        \001   {send_user "you typed a control-A\n";
                send "\001"
               }
        $      {send_user "The date is [exec date]."}
        \003   exit
        foo    {send_user "bar"}
        ~~
    }
</pre>

<p>In string-body pairs, strings are matched in the order they are
listed as arguments. Strings that partially match are not sent to
the current process in anticipation of the remainder coming. If
characters are then entered such that there can no longer possibly
be a match, only the part of the string will be sent to the process
that cannot possibly begin another match. Thus, strings that are
substrings of partial matches can match later, if the original
strings that was attempting to be match ultimately fails.</p>

<p>By default, string matching is exact with no wild cards. (In
contrast, the <code>expect</code> command uses globstyle patterns by
default.) The <code>-ex</code> flag may be used to protect patterns that
might otherwise match <code>interact</code> flags from doing so. Any
pattern beginning with a "-" should be protected this
way. (All strings starting with "-" are reserved for
future options.)</p>

<p>The <code>-re</code> flag forces the string to be interpreted as a
regexp-style pattern. In this case, matching substrings are stored
in the variable <em>interact_out</em> similarly to the
way <code>expect</code> stores its output in the variable
<code>expect_out</code>. The <code>-indices</code> flag is similarly
supported.</p>

<p>The pattern <code>eof</code> introduces an action that is executed
upon end-of-file. A separate <code>eof</code> pattern may also follow the
<code>-output</code> flag in which case it is matched if an eof is
detected while writing output. The default <code>eof</code> action is
"return", so that <code>interact</code> simply returns upon any
EOF.</p>

<p>The pattern <code>timeout</code> introduces a timeout (in seconds) and
action that is executed after no characters have been read for a
given time. The <code>timeout</code> pattern applies to the most recently
specified process. There is no default timeout. The special
variable "timeout" (used by the <code>expect</code> command)
has no affect on this timeout.</p>

<p>For example, the following statement could be used to autologout
users who have not typed anything for an hour but who still get
frequent system messages:</p>

<pre>
    interact -input $user_spawn_id timeout 3600 return -output \
        $spawn_id
</pre>

<p>If the pattern is the keyword <code>null</code>, and nulls are allowed
(via the <code>remove_nulls</code> command), the corresponding body is
executed if a single ASCII 0 is matched. It is not possible to
match 0 bytes via glob or regexp patterns.</p>

<p>Prefacing a pattern with the flag <code>-iwrite</code> causes the
variable <em>interact_out(spawn_id)</em> to be set to the spawn_id which
matched the pattern (or eof).</p>

<p>Actions such as <code>break</code> and <code>continue</code> cause control
structures (i.e., <code>for</code>, <code>proc</code>) to behave in the usual
way. However, <code>return</code> causes interact to return to its caller,
while <code>inter_return</code> causes <code>interact</code> to cause a return
in its caller. For example, if "proc foo" called
<code>interact</code> which then executed the action <code>inter_return</code>,
<code>proc</code> <code>foo</code> would return. (This means that if
<code>interact</code> calls <code>interpreter</code> interactively typing
<code>return</code> will cause the interact to continue, while
<code>inter_return</code> will cause the interact to return to its
caller.)</p>

<p>During <code>interact</code>, raw mode is used so that all characters
may be passed to the current process. If the current process does
not catch job control signals, it will stop if sent a stop signal
(by default ^Z). To restart it, send a continue signal (such as by
"<code>kill -CONT &lt;pid&gt;</code>"). If you really want to send a
SIGSTOP to such a process (by ^Z), consider spawning csh first and
then running your program. On the other hand, if you want to send a
SIGSTOP to Expect itself, first call interpreter (perhaps by
using an escape character), and then press ^Z.</p>

<p>String-body pairs can be used as a shorthand for avoiding having
to enter the interpreter and execute commands interactively. The
previous terminal mode is used while the body of a string-body pair
is being executed.</p>

<p>For speed, actions execute in raw mode by default. The
<code>-reset</code> flag resets the terminal to the mode it had before
<code>interact</code> was executed (invariably, cooked mode). Note that
characters entered when the mode is being switched may be lost (an
unfortunate feature of the terminal driver on some systems). The
only reason to use <code>-reset</code> is if your action depends on
running in cooked mode.</p>

<p>The <code>-echo</code> flag sends characters that match the following
pattern back to the process that generated them as each character
is read. This may be useful when the user needs to see feedback
from partially typed patterns.</p>

<p>If a pattern is being echoed but eventually fails to match, the
characters are sent to the spawned process. If the spawned process
then echoes them, the user will see the characters twice.
<code>-echo</code> is probably only appropriate in situations where the
user is unlikely to not complete the pattern. For example, the
following excerpt is from rftp, the recursiveftp script, where the
user is prompted to enter ~g, ~p, or ~l, to get, put, or list the
current directory recursively. These are so far away from the
normal ftp commands, that the user is unlikely to type ~ followed
by anything else, except mistakenly, in which case, they'll
probably just ignore the result anyway.</p>

<pre>
    interact {
        -echo ~g {getcurdirectory 1}
        -echo ~l {getcurdirectory 0}
        -echo ~p {putcurdirectory}
    }
</pre>

<p>The <code>-nobuffer</code> flag sends characters that match the
following pattern on to the output process as characters are
read.</p>

<p>This is useful when you wish to let a program echo back the
pattern. For example, the following might be used to monitor where
a person is dialing (a Hayes-style modem). Each time
"atd" is seen the script logs the rest of the line.</p>

<pre>
    proc lognumber {} {
        interact -nobuffer -re "(.*)\r" return
        puts $log "[exec date]: dialed $interact_out(1,string)"
    }

    interact -nobuffer "atd" lognumber
</pre>

<p>During <code>interact</code>, previous use of <code>log_user</code> is
ignored. In particular, <code>interact</code> will force its output to be
logged (sent to the standard output) since it is presumed the user
doesn't wish to interact blindly.</p>

<p>The <code>-o</code> flag causes any following key-body pairs to be
applied to the output of the current process. This can be useful,
for example, when dealing with hosts that send unwanted characters
during a telnet session.</p>

<p>By default, <code>interact</code> expects the user to be writing stdin
and reading stdout of the Expect process itself. The
<code>-u</code> flag (for "user") makes <code>interact</code> look for
the user as the process named by its argument (which must be a
spawned id).</p>

<p>This allows two unrelated processes to be joined together
without using an explicit loop. To aid in debugging, Expect
diagnostics always go to stderr (or stdout for certain logging and
debugging information). For the same reason, the <code>interpreter</code>
command will read interactively from stdin.</p>

<p>For example, the following fragment creates a login process.
Then it dials the user (not shown), and finally connects the two
together. Of course, any process may be substituted for login. A
shell, for example, would allow the user to work without supplying
an account and password.</p>

<pre>
    spawn login
    set login $spawn_id
    spawn tip modem
    # dial back out to user
    # connect user to login
    interact -u $login
</pre>

<p>To send output to multiple processes, list each spawn id list
prefaced by a <code>-output</code> flag. Input for a group of output
spawn ids may be determined by a spawn id list prefaced by a
<code>-input</code> flag. (Both <code>-input</code> and <code>-output</code> may take
lists in the same form as the <code>-i</code> flag in the <code>expect</code>
command, except that any_spawn_id is not meaningful in
<code>interact</code>.) All following flags and strings (or patterns)
apply to this input until another -input flag appears. If no
<code>-input</code> appears, <code>-output</code> implies "-input
$user_spawn_id -output". (Similarly, with patterns that do not have
<code>-input</code>.) If one <code>-input</code> is specified, it overrides
$user_spawn_id. If a second <code>-input</code> is specified, it
overrides $spawn_id. Additional <code>-input</code> flags may be
specified.</p>

<p>The two implied input processes default to having their outputs
specified as $spawn_id and $user_spawn_id (in reverse). If a
<code>-input</code> flag appears with no <code>-output</code> flag, characters
from that process are discarded.</p>

<p>The <code>-i</code> flag introduces a replacement for the current
spawn_id when no other <code>-input</code> or <code>-output</code> flags are
used. A -i flag implies a -o flag.</p>

<p>It is possible to change the processes that are being interacted
with by using indirect spawn ids. (Indirect spawn ids are described
in the section on the expect command.) Indirect spawn ids may be
specified with the -i, -u, -input, or -output flags.</p>
-->
</dd>

<dt><a name="exp_internal"><strong>exp_internal</strong> <em>[-f
file] [-info] value</em></a></dt>

<dd>
<p>This causes further commands to send diagnostic information
internal to Expect to stderr if <em>value</em> is nonzero. This
output is disabled if <em>value</em> is 0. The diagnostic
information includes every character received, and every attempt
made to match the current output against the patterns.</p>

<p>If the optional <em>file</em> is supplied, all normal and
debugging output is written to that file (regardless of the value
of <em>value</em>). Any previous diagnostic output file is
closed.</p>

<p>The <code>-info</code> flag causes <code>exp_internal</code> to
return a description of the most recent non-info arguments
given.</p>
</dd>

<dt><a name="exp_interpreter"><strong>exp_interpreter</strong>
<em>[args]</em></a></dt>

<dd>
<p>This command causes the user to be interactively prompted for
Expect and Tcl commands. The result of each command is printed.</p>

<p>Actions such as <code><a target="_blank" href=
"http://tcl.activestate.com/man/tcl8.4/TclCmd/break.htm">break</a></code>
and <code><a target="_blank" href=
"http://tcl.activestate.com/man/tcl8.4/TclCmd/continue.htm">continue</a></code>
cause control structures (i.e., <code>for</code>,
<code>proc</code>) to behave in the usual way. However <code><a
target="_blank" href=
"http://tcl.activestate.com/man/tcl8.4/TclCmd/return.htm">return</a></code>
causes <code>exp_interpreter</code> to return to its caller, while
<code>exp_inter_return</code> <em>(not currently implemented in
Expect for Windows)</em> causes <code>exp_interpreter</code> to
cause a return in its caller. For example, if "<code>proc
foo</code>" called <code>exp_interpreter</code>, which then
executed the action <code>exp_inter_return</code>,
<code>proc</code> <code>foo</code> would return. Any other command
causes <code>exp_interpreter</code> to continue prompting for new
commands.</p>

<p>By default, the prompt contains two integers. The first integer
describes the depth of the evaluation stack (i.e., how many times
<code><a target="_blank" href=
"http://tcl.activestate.com/man/tcl8.4/TclLib/Eval.htm">Tcl_Eval</a></code>
has been called). The second integer is the Tcl history identifier.
The prompt can be set by defining a procedure called "prompt1"
whose return value becomes the next prompt. If a statement has open
quotes, parentheses, braces, or brackets, a secondary prompt (by
default "+&gt; ") is issued upon newline. The secondary prompt may
be set by defining a procedure called "prompt2".</p>

<p>During <code>exp_interpreter</code>, cooked mode is used, even
if its caller was using raw mode.</p>

<!--VERIFY: is the cooked/raw terminology applicable on Windows? If so
we need to define both. -->
<p>If stdin is closed, <code>exp_interpreter</code> will return
unless the <code>-eof</code> flag is used, in which case the
subsequent argument is invoked.</p>
</dd>

<dt><a name="exp_log_file"><strong>exp_log_file</strong> <em>[args]
[[-a] file]</em></a></dt>

<dd>
<p>If a filename is provided, <code>exp_log_file</code> will record
a transcript of the session (beginning at that point) in the file.
The <code>exp_log_file</code> command will stop recording if no
argument is given. Any previous log file is closed.</p>

<p>Instead of a filename, a Tcl file identifier may be provided by
using the <code>-open</code> or <code>-leaveopen</code> flags. This
is similar to the <code><a href="#exp_spawn">exp_spawn</a></code>
command.</p>

<p>The <code>-a</code> flag forces output to be logged that was
suppressed by the <code><a href=
"#exp_log_user">exp_log_user</a></code> command.</p>

<p>By default, the <code>exp_log_file</code> command
<em>appends</em> to old files rather than truncating them, for the
convenience of being able to turn logging off and on multiple times
in one session. To truncate files, use the <code>-noappend</code>
flag.</p>

<p>The <code>-info</code> flag causes <code>exp_log_file</code> to
return a description of the most recent non-info arguments
given.</p>
</dd>

<dt><a name="exp_log_user"><strong>exp_log_user</strong>
<em>-info|0|1</em></a></dt>

<dd>
<p>By default, the send/expect dialogue is logged to stdout (and a
log file if open). The logging to stdout is disabled by the command
"<code>exp_log_user 0</code>" and re-enabled by "<code>exp_log_user
1</code>". Logging to the log file is unchanged.</p>

<p>The <code>-info</code> flag causes log_user to return a
description of the most recent non-info arguments given.</p>
</dd>

<dt><a name="exp_match_max"><strong>exp_match_max</strong> <em>[-d]
[-i spawn_id] [size]</em></a></dt>

<dd>
<p>This command defines the size of the buffer (in bytes) used
internally by <code>expect</code>. With no <em>size</em> argument,
the current size is returned.</p>

<p>With the <code>-d</code> flag, the default size is set. (The
initial default is 2000.) With the <code>-i</code> flag, the size
is set for the named spawn id, otherwise it is set for the current
process.</p>
</dd>

<dt><a name="exp_open"><strong>exp_open</strong> <em>[args]</em>
<em>[-i</em> <em>spawn_id]</em></a></dt>

<dd>
<p><em>Not available on Windows.</em> On Unix systems, this returns
a Tcl file identifier that corresponds to the original spawn id.
The file identifier can then be used as if it were opened by Tcl's
<code>open</code> command.</p>

<!-- (The spawn id should no longer
be used. A <code>wait</code> should not be executed.</p>

<p>The <code>-leaveopen</code> flag leaves the spawn id open for
   access through Expect commands. A <code>wait</code> must be
   executed on the spawn id.</p> -->
</dd>

<dt><a name="exp_overlay"><strong><span class=
"doccmddeprecated">exp_overlay</span></strong> <em>[-# spawn_id]
[-# spawn_id] [...] program [args]</em></a></dt>

<dd>
<p><em>Not applicable on Windows.</em> On Unix systems, this
executes <em>program [args]</em> in place of the current Expect
program, which terminates.</p>

<!--A bare hyphen argument forces a hyphen in front of
   the command name as if it was a login shell. All spawn_ids are closed
   except for those named as arguments. These are mapped onto the named
   file identifiers.</p>

<p>Spawn_ids are mapped to file identifiers for the new program to
inherit. For example, the following line runs chess and allows it
to be controlled by the current process - say, a chess master.</p>

<pre>
    exp_overlay -0 $spawn_id -1 $spawn_id -2 $spawn_id chess
</pre>

<p>This is more efficient than "interact -u", however, it
sacrifices the ability to do programmed interaction since the
Expect process is no longer in control.</p>

<p>Note that no controlling terminal is provided. Thus, if you
disconnect or remap standard input, programs that do job control
(shells, login, etc) will not function properly.</p>

-->
</dd>

<dt><a name="exp_parity"><strong>exp_parity</strong> <em>[-d] [-i
spawn_id] [value]</em></a></dt>

<dd>
<p>This command defines whether parity should be retained or
stripped from the output of spawned processes. If <em>value</em> is
zero, parity is stripped, otherwise it is not stripped. With no
<em>value</em> argument, the current value is returned.</p>

<p>With the <code>-d</code> flag, the default parity value is set.
(The initial default is 1, i.e., parity is not stripped.) With the
<code>-i</code> flag, the parity value is set for the named spawn
id, otherwise it is set for the current process.</p>
</dd>

<dt><a name="exp_pid"><strong>exp_pid</strong> <em>[-i
spawn_id]</em></a></dt>

<dd>
<p>This command returns the process id corresponding to the
currently spawned process. If the <code>-i</code> flag is used, the
pid returned corresponds to that of the given spawn id.</p>
</dd>

<dt><a name="exp_remove_nulls"><strong>exp_remove_nulls</strong>
<em>[-d] [-i spawn_id] [value]</em></a></dt>

<dd>
<p>This command defines whether nulls are retained or removed from
the output of spawned processes before pattern matching or storing
in the variable <em>expect_out</em> or <em>interact_out</em>. If
<em>value</em> is 1, nulls are removed. If <em>value</em> is 0,
nulls are not removed. With no <em>value</em> argument, the current
value is returned.</p>

<p>With the <code>-d</code> flag, the default value is set. (The
initial default is 1, i.e., nulls are removed.) With the
<code>-i</code> flag, the value is set for the named spawn id,
otherwise it is set for the current process.</p>

<p>Whether or not nulls are removed, Expect will record null bytes
to the log and stdout.</p>
</dd>

<dt><a name="exp_send"><strong>exp_send</strong> <em>[-flags]
string</em></a></dt>

<dd>
<p>Sends <em>string</em> to the current process. For example, this
command will send the characters, h e l l o &lt;blank&gt; w o r l d
&lt;return&gt; to the current process:</p>

<pre>
    exp_send "hello world\r"
</pre>

<p>Tcl includes a <code>printf</code>-like command called <code><a
target="_blank" href=
"http://tcl.activestate.com/man/tcl8.4/TclCmd/format.htm">format</a></code>,
which can build arbitrarily complex strings.</p>

<p>Characters are sent immediately, although programs with
line-buffered input will not read the characters until a return
character is sent. A return character is denoted "\r".</p>

<p>The <code>--</code> flag forces the next argument to be
interpreted as a string rather than a flag. Any string can be
preceded by "--" whether or not it actually looks like a flag. This
provides a reliable mechanism to specify variable strings without
being confused by those that accidentally look like flags. (All
strings starting with "-" are reserved for future options.)</p>

<p>The <code>-i</code> flag declares that the string be sent to the
named spawn_id. If the spawn_id is <em>user_spawn_id</em>, and the
terminal is in raw mode, newlines in the string are translated to
return-newline sequences so that they appear as if the terminal was
in cooked mode. The <code>-raw</code> flag disables this
translation.</p>

<p>The <code>-null</code> flag sends null characters (0 bytes). By
default, one null is sent. An integer may follow the
<code>-null</code> to indicate how many nulls to send.</p>

<p><em>The <code>-break</code> flag is not available on
Windows.</em> On Unix systems, this flag generates a break
condition. This only makes sense if the spawn id refers to a tty
device opened via "exp_spawn -open". If you have spawned a process
such as tip, you should use tip's convention for generating a
break.</p>

<p>The <code>-s</code> flag forces output to be sent "slowly", thus
avoiding the common situation where a computer outtypes an input
buffer that was designed for a human who would never outtype the
same buffer. This output is controlled by the value of the variable
"send_slow" which takes a two-element list. The first element is an
integer that describes the number of bytes to send atomically. The
second element is a real number that sets the number of seconds by
which the atomic sends must be separated. For example, "set
send_slow {10 .001}" would force "send -s" to send strings with 1
millisecond in between each 10 characters sent.</p>

<p>The <code>-h</code> flag forces output to be sent (somewhat)
like a human actually typing. Human-like delays appear between the
characters. (The algorithm is based upon a Weibull distribution,
with modifications to suit this particular application.) This
output is controlled by the value of the variable "send_human",
which takes a five-element list:</p>

<ul>
<li>The first two elements are the average interarrival time of
characters in seconds: 

<ul>
<li>The first is used by default.</li>

<li>The second is used at word endings, to simulate the subtle
pauses that occasionally occur at such transitions.</li>
</ul>
</li>

<li>The third parameter is a measure of variability where .1 is
quite variable, 1 is reasonably variable, and 10 is quite
invariable. The extremes are 0 to infinity.</li>

<li>The last two parameters are, respectively, a minimum and
maximum interarrival time. The minimum and maximum are used last
and "clip" the final time. The ultimate average can be quite
different from the given average if the minimum and maximum clip
enough values.</li>
</ul>

<p>As an example, the following command emulates a fast and
consistent typist:</p>

<pre>
    set send_human {.1 .3 1 .05 2}
    exp_send -h "I'm hungry.  Let's do lunch."
</pre>

<p>The following might be more suitable after a hangover:</p>

<pre>
    set send_human {.4 .4 .2 .5 100}
    exp_send -h "Goodd party lash night!"
</pre>

<p>Note that errors are not simulated, although you can set up
error correction situations yourself by embedding mistakes and
corrections in an <code>exp_send</code> argument.</p>

<p>The flags for sending null characters, for sending breaks, for
forcing slow output and for human-style output are mutually
exclusive. Only the one specified last will be used. Furthermore,
no <em>string</em> argument can be specified with the flags for
sending null characters or breaks.</p>

<p>It is a good idea to precede the first <code>exp_send</code> to
a process by an <code><a href="#expect">expect</a></code>. The
<code>expect</code> command will wait for the process to start,
while <code>exp_send</code> cannot. In particular, if the first
<code>exp_send</code> completes before the process starts running,
you run the risk of having your data ignored. In situations where
interactive programs offer no initial prompt, you can precede
<code>exp_send</code> by a delay as in:</p>

<pre>
    <span class=
"doccodecomment"># To avoid giving hackers hints on how to break in,</span>
    <span class=
"doccodecomment"># this system does not prompt for an external password.</span>
    <span class=
"doccodecomment"># Wait for 5 seconds for exec to complete.</span>
    exp_spawn telnet very.secure.gov
    exp_sleep 5
    exp_send password\r
</pre>

<p>Expect for Windows does not implement a parser for VT100 codes
for special keypress codes such as "arrow up", F1, Home, etc.</p>
</dd>

<dt><a name="exp_send_error"><strong>exp_send_error</strong>
<em>[-flags] string</em></a></dt>

<dd>
<p>This command is like <code><a href=
"#exp_send">exp_send</a></code>, except that the output is sent to
stderr rather than the current process.</p>
</dd>

<dt><a name="exp_send_log"><strong>exp_send_log</strong> <em>[--]
string</em></a></dt>

<dd>
<p>This command is like <code>exp_send</code>, except that the
string is only sent to the log file (see <strong><a href=
"#exp_log_file">exp_log_file</a></strong> .) The arguments are
ignored if no log file is open.</p>
</dd>

<dt><a name="exp_send_tty"><strong>exp_send_tty</strong>
<em>[-flags] string</em></a></dt>

<dd>
<p>This command is like <code>exp_send</code>, except that the
output is sent to /dev/tty rather than the current process.</p>
</dd>

<dt><a name="exp_send_user"><strong>exp_send_user</strong>
<em>[-flags] string</em></a></dt>

<dd>
<p>This command is like <code>exp_send</code>, except that the
output is sent to stdout rather than the current process.</p>
</dd>

<dt><a name="exp_sleep"><strong>exp_sleep</strong>
<em>seconds</em></a></dt>

<dd>
<p>This command causes the script to sleep for the given number of
seconds. Seconds may be a decimal number. Interrupts (and Tk events
if you are using Expectk) are processed while Expect sleeps. It is
better to use Tcl's <code><a target="_blank" href=
"http://tcl.activestate.com/man/tcl8.4/TclCmd/after.htm">after</a></code>
command instead.</p>
</dd>

<dt><a name="exp_spawn"><strong>exp_spawn</strong> <em>[args]
program [args]</em></a></dt>

<dd>
<p>This command creates a new process running <em>program
args</em>. Its stdin, stdout and stderr are connected to Expect, so
that they may be read and written by other Expect commands. The
connection is broken by <code><a href=
"#exp_close">exp_close</a></code> or by the process itself closing
any of the file identifiers.</p>

<p>When a process is started by <code>exp_spawn</code>, the
variable <em>spawn_id</em> is set to a descriptor referring to that
process. The process described by <em>spawn_id</em> is considered
the <em>current process</em>. The <em>spawn_id</em> variable may be
read or written, in effect providing job control.</p>

<p><em>user_spawn_id</em> is a global variable containing a
descriptor that refers to the user. For example, when
<em>spawn_id</em> is set to this value, <code><a href=
"#expect">expect</a></code> behaves like <code><a href=
"#expect_user">expect_user</a></code>.</p>

<p><em>error_spawn_id</em> is a global variable containing a
descriptor that refers to the standard error. For example, when
<em>spawn_id</em> is set to this value, <code><a href=
"#exp_send">exp_send</a></code> behaves like <code><a href=
"#exp_send_error">exp_send_error</a></code>.</p>

<p><em>tty_spawn_id</em> is a global variable containing a
descriptor that refers to /dev/tty. If /dev/tty does not exist
(such as in a cron, at, or batch script), then
<em>tty_spawn_id</em> is not defined. This may be tested as:</p>

<pre>
    if {[info vars tty_spawn_id]} {
        <span class="doccodecomment"># /dev/tty exists</span>
    } else {
        <span class=
"doccodecomment"># /dev/tty doesn't exist</span>
        <span class=
"doccodecomment"># probably in cron, batch, or at script</span>
    }
</pre>

<p><code>exp_spawn</code> returns the Unix process id. If no
process is spawned, 0 is returned. The variable
<em>spawn_out(slave,name)</em> is set to the name of the pty slave
device.</p>

<p>By default, <code>exp_spawn</code> echoes the command name and
arguments. The <code>-noecho</code> flag stops
<code>exp_spawn</code> from doing this.</p>

<p>The <code>-console</code> flag causes console output to be
redirected to the spawned process. This is not supported on all
systems.</p>

<!--VERIFY:Does this need to be replaced with Windows specific
onfirmation on exp_spawn? -->
<p>Internally, <code>exp_spawn</code> uses a pty, initialized the
same way as the user's tty. This is further initialized so that all
settings are "sane" (according to stty(1)). If the variable
<em>stty_init</em> is defined, it is interpreted in the style of
stty arguments as further configuration. For example, "<code>set
stty_init raw</code>" will cause further spawned processes's
terminals to start in raw mode. The <code>-nottycopy</code> flag
skips the initialization based on the user's tty. The
<code>-nottyinit</code> flag skips the "sane" initialization.</p>

<p>Normally, <code>exp_spawn</code> takes little time to execute.
If you notice spawn taking a significant amount of time, it is
probably encountering ptys that are wedged. A number of tests are
run on ptys to avoid entanglements with errant processes. (These
take 10 seconds per wedged pty.) Running Expect with the
<code>-d</code> option will show if Expect is encountering many
ptys in odd states. If you cannot kill the processes to which these
ptys are attached, your only recourse may be to reboot.</p>

<p>If a program cannot be spawned successfully because
<code>exec</code> fails (e.g. when the program doesn't exist), an
error message will be returned by the next <code>expect</code>
command as if the program had run and produced the error message as
output. This behavior is a natural consequence of the
implementation of <code>exp_spawn</code>. Internally, spawn forks,
after which the spawned process has no way to communicate with the
original Expect process except by communication via the
spawn_id.</p>

<p>The <code>-open</code> flag causes the next argument to be
interpreted as a Tcl file identifier (i.e., returned by
<code>exp_open</code>.) The spawn id can then be used as if it were
a spawned process. (The file identifier should no longer be used.)
This lets you treat raw devices, files, and pipelines as spawned
processes without using a pty. 0 is returned to indicate there is
no associated process. When the connection to the spawned process
is closed, so is the Tcl file identifier. The
<code>-leaveopen</code> flag is similar to <code>-open</code>
except that <code>-leaveopen</code> causes the file identifier to
be left open even after the spawn id is closed.</p>

<p>The <code>-pty</code> flag causes a pty to be opened but no
process to be spawned. 0 is returned to indicate there is no
associated process. <em>spawn_id</em> is set as usual.</p>

<p>The variable <em>spawn_out(slave,fd)</em> is set to a file
identifier corresponding to the pty slave. It can be closed using
"close -slave".</p>

<p><em>The <code>-ignore</code> flag is not implemented on
Windows.</em> On Unix systems, this flag names a signal to be
ignored in the spawned process. Otherwise, signals get the default
behavior. Signals are named as in the <code>exp_trap</code>
command, except that each signal requires a separate flag.</p>

<!--NEW: -->
<p>The <code>-environment</code> flag takes a list of name/value
pairs in the form <code><a target="_blank" href=
"http://tcl.activestate.com/man/tcl8.4/TclCmd/array.htm#M8">array
get</a></code> would return to represent the environment to
use.</p>

<p>The <code>-directory</code> flag sets the starting directory for
the spawned process.</p>

<p><em>The <code>-trap</code> flag is not available on
Windows.</em></p>
</dd>

<dt><a name="exp_strace"><strong>exp_strace</strong>
<em>level</em></a></dt>

<dd>
<p>This command causes following statements to be printed before
being executed. (Tcl's trace command traces variables.)
<em>level</em> indicates how far down in the call stack to trace.
For example, the following command runs Expect while tracing the
first 4 levels of calls, but none below that.</p>

<!--TO-DO: get different usage - no expect binary -->
<pre>
    expect -c "strace 4" script.exp
</pre>

<p>The <code>-info</code> flag causes strace to return a
description of the most recent non-info arguments given.</p>
</dd>

<dt><a name="exp_stty"><strong>exp_stty</strong>
<em>args</em></a></dt>

<dd>
<p>This command changes terminal modes similarly to the external
stty command. <em>On Windows, <code>exp_stty</code> does not do
redirection or accept the rows or columns options.</em></p>

<p>By default, the controlling terminal is accessed. On Unix
systems, other terminals can be accessed by appending "&lt;
/dev/tty..." to the command. (Note that the arguments should not be
grouped into a single argument.)</p>

<p>Requests for status return it as the result of the command. If
no status is requested and the controlling terminal is accessed,
the previous status of the raw and echo attributes are returned in
a form that can later be used by the command.</p>

<p>For example, the arguments <code>raw</code> or
<code>-cooked</code> put the terminal into raw mode. The arguments
<code>-raw</code> or <code>cooked</code> put the terminal into
cooked mode. The arguments <code>echo</code> and <code>-echo</code>
put the terminal into echo and noecho mode respectively.</p>

<p>The following example illustrates how to temporarily disable
echoing. This could be used in otherwise automatic scripts to avoid
embedding passwords.</p>

<pre>
    exp_stty -echo
    exp_send_user "Password: "
    expect_user -re "(.*)\n"
    set password $expect_out(1,string)
    exp_stty echo
</pre>
</dd>

<dt><a name="exp_system"><strong><span class=
"doccmddeprecated">exp_system</span></strong>
<em>args</em></a></dt>

<dd>
<p><em>Not applicable on Windows - use Tcl's <a target="_blank"
href=
"http://tcl.activestate.com/man/tcl8.4/TclCmd/exec.htm"><code>exec</code></a>
command instead.</em> On Unix systems, this gives <em>args</em> to
sh as input, just as if it had been typed as a command from a
terminal. Expect waits until the shell terminates. The return
status from sh is handled the same way that <code>exec</code>
handles its return status.</p>

<!--
<p>In contrast to <code>exec</code> which redirects stdin and stdout to
the script, <code>exp_system</code> performs no redirection (other than that
indicated by the string itself). Thus, it is possible to use
programs which must talk directly to /dev/tty. For the same reason,
the results of <code>exp_system</code> are not recorded in the log.</p>

-->
</dd>

<dt><a name="exp_timestamp"><strong>exp_timestamp</strong>
<em>[args]</em></a></dt>

<dd>
<p>This command returns a timestamp. With no arguments, the number
of seconds since the epoch is returned. Use Tcl's
<code>clock</code> command instead.</p>

<p>The <code>-format</code> flag introduces a string that is
returned, but with substitutions made according to the POSIX rules
for strftime. For example <code>%a</code> is replaced by an
abbreviated weekday name (i.e., Sat). Others are:<br>
</p>

<ul>
<li><code>%a</code> - abbreviated weekday name</li>

<li><code>%A</code> - full weekday name</li>

<li><code>%b</code> - abbreviated month name</li>

<li><code>%B</code> - full month name</li>

<li><code>%c</code> - date-time as in: Wed Oct 6 11:45:56 1993</li>

<li><code>%d</code> - day of the month (01-31)</li>

<li><code>%H</code> - hour (00-23)</li>

<li><code>%I</code> - hour (01-12)</li>

<li><code>%j</code> - day (001-366)</li>

<li><code>%m</code> - month (01-12)</li>

<li><code>%M</code> - minute (00-59)</li>

<li><code>%p</code> - am or pm</li>

<li><code>%S</code> - second (00-61)</li>

<li><code>%u</code> - day (1-7, Monday is first day of week)</li>

<li><code>%U</code> - week (00-53, first Sunday is first day of
week one)</li>

<li><code>%V</code> - week (01-53, ISO 8601 style)</li>

<li><code>%w</code> - day (0-6)</li>

<li><code>%W</code> - week (00-53, first Monday is first day of
week one)</li>

<li><code>%x</code> - date-time as in: Wed Oct 6 1993</li>

<li><code>%X</code> - time as in: 23:59:59</li>

<li><code>%y</code> - year (00-99)</li>

<li><code>%Y</code> - year as in: 1993</li>

<li><code>%Z</code> - timezone (or nothing if not
determinable)</li>

<li><code>%%</code> - a bare percent sign</li>
</ul>

<p>Other % specifications are undefined. Other characters will be
passed through untouched. Only the C locale is supported.</p>

<p>The <code>-seconds</code> flag introduces a number of seconds
since the epoch to be used as a source from which to format.
Otherwise, the current time is used.</p>

<p>The <code>-gmt</code> flag forces timestamp output to use the
GMT timezone. With no flag, the local timezone is used.</p>
</dd>

<dt><a name="exp_trap"><strong>exp_trap</strong> <em>[[command]
signals]</em></a></dt>

<dd>
<p>This causes the given <em>command</em> to be executed upon
future receipt of any of the given signals. The command is executed
in the global scope. If <em>command</em> is absent, the signal
action is returned. If <em>command</em> is the string SIG_IGN, the
signals are ignored. If <em>command</em> is the string SIG_DFL, the
signals are reset to the system default. The <em>signals</em>
argument is either a single signal or a list of signals.</p>

<p>Signal manipulation beyond the seven signals abstracted via
ANSI's signal.h is not supported on Windows, nor are
Windows-specific ones such as <code>CTRL_SHUTDOWN_EVENT</code>. 
<!--VERIFY: N/A on Windows?  
<p>Signals may be specified numerically or symbolically as per <a
href="man:signal(3)">signal(3)</a> . The "SIG" prefix may be
omitted.</p> -->
</p>

<p>With no arguments (or the argument <code>-number</code>),
<code>exp_trap</code> returns the signal number of the trap command
currently being executed.</p>

<p>The <code>-code</code> flag uses the return code of the command
in place of whatever code Tcl was about to return when the command
originally started running.</p>

<p>The <code>-interp</code> flag causes the command to be evaluated
using the interpreter active at the time the command started
running, rather than when the trap was declared.</p>

<p>The <code>-name</code> flag causes the <code>exp_trap</code>
command to return the signal name of the trap command currently
being executed.</p>

<p>The <code>-max</code> flag causes the <code>exp_trap</code>
command to return the largest signal number that can be set.</p>

<p>For example, the command <code>"exp_trap {exp_send_user "Ouch!"}
SIGINT"</code> will print "Ouch!" each time the user presses
^C.</p>

<p>By default, SIGINT (which can usually be generated by pressing
^C) and SIGTERM cause Expect to exit. This is due to the following
trap, created by default when Expect starts.</p>

<pre>
    exp_trap exit {SIGINT SIGTERM}
</pre>

<p>If you use the -D flag to start the debugger, SIGINT is
redefined to start the interactive debugger. This is due to the
following trap:</p>

<pre>
    exp_trap {exp_debug 1} SIGINT
</pre>

<p>The debugger trap can be changed by setting the environment
variable EXPECT_DEBUG_INIT to a new trap command.</p>

<p>You can, of course, override both of these just by adding trap
commands to your script. In particular, if you have your own
"<code>exp_trap exit SIGINT</code>", this will override the
debugger trap. This is useful if you want to prevent users from
getting to the debugger at all.</p>

<p>If you want to define your own trap on SIGINT but still trap to
the debugger when it is running, use:</p>

<pre>
    if {![exp_debug]} {exp_trap mystuff SIGINT}
</pre>

<p>Alternatively, you can trap to the debugger using some other
signal.</p>

<p>The <code>exp_trap</code> command will not let you override the
action for SIGALRM as this is used internally to Expect. The
disconnect command sets SIGALRM to SIG_IGN (ignore). You can
re-enable this as long as you disable it during subsequent spawn
commands.</p>
</dd>

<dt><a name="exp_version"><strong>exp_version</strong>
<em>[[-exit]</em> <em>version]</em></a></dt>

<dd>
<p>This command is useful for assuring that the script is
compatible with the current version of Expect, however, the more
modern "<code>package require Expect <em>[version]</em></code>"
command should be used instead.</p>

<!--VERIFY: Could this be removed?

<p>With no arguments, the current version of Expect is
returned. This version may then be encoded in your script. If you
actually know that you are not using features of recent versions,
you can specify an earlier version.</p>

<p>Versions consist of three numbers separated by dots. First is
the major number. Scripts written for versions of Expect
with a different major number will almost certainly not work.
<code>exp_version</code> returns an error if the major numbers do not
match.</p>

<p>Second is the minor number. Scripts written for a version with a
greater minor number than the current version may depend upon some
new feature and might not run. <code>exp_version</code> returns an error
if the major numbers match, but the script minor number is greater
than that of the running Expect.</p>

<p>Third is a number that plays no part in the version comparison.
However, it is incremented when the Expect software
distribution is changed in any way, such as by additional
documentation or optimization. It is reset to 0 upon each new minor
version.</p> 

<p>With the <code>-exit</code> flag, Expect prints
an error and exits if the version is out of date.</p> -->
</dd>

<dt><a name="exp_wait"><strong>exp_wait</strong>
<em>[args]</em></a></dt>

<dd>
<p>This command delays until a spawned process (or the current
process if none is named) terminates.</p>

<p><code>exp_wait</code> normally returns a list of four integers.
The first integer is the pid of the process that was waited upon.
The second integer is the corresponding spawn id. The third integer
is -1 if an operating system error occurred, or 0 otherwise. If the
third integer was 0, the fourth integer is the status returned by
the spawned process. If the third integer was -1, the fourth
integer is the value of errno set by the operating system. The
global variable errorCode is also set.</p>

<!--Also, <code>[exp_wait]</code> is
limited in the same way for signal exits, as is the core's
<code>Tcl_WaitPid()</code> which it uses.</li>


<p>Additional elements may appear at the end of the return value
from <code>exp_wait</code>. An optional fifth element identifies a class of
information. Currently, the only possible value for this element is
CHILDKILLED in which case the next two values are the C-style
signal name and a short textual description.</p>

<p>The <code>-i</code> flag declares the process to wait corresponding to
the named spawn_id (NOT the process id). Inside a SIGCHLD handler,
it is possible to wait for any spawned process by using the spawn
id -1.</p>

<p>The <code>-nowait</code> flag causes the wait to return immediately
with the indication of a successful wait. When the process exits
(later), it will automatically disappear without the need for an
explicit wait.</p>

<p>The <code>exp_wait</code> command may also be used wait for a forked
process using the arguments "-i -1". Unlike its use with
spawned processes, this command can be executed at any time. There
is no control over which process is reaped. However, the return
value can be checked for the process id.</p>
-->
</dd>

<dt><a name="expect"><strong>expect</strong> <em>[[-opts] pat1
body1] ... [-opts] patn [bodyn]</em></a></dt>

<dd>
<p>This command waits until one of the patterns matches the output
of a spawned process, a specified time period has passed, or an
end-of-file is seen. If the final body is empty, it may be
omitted.</p>

<p>Patterns from the most recent <code><a href=
"#expect_before">expect_before</a></code> command are implicitly
used before any other patterns. Patterns from the most recent
<code><a href="#expect_after">expect_after</a></code> command are
implicitly used after any other patterns.</p>

<p>If the arguments to the entire <code>expect</code> statement
require more than one line, all arguments may be "braced" into one
so as to avoid terminating each line with a backslash. In this one
case, the usual Tcl substitutions will occur despite the
braces.</p>

<p>If a pattern is the keyword <code>eof</code>, the corresponding
body is executed upon end-of-file. If a pattern is the keyword
<code>timeout</code>, the corresponding body is executed upon
timeout. If no timeout keyword is used, an implicit null action is
executed upon timeout. The default timeout period is 10 seconds but
may be set, for example to 30, by the command "set timeout 30". An
infinite timeout may be designated by the value -1. If a pattern is
the keyword <code>default</code>, the corresponding body is
executed upon either timeout or end-of-file.</p>

<p>If a pattern matches, then the corresponding body is executed.
The <code>expect</code> command returns the result of the body (or
the empty string if no pattern matched). In the event that multiple
patterns match, the one appearing first is used to select a
body.</p>

<p>Each time new output arrives, it is compared to each of the
patterns in the order they are listed. Thus, you may test for
absence of a match by making the last pattern something guaranteed
to appear, such as a prompt. In situations where there is no
prompt, you must use <code>timeout</code> as you would if you were
interacting with the program manually.</p>

<p>Patterns are specified in three ways. By default, patterns are
specified as with Tcl's <code><a target="_blank" href=
"http://tcl.activestate.com/man/tcl8.4/TclCmd/string.htm#M35">string
match</a></code> command. (Such patterns are also similar to
C-shell regular expressions usually referred to as "glob"
patterns). The <code>-gl</code> flag may be used to protect
patterns that might otherwise match <code>expect</code> flags from
doing so. Any pattern beginning with a "-" should be protected this
way. (All strings starting with "-" are reserved for future
options.)</p>

<p>For example, the following fragment looks for a successful
login. Note that <code>abort</code> is presumed to be a procedure
defined elsewhere in the script.</p>

<pre>
    expect {
        busy       {puts busy\n ; exp_continue}
        -re "failed|invalid password" abort
        timeout    abort
        connected
    }
</pre>

<p>Quotes are necessary on the fourth pattern since it contains a
space, which would otherwise separate the pattern from the action.
Patterns with the same action (such as the 3rd and 4th) require
listing the actions again. This can be avoided by using
regexp-style patterns (see below). More information on forming <a
target="_blank" href=
"http://tcl.activestate.com/man/tcl8.4/TclCmd/glob.htm">glob</a>
patterns can be found in the Tcl manual.</p>

<p>Regexp-style patterns follow the syntax defined by Tcl's
<code><a target="_blank" href=
"http://tcl.activestate.com/man/tcl8.4/TclCmd/regexp.htm">regexp</a></code>
(short for "regular expression") command. An introduction to
writing regular expressions can be found in the <a href=
"regex.html">Regular Expression Primer</a>. <code>regexp</code>
patterns are introduced with the flag <code>-re</code>. The
previous example can be rewritten using a regexp as:</p>

<pre>
    expect {
        busy       {puts busy\n ; exp_continue}
        -re "failed|invalid password" abort
        timeout    abort
        connected
    }
</pre>

<p>Both types of patterns are "unanchored". This means that
patterns do not have to match the entire string, but can begin and
end the match anywhere in the string (as long as everything else
matches). Use ^ to match the beginning of a string, and $ to match
the end. Note that if you do not wait for the end of a string, your
responses can easily end up in the middle of the string as they are
echoed from the spawned process. While still producing correct
results, the output can look unnatural. Thus, use of $ is
encouraged if you can exactly describe the characters at the end of
a string.</p>

<p>Note that in many editors, the ^ and $ match the beginning and
end of lines respectively. However, because <code>expect</code> is
not line oriented, these characters match the beginning and end of
the data (as opposed to lines) currently in the <code>expect</code>
matching buffer. (Also, see the note below on "system
indigestion.")</p>

<p>The <code>-ex</code> flag causes the pattern to be matched as an
"exact" string. No interpretation of *, ^, etc is made (although
the usual Tcl conventions must still be observed). Exact patterns
are always unanchored.</p>

<p>The <code>-nocase</code> flag causes uppercase characters of the
output to compare as if they were lowercase characters. The pattern
is not affected.</p>

<p>While reading output, more than 2000 bytes can force earlier
bytes to be "forgotten". This may be changed with the function
<code>match_max</code>. (Note that excessively large values can
slow down the pattern matcher.) If <em>patlist</em> is
<code>full_buffer</code>, the corresponding body is executed if
<code>match_max</code> bytes have been received and no other
patterns have matched. Whether or not the <code>full_buffer</code>
keyword is used, the forgotten characters are written to
<em>expect_out(buffer)</em>.</p>

<p>If <em>patlist</em> is the keyword <code>null</code>, and nulls
are allowed (via the <code>remove_nulls</code> command), the
corresponding body is executed if a single ASCII 0 is matched. It
is not possible to match 0 bytes via glob or regexp patterns.</p>

<p>Upon matching a pattern (or eof or full_buffer), any matching
and previously unmatched output is saved in the variable
<em>expect_out(buffer)</em>. Up to 9 regexp substring matches are
saved in the variables <em>expect_out(1,string)</em> through
<em>expect_out(9,string)</em>. If the <code>-indices</code> flag is
used before a pattern, the starting and ending indices (in a form
suitable for <code><a target="_blank" href=
"http://tcl.activestate.com/man/tcl8.4/TclCmd/lrange.htm">lrange</a></code>)
of the 10 strings are stored in the variables
<em>expect_out(X,start)</em> and <em>expect_out(X,end)</em> where X
is a digit, corresponds to the substring position in the buffer. 0
refers to strings that matched the entire pattern and is generated
for glob patterns as well as regexp patterns. For example, if a
process has produced output of "abcdefgh\n", the result of:</p>

<pre>
    expect "cd"
</pre>

<p>is as if the following statements had executed:</p>

<pre>
    set expect_out(0,string) cd
    set expect_out(buffer) abcd
</pre>

<p>and "efgh\n" is left in the output buffer. If a process produced
the output "abbbcabkkkka\n", the result of:</p>

<pre>
    expect -indices -re "b(b*).*(k+)"
</pre>

<p>is as if the following statements had executed:</p>

<pre>
    set expect_out(0,start) 1
    set expect_out(0,end) 10
    set expect_out(0,string) bbbcabkkkk set expect_out(1,start) 2
    set expect_out(1,end) 3
    set expect_out(1,string) bb
    set expect_out(2,start) 10
    set expect_out(2,end) 10
    set expect_out(2,string) k
    set expect_out(buffer) abbbcabkkkk
</pre>

<p>and "a\n" is left in the output buffer. The pattern "*" (and -re
".*") will flush the output buffer without reading any more output
from the process.</p>

<p>Normally, the matched output is discarded from Expect's internal
buffers. This may be prevented by prefixing a pattern with the
<code>-notransfer</code> flag. This flag is especially useful in
experimenting (and can be abbreviated to "<code>-not</code>" for
convenience).</p>

<p>The spawn id associated with the matching output (or eof or
full_buffer) is stored in <em>expect_out(spawn_id)</em>.</p>

<p>The <code>-timeout</code> flag causes the current expect command
to use the following value as a timeout instead of using the value
of the timeout variable.</p>

<p>By default, patterns are matched against output from the current
process, however the <code>-i</code> flag declares the output from
the named spawn_id list be matched against any following patterns
(up to the next <code>-i</code>). The spawn_id list should either
be a whitespace separated list of spawn_ids or a variable referring
to such a list of spawn_ids.</p>

<p>For example, the following example waits for "connected" from
the current process, or "busy", "failed" or "invalid password" from
the spawn_id named by $proc2.</p>

<pre>
    expect {
        -i $proc2 busy {puts busy\n ; exp_continue}
        -re "failed|invalid password" abort
        timeout abort
        connected
    }
</pre>

<p>The value of the global variable <em>any_spawn_id</em> may be
used to match patterns to any spawn_ids that are named with all
other <strong>- i</strong> flags in the current <code>expect</code>
command. The spawn_id from a <code>-i</code> flag with no
associated pattern (i.e., followed immediately by another
<code>-i</code>) is made available to any other patterns in the
same <code>expect</code> command associated with
<em>any_spawn_id.</em></p>

<p>The <code>-i</code> flag may also name a global variable, in
which case the variable is read for a list of spawn ids. The
variable is reread whenever it changes. This provides a way of
changing the I/O source while the command is in execution. Spawn
ids provided this way are called "indirect" spawn ids.</p>

<p>Actions such as <code><a target="_blank" href=
"http://tcl.activestate.com/man/tcl8.4/TclCmd/break.htm">break</a></code>
and <code><a target="_blank" href=
"http://tcl.activestate.com/man/tcl8.4/TclCmd/continue.htm">continue</a></code>
cause control structures (i.e., <code><a target="_blank" href=
"http://tcl.activestate.com/man/tcl8.4/TclCmd/for.htm">for</a></code>,
<code><a target="_blank" href=
"http://tcl.activestate.com/man/tcl8.4/TclCmd/proc">proc</a></code>)
to behave in the usual way. The command <code><a href=
"#exp_continue">exp_continue</a></code> allows <code>expect</code>
itself to continue executing rather than returning as it normally
would.</p>

<p>This is useful for avoiding explicit loops or repeated expect
statements. The following example is part of a fragment to automate
rlogin. The <code>exp_continue</code> avoids having to write a
second <code>expect</code> statement (to look for the prompt again)
if the rlogin prompts for a password.</p>

<pre>
    expect {
        Password: {
            exp_stty -echo
            exp_send_user "password (for $user) on $host: "
            expect_user -re "(.*)\n"
            exp_send_user "\n"
            exp_send "$expect_out(1,string)\r"
            exp_stty echo
            exp_continue
        } incorrect {
            send_user "invalid password or account\n"
            exit
        } timeout {
            send_user "connection to $host timed out\n"
            exit
        } eof {
            exp_send_user \
                "connection to host failed: $expect_out(buffer)"
            exp_exit
        } -re $prompt
    }
</pre>

<p>For example, the following fragment might help a user guide an
interaction that is already totally automated. In this case, the
terminal is put into raw mode. If the user presses "+", a variable
is incremented. If "p" is pressed, several returns are sent to the
process, perhaps to poke it in some way.
<!--, and "i" lets the user interact
with the process, effectively stealing away control from the script.-->
In each case, the <code><a href=
"#exp_continue">exp_continue</a></code> allows the current
<code>expect</code> to continue pattern matching after executing
the current action.</p>

<!--TO-DO:Replace interact line? -->
<pre>
    stty raw -echo
    expect_after {
        -i $user_spawn_id
        "p" {send "\r\r\r"; exp_continue}
        "+" {incr foo; exp_continue}
<!--        "i" {interact; exp_continue}-->
        "quit" exit
    }
</pre>

<p>By default, <code>exp_continue</code> resets the timeout timer.
The timer is not restarted, if <code>exp_continue</code> is called
with the <code>-continue_timer</code> flag.</p>
</dd>

<dt><a name="expect_after"><strong>expect_after</strong>
<em>[expect_args]</em></a></dt>

<dd>
<p>This command works identically to the <code><a href=
"#expect_before">expect_before</a></code> command except that if
patterns from both <code>expect</code> and
<code>expect_after</code> can match, the <code>expect</code>
pattern is used.</p>
</dd>

<dt><a name="expect_background"><strong>expect_background</strong>
<em>[expect_args]</em></a></dt>

<dd>
<p>This command takes the same arguments as <code>expect</code>,
however it returns immediately. Patterns are tested whenever new
input arrives. The patterns <code>timeout</code> and
<code>default</code> are meaningless to
<code>expect_background</code> and are silently discarded.
Otherwise, the <code>expect_background</code> command uses
<code>expect_before</code> and <code>expect_after</code> patterns
just like <code>expect</code> does.</p>

<p>When <code>expect_background</code> actions are being evaluated,
background processing for the same spawn id is blocked. Background
processing is unblocked when the action completes. While background
processing is blocked, it is possible to do a (foreground)
<code>expect</code> on the same spawn id.</p>

<p>It is not possible to execute an <code>expect</code> while an
<code>expect_background</code> is unblocked. The
<code>expect_background</code> for a particular spawn id is deleted
by declaring a new <code>expect_background</code> with the same
spawn id. Declaring <code>expect_background</code> with no pattern
removes the given spawn id from the ability to match patterns in
the background.</p>
</dd>

<dt><a name="expect_before"><strong>expect_before</strong>
<em>[expect_args]</em></a></dt>

<dd>
<p>This command takes the same arguments as <code><a href=
"#expect">expect</a></code> does, however it returns immediately.
Pattern-action pairs from the most recent
<code>expect_before</code> with the same spawn id are implicitly
added to any following <code>expect</code> commands. If a pattern
matches, it is treated as if it had been specified in the
<code>expect</code> command itself, and the associated body is
executed in the context of the <code>expect</code> command. If
patterns from both <code>expect_before</code> and
<code>expect</code> can match, the <code>expect_before</code>
pattern is used.</p>

<p>If no pattern is specified, the spawn id is not checked for any
patterns.</p>

<p>Unless overridden by a <code>-i</code> flag,
<code>expect_before</code> patterns match against the spawn id
defined at the time that the <code>expect_before</code> command was
executed (not when its pattern is matched).</p>

<p>The <code>-info</code> flag causes <code>expect_before</code> to
return the current specifications of what patterns it will match.
By default, it reports on the current spawn id. An optional spawn
id specification may be given for information on that spawn id. For
example</p>

<pre>
    expect_before -info -i $proc
</pre>

<p>At the most, one spawn id specification may be given. The flag
<code>-indirect</code> suppresses direct spawn ids that come only
from indirect specifications.</p>

<p>Instead of a spawn id specification, the flag <code>-all</code>
will cause <code>-info</code> to report on all spawn ids.</p>

<p>The output of the <code>-info</code> flag can be reused as the
argument to <code>expect_before</code>.</p>
</dd>

<dt><a name="expect_tty"><strong>expect_tty</strong>
<em>[expect_args]</em></a></dt>

<dd>
<p>This command is like <code><a href="#expect">expect</a></code>
but it reads characters from /dev/tty (i.e. keystrokes from the
user). By default, reading is performed in cooked mode. Thus, lines
must end with a return in order for <code>expect</code> to see
them. This may be changed via <code><a href=
"#exp_stty">exp_stty</a></code>.</p>
</dd>

<dt><a name="expect_user"><strong>expect_user</strong>
<em>[expect_args]</em></a></dt>

<dd>
<p>This command is like <code><a href="#expect">expect</a></code>
but it reads characters from stdin (i.e. keystrokes from the user).
By default, reading is performed in cooked mode. Thus, lines must
end with a return in order for <code>expect</code> to see them.
This may be changed via <code><a href=
"#exp_stty">exp_stty</a></code>.</p>
</dd>
</dl>

<a class="topText" href="#top"><img alt="Top" src="images/top.gif"
height="11" width="11" border="0">Top</a> 

<h2><a name="libraries"><strong>Libraries</strong></a></h2>

<p>Expect automatically knows about two built-in libraries for
Expect scripts. These are defined by the directories named in the
variables <code>exp_library</code> and
<code>exp_exec_library</code>. Both are meant to contain utility
files that can be used by other scripts. exp_library contains
architecture-independent files. exp_exec_library contains
architecture-dependent files. Depending on your system, both
directories may be totally empty. The existence of the file
$exp_exec_library/catbuffers describes whether your /bin/cat
buffers by default.</p>

<a class="topText" href="#top"><img alt="Top" src="images/top.gif"
height="11" width="11" border="0">Top</a> 
<!--<h2><a name="differences"><strong>Differences between the Unix and Windows Version</strong></a></h2>

<p>Differences in the behavior of specific Expect
   commands on Windows are detailed in the command reference above.
   Additionally, the following behaviors are limited:</p>

<ul>
  <li>There is no creation of tty channels when they aren't already
      given to the application. This is not applicable on Unix&nbsp;for
      example, if <code>CreateFile("CONOUT$")</code> fails when asking
      for the existing tty channel, there is no recourse in the generic
      layer to create one. Only a single console window is allowed per
      process on Windows. This affects <code>exp_send_tty</code> and
      <code>expect_tty</code>, and is a prerequisite for enabling
      <code>exp_interact</code>.</li>
  
  <li>Signal manipulation beyond the seven signals abstracted via ANSI's
      signal.h is not supported, nor are windows-specific ones such as
      <code>CTRL_SHUTDOWN_EVENT</code>. Also, <code>[exp_wait]</code> is
      limited in the same way for signal exits, as is the core's
      <code>Tcl_WaitPid()</code> which it uses.</li>
</ul>

<p>The following behaviors are not available at this time:</p>

<ul>
  <li>The Expect clib is not available at this time.</li>
  <li>An Expect channel can not be moved to a different thread with
      <code>[thread::transfer]</code>&nbsp;this is a limitation of Tcl's
      channel API.</li>
</ul>-->
 <!--TO-DO: insert a list of commands NOT available on Windows
-->
<!--Caveats section removed and put into ex_usage.html-->
<hr>
</body>
</html>

