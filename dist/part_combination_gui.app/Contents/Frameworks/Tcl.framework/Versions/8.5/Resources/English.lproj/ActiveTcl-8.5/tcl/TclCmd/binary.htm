<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<meta name="generator" content="HTML Tidy, see www.w3.org">
<meta name='Author' content='ActiveState'>
<link rel='stylesheet' type='text/css' href='../../aspn.css'>
<title>Tcl Built-In Commands - binary manual page</title>
<link rel="stylesheet" href="../docs.css" type="text/css" media=
"all">
</head>
<body>
<div class="banner">
<table width="100%" border="0" cellspacing="0" cellpadding="3">
<tr>
<td align="left"><a target="_blank" href=
"http://www.activestate.com/activetcl"><img src=
"../../images/ActiveTcl.gif" border="0" align="left" alt=
"ActiveTcl"></a> </td>
<td align="center" class="heading">ActiveTcl User Guide</td>
<td align="right"><a target="_blank" href=
"http://www.activestate.com"><img src="../../images/AS_logo.gif"
border="0" align="right" alt="ActiveState Software Inc."></a> </td>
</tr>
</table>
</div>

<br>
<h2><a href="../contents.htm">Tcl/Tk Documentation</a>
<small>&gt;</small> <a href="contents.htm">TclCmd</a>
<small>&gt;</small> binary</h2>

<h3><a href="../UserCmd/contents.htm">Tcl/Tk Applications</a> | <a
href="../TclCmd/contents.htm">Tcl Commands</a> | <a href=
"../TkCmd/contents.htm">Tk Commands</a> | <a href=
"../TclLib/contents.htm">Tcl Library</a> | <a href=
"../TkLib/contents.htm">Tk Library</a></h3>

<dl>
<dd><a href="binary.htm#M2" name="L49">NAME</a> 

<dl>
<dd>binary - Insert and extract fields from binary strings</dd>
</dl>
</dd>

<dd><a href="binary.htm#M3" name="L50">SYNOPSIS</a> 

<dl>
<dd><b>binary format</b> <i>formatString</i> ?<i>arg arg
...</i>?</dd>

<dd><b>binary scan</b> <i>string formatString</i> ?<i>varName
varName ...</i>?</dd>
</dl>
</dd>

<dd><a href="binary.htm#M4" name="L51">DESCRIPTION</a></dd>

<dd><a href="binary.htm#M5" name="L52">BINARY FORMAT</a> 

<dl class="binary format">
<dd><a href="binary.htm#M6" name="L53"><b>a</b></a></dd>

<dd><a href="binary.htm#M7" name="L54"><b>A</b></a></dd>

<dd><a href="binary.htm#M8" name="L55"><b>b</b></a></dd>

<dd><a href="binary.htm#M9" name="L56"><b>B</b></a></dd>

<dd><a href="binary.htm#M10" name="L57"><b>H</b></a></dd>

<dd><a href="binary.htm#M11" name="L58"><b>h</b></a></dd>

<dd><a href="binary.htm#M12" name="L59"><b>c</b></a></dd>

<dd><a href="binary.htm#M13" name="L60"><b>s</b></a></dd>

<dd><a href="binary.htm#M14" name="L61"><b>S</b></a></dd>

<dd><a href="binary.htm#M15" name="L62"><b>t</b></a></dd>

<dd><a href="binary.htm#M16" name="L63"><b>i</b></a></dd>

<dd><a href="binary.htm#M17" name="L64"><b>I</b></a></dd>

<dd><a href="binary.htm#M18" name="L65"><b>n</b></a></dd>

<dd><a href="binary.htm#M19" name="L66"><b>w</b></a></dd>

<dd><a href="binary.htm#M20" name="L67"><b>W</b></a></dd>

<dd><a href="binary.htm#M21" name="L68"><b>m</b></a></dd>

<dd><a href="binary.htm#M22" name="L69"><b>f</b></a></dd>

<dd><a href="binary.htm#M23" name="L70"><b>r</b></a></dd>

<dd><a href="binary.htm#M24" name="L71"><b>R</b></a></dd>

<dd><a href="binary.htm#M25" name="L72"><b>d</b></a></dd>

<dd><a href="binary.htm#M26" name="L73"><b>q</b></a></dd>

<dd><a href="binary.htm#M27" name="L74"><b>Q</b></a></dd>

<dd><a href="binary.htm#M28" name="L75"><b>x</b></a></dd>

<dd><a href="binary.htm#M29" name="L76"><b>X</b></a></dd>

<dd><a href="binary.htm#M30" name="L77"><b>@</b></a></dd>
</dl>
</dd>

<dd><a href="binary.htm#M31" name="L78">BINARY SCAN</a> 

<dl class="binary scan">
<dd><a href="binary.htm#M32" name="L79"><b>a</b></a></dd>

<dd><a href="binary.htm#M33" name="L80"><b>A</b></a></dd>

<dd><a href="binary.htm#M34" name="L81"><b>b</b></a></dd>

<dd><a href="binary.htm#M35" name="L82"><b>B</b></a></dd>

<dd><a href="binary.htm#M36" name="L83"><b>H</b></a></dd>

<dd><a href="binary.htm#M37" name="L84"><b>h</b></a></dd>

<dd><a href="binary.htm#M38" name="L85"><b>c</b></a></dd>

<dd><a href="binary.htm#M39" name="L86"><b>s</b></a></dd>

<dd><a href="binary.htm#M40" name="L87"><b>S</b></a></dd>

<dd><a href="binary.htm#M41" name="L88"><b>t</b></a></dd>

<dd><a href="binary.htm#M42" name="L89"><b>i</b></a></dd>

<dd><a href="binary.htm#M43" name="L90"><b>I</b></a></dd>

<dd><a href="binary.htm#M44" name="L91"><b>n</b></a></dd>

<dd><a href="binary.htm#M45" name="L92"><b>w</b></a></dd>

<dd><a href="binary.htm#M46" name="L93"><b>W</b></a></dd>

<dd><a href="binary.htm#M47" name="L94"><b>m</b></a></dd>

<dd><a href="binary.htm#M48" name="L95"><b>f</b></a></dd>

<dd><a href="binary.htm#M49" name="L96"><b>r</b></a></dd>

<dd><a href="binary.htm#M50" name="L97"><b>R</b></a></dd>

<dd><a href="binary.htm#M51" name="L98"><b>d</b></a></dd>

<dd><a href="binary.htm#M52" name="L99"><b>q</b></a></dd>

<dd><a href="binary.htm#M53" name="L100"><b>Q</b></a></dd>

<dd><a href="binary.htm#M54" name="L101"><b>x</b></a></dd>

<dd><a href="binary.htm#M55" name="L102"><b>X</b></a></dd>

<dd><a href="binary.htm#M56" name="L103"><b>@</b></a></dd>
</dl>
</dd>

<dd><a href="binary.htm#M57" name="L104">PORTABILITY
ISSUES</a></dd>

<dd><a href="binary.htm#M58" name="L105">EXAMPLES</a></dd>

<dd><a href="binary.htm#M59" name="L106">SEE ALSO</a></dd>

<dd><a href="binary.htm#M60" name="L107">KEYWORDS</a></dd>
</dl>

<h3><a name="M2">NAME</a></h3>

binary - Insert and extract fields from binary strings 

<h3><a name="M3">SYNOPSIS</a></h3>

<b>binary format</b> <i>formatString</i> ?<i>arg arg ...</i>?<br>
<b>binary scan</b> <i>string formatString</i> ?<i>varName varName
...</i>?<br>
<h3><a name="M4">DESCRIPTION</a></h3>

This command provides facilities for manipulating binary data. The
first form, <b>binary format</b>, creates a binary string from
normal Tcl values. For example, given the values 16 and 22, on a
32-bit architecture, it might produce an 8-byte binary string
consisting of two 4-byte integers, one for each of the numbers. The
second form of the command, <b>binary scan</b>, does the opposite:
it extracts data from a binary string and returns it as ordinary
Tcl string values. 

<h3><a name="M5">BINARY FORMAT</a></h3>

The <b>binary format</b> command generates a binary string whose
layout is specified by the <i>formatString</i> and whose contents
come from the additional arguments. The resulting binary value is
returned. 

<p>The <i>formatString</i> consists of a sequence of zero or more
field specifiers separated by zero or more spaces. Each field
specifier is a single type character followed by an optional flag
character followed by an optional numeric <i>count</i>. Most field
specifiers consume one argument to obtain the value to be
formatted. The type character specifies how the value is to be
formatted. The <i>count</i> typically indicates how many items of
the specified type are taken from the value. If present, the
<i>count</i> is a non-negative decimal integer or <b>*</b>, which
normally indicates that all of the items in the value are to be
used. If the number of arguments does not match the number of
fields in the format string that consume arguments, then an error
is generated. The flag character is ignored for for <b>binary
format</b>.</p>

<p>Here is a small example to clarify the relation between the
field specifiers and the arguments:</p>

<pre>
<b>binary format</b> d3d {1.0 2.0 3.0 4.0} 0.1
</pre>

<p>The first argument is a list of four numbers, but because of the
count of 3 for the associated field specifier, only the first three
will be used. The second argument is associated with the second
field specifier. The resulting binary string contains the four
numbers 1.0, 2.0, 3.0 and 0.1.</p>

<p>Each type-count pair moves an imaginary cursor through the
binary data, storing bytes at the current position and advancing
the cursor to just after the last byte stored. The cursor is
initially at position 0 at the beginning of the data. The type may
be any one of the following characters:</p>

<dl class="binary format">
<dt><a name="M6"><b>a</b></a></dt>

<dd>Stores a byte string of length <i>count</i> in the output
string. Every character is taken as modulo 256 (i.e. the low byte
of every character is used, and the high byte discarded) so when
storing character strings not wholly expressible using the
characters \u0000-\u00ff, the <b>encoding convertto</b> command
should be used first to change the string into an external
representation if this truncation is not desired (i.e. if the
characters are not part of the ISO 8859-1 character set.) If
<i>arg</i> has fewer than <i>count</i> bytes, then additional zero
bytes are used to pad out the field. If <i>arg</i> is longer than
the specified length, the extra characters will be ignored. If
<i>count</i> is <b>*</b>, then all of the bytes in <i>arg</i> will
be formatted. If <i>count</i> is omitted, then one character will
be formatted. For example, 

<pre>
<b>binary format</b> a7a*a alpha bravo charlie
</pre>

will return a string equivalent to <b>alpha\000\000bravoc</b>, 

<pre>
<b>binary format</b> a* [encoding convertto utf-8 \u20ac]
</pre>

will return a string equivalent to <b>\342\202\254</b> (which is
the UTF-8 byte sequence for a Euro-currency character) and 

<pre>
<b>binary format</b> a* [encoding convertto iso8859-15 \u20ac]
</pre>

will return a string equivalent to <b>\244</b> (which is the ISO
8859-15 byte sequence for a Euro-currency character). Contrast
these last two with: 

<pre>
<b>binary format</b> a* \u20ac
</pre>

which returns a string equivalent to <b>\254</b> (i.e. <b>\xac</b>)
by truncating the high-bits of the character, and which is probably
not what is desired.</dd>

<dt><a name="M7"><b>A</b></a></dt>

<dd>This form is the same as <b>a</b> except that spaces are used
for padding instead of nulls. For example, 

<pre>
<b>binary format</b> A6A*A alpha bravo charlie
</pre>

will return <b>alpha bravoc</b>.</dd>

<dt><a name="M8"><b>b</b></a></dt>

<dd>Stores a string of <i>count</i> binary digits in low-to-high
order within each byte in the output string. <i>Arg</i> must
contain a sequence of <b>1</b> and <b>0</b> characters. The
resulting bytes are emitted in first to last order with the bits
being formatted in low-to-high order within each byte. If
<i>arg</i> has fewer than <i>count</i> digits, then zeros will be
used for the remaining bits. If <i>arg</i> has more than the
specified number of digits, the extra digits will be ignored. If
<i>count</i> is <b>*</b>, then all of the digits in <i>arg</i> will
be formatted. If <i>count</i> is omitted, then one digit will be
formatted. If the number of bits formatted does not end at a byte
boundary, the remaining bits of the last byte will be zeros. For
example, 

<pre>
<b>binary format</b> b5b* 11100 111000011010
</pre>

will return a string equivalent to <b>\x07\x87\x05</b>.</dd>

<dt><a name="M9"><b>B</b></a></dt>

<dd>This form is the same as <b>b</b> except that the bits are
stored in high-to-low order within each byte. For example, 

<pre>
<b>binary format</b> B5B* 11100 111000011010
</pre>

will return a string equivalent to <b>\xe0\xe1\xa0</b>.</dd>

<dt><a name="M10"><b>H</b></a></dt>

<dd>Stores a string of <i>count</i> hexadecimal digits in
high-to-low within each byte in the output string. <i>Arg</i> must
contain a sequence of characters in the set
&ldquo;0123456789abcdefABCDEF&rdquo;. The resulting bytes are
emitted in first to last order with the hex digits being formatted
in high-to-low order within each byte. If <i>arg</i> has fewer than
<i>count</i> digits, then zeros will be used for the remaining
digits. If <i>arg</i> has more than the specified number of digits,
the extra digits will be ignored. If <i>count</i> is <b>*</b>, then
all of the digits in <i>arg</i> will be formatted. If <i>count</i>
is omitted, then one digit will be formatted. If the number of
digits formatted does not end at a byte boundary, the remaining
bits of the last byte will be zeros. For example, 

<pre>
<b>binary format</b> H3H*H2 ab DEF 987
</pre>

will return a string equivalent to
<b>\xab\x00\xde\xf0\x98</b>.</dd>

<dt><a name="M11"><b>h</b></a></dt>

<dd>This form is the same as <b>H</b> except that the digits are
stored in low-to-high order within each byte. This is seldom
required. For example, 

<pre>
<b>binary format</b> h3h*h2 AB def 987
</pre>

will return a string equivalent to
<b>\xba\x00\xed\x0f\x89</b>.</dd>

<dt><a name="M12"><b>c</b></a></dt>

<dd>Stores one or more 8-bit integer values in the output string.
If no <i>count</i> is specified, then <i>arg</i> must consist of an
integer value. If <i>count</i> is specified, <i>arg</i> must
consist of a list containing at least that many integers. The
low-order 8 bits of each integer are stored as a one-byte value at
the cursor position. If <i>count</i> is <b>*</b>, then all of the
integers in the list are formatted. If the number of elements in
the list is greater than <i>count</i>, then the extra elements are
ignored. For example, 

<pre>
<b>binary format</b> c3cc* {3 -3 128 1} 260 {2 5}
</pre>

will return a string equivalent to <b>\x03\xfd\x80\x04\x02\x05</b>,
whereas 

<pre>
<b>binary format</b> c {2 5}
</pre>

will generate an error.</dd>

<dt><a name="M13"><b>s</b></a></dt>

<dd>This form is the same as <b>c</b> except that it stores one or
more 16-bit integers in little-endian byte order in the output
string. The low-order 16-bits of each integer are stored as a
two-byte value at the cursor position with the least significant
byte stored first. For example, 

<pre>
<b>binary format</b> s3 {3 -3 258 1}
</pre>

will return a string equivalent to
<b>\x03\x00\xfd\xff\x02\x01</b>.</dd>

<dt><a name="M14"><b>S</b></a></dt>

<dd>This form is the same as <b>s</b> except that it stores one or
more 16-bit integers in big-endian byte order in the output string.
For example, 

<pre>
<b>binary format</b> S3 {3 -3 258 1}
</pre>

will return a string equivalent to
<b>\x00\x03\xff\xfd\x01\x02</b>.</dd>

<dt><a name="M15"><b>t</b></a></dt>

<dd>This form (mnemonically <i>tiny</i>) is the same as <b>s</b>
and <b>S</b> except that it stores the 16-bit integers in the
output string in the native byte order of the machine where the Tcl
script is running. To determine what the native byte order of the
machine is, refer to the <b>byteOrder</b> element of the
<b>tcl_platform</b> array.</dd>

<dt><a name="M16"><b>i</b></a></dt>

<dd>This form is the same as <b>c</b> except that it stores one or
more 32-bit integers in little-endian byte order in the output
string. The low-order 32-bits of each integer are stored as a
four-byte value at the cursor position with the least significant
byte stored first. For example, 

<pre>
<b>binary format</b> i3 {3 -3 65536 1}
</pre>

will return a string equivalent to
<b>\x03\x00\x00\x00\xfd\xff\xff\xff\x00\x00\x01\x00</b></dd>

<dt><a name="M17"><b>I</b></a></dt>

<dd>This form is the same as <b>i</b> except that it stores one or
more one or more 32-bit integers in big-endian byte order in the
output string. For example, 

<pre>
<b>binary format</b> I3 {3 -3 65536 1}
</pre>

will return a string equivalent to
<b>\x00\x00\x00\x03\xff\xff\xff\xfd\x00\x01\x00\x00</b></dd>

<dt><a name="M18"><b>n</b></a></dt>

<dd>This form (mnemonically <i>number</i> or <i>normal</i>) is the
same as <b>i</b> and <b>I</b> except that it stores the 32-bit
integers in the output string in the native byte order of the
machine where the Tcl script is running. To determine what the
native byte order of the machine is, refer to the <b>byteOrder</b>
element of the <b>tcl_platform</b> array.</dd>

<dt><a name="M19"><b>w</b></a></dt>

<dd>This form is the same as <b>c</b> except that it stores one or
more 64-bit integers in little-endian byte order in the output
string. The low-order 64-bits of each integer are stored as an
eight-byte value at the cursor position with the least significant
byte stored first. For example, 

<pre>
<b>binary format</b> w 7810179016327718216
</pre>

will return the string <b>HelloTcl</b></dd>

<dt><a name="M20"><b>W</b></a></dt>

<dd>This form is the same as <b>w</b> except that it stores one or
more one or more 64-bit integers in big-endian byte order in the
output string. For example, 

<pre>
<b>binary format</b> Wc 4785469626960341345 110
</pre>

will return the string <b>BigEndian</b></dd>

<dt><a name="M21"><b>m</b></a></dt>

<dd>This form (mnemonically the mirror of <b>w</b>) is the same as
<b>w</b> and <b>W</b> except that it stores the 64-bit integers in
the output string in the native byte order of the machine where the
Tcl script is running. To determine what the native byte order of
the machine is, refer to the <b>byteOrder</b> element of the
<b>tcl_platform</b> array.</dd>

<dt><a name="M22"><b>f</b></a></dt>

<dd>This form is the same as <b>c</b> except that it stores one or
more one or more single-precision floating point numbers in the
machine's native representation in the output string. This
representation is not portable across architectures, so it should
not be used to communicate floating point numbers across the
network. The size of a floating point number may vary across
architectures, so the number of bytes that are generated may vary.
If the value overflows the machine's native representation, then
the value of FLT_MAX as defined by the system will be used instead.
Because Tcl uses double-precision floating point numbers
internally, there may be some loss of precision in the conversion
to single-precision. For example, on a Windows system running on an
Intel Pentium processor, 

<pre>
<b>binary format</b> f2 {1.6 3.4}
</pre>

will return a string equivalent to
<b>\xcd\xcc\xcc\x3f\x9a\x99\x59\x40</b>.</dd>

<dt><a name="M23"><b>r</b></a></dt>

<dd>This form (mnemonically <i>real</i>) is the same as <b>f</b>
except that it stores the single-precision floating point numbers
in little-endian order. This conversion only produces meaningful
output when used on machines which use the IEEE floating point
representation (very common, but not universal.)</dd>

<dt><a name="M24"><b>R</b></a></dt>

<dd>This form is the same as <b>r</b> except that it stores the
single-precision floating point numbers in big-endian order.</dd>

<dt><a name="M25"><b>d</b></a></dt>

<dd>This form is the same as <b>f</b> except that it stores one or
more one or more double-precision floating point numbers in the
machine's native representation in the output string. For example,
on a Windows system running on an Intel Pentium processor, 

<pre>
<b>binary format</b> d1 {1.6}
</pre>

will return a string equivalent to
<b>\x9a\x99\x99\x99\x99\x99\xf9\x3f</b>.</dd>

<dt><a name="M26"><b>q</b></a></dt>

<dd>This form (mnemonically the mirror of <b>d</b>) is the same as
<b>d</b> except that it stores the double-precision floating point
numbers in little-endian order. This conversion only produces
meaningful output when used on machines which use the IEEE floating
point representation (very common, but not universal.)</dd>

<dt><a name="M27"><b>Q</b></a></dt>

<dd>This form is the same as <b>q</b> except that it stores the
double-precision floating point numbers in big-endian order.</dd>

<dt><a name="M28"><b>x</b></a></dt>

<dd>Stores <i>count</i> null bytes in the output string. If
<i>count</i> is not specified, stores one null byte. If
<i>count</i> is <b>*</b>, generates an error. This type does not
consume an argument. For example, 

<pre>
<b>binary format</b> a3xa3x2a3 abc def ghi
</pre>

will return a string equivalent to
<b>abc\000def\000\000ghi</b>.</dd>

<dt><a name="M29"><b>X</b></a></dt>

<dd>Moves the cursor back <i>count</i> bytes in the output string.
If <i>count</i> is <b>*</b> or is larger than the current cursor
position, then the cursor is positioned at location 0 so that the
next byte stored will be the first byte in the result string. If
<i>count</i> is omitted then the cursor is moved back one byte.
This type does not consume an argument. For example, 

<pre>
<b>binary format</b> a3X*a3X2a3 abc def ghi
</pre>

will return <b>dghi</b>.</dd>

<dt><a name="M30"><b>@</b></a></dt>

<dd>Moves the cursor to the absolute location in the output string
specified by <i>count</i>. Position 0 refers to the first byte in
the output string. If <i>count</i> refers to a position beyond the
last byte stored so far, then null bytes will be placed in the
uninitialized locations and the cursor will be placed at the
specified location. If <i>count</i> is <b>*</b>, then the cursor is
moved to the current end of the output string. If <i>count</i> is
omitted, then an error will be generated. This type does not
consume an argument. For example, 

<pre>
<b>binary format</b> a5@2a1@*a3@10a1 abcde f ghi j
</pre>

will return <b>abfdeghi\000\000j</b>.</dd>
</dl>

<h3><a name="M31">BINARY SCAN</a></h3>

The <b>binary scan</b> command parses fields from a binary string,
returning the number of conversions performed. <i>String</i> gives
the input bytes to be parsed (one byte per character, and
characters not representable as a byte have their high bits
chopped) and <i>formatString</i> indicates how to parse it. Each
<i>varName</i> gives the name of a variable; when a field is
scanned from <i>string</i> the result is assigned to the
corresponding variable. 

<p>As with <b>binary format</b>, the <i>formatString</i> consists
of a sequence of zero or more field specifiers separated by zero or
more spaces. Each field specifier is a single type character
followed by an optional flag character followed by an optional
numeric <i>count</i>. Most field specifiers consume one argument to
obtain the variable into which the scanned values should be placed.
The type character specifies how the binary data is to be
interpreted. The <i>count</i> typically indicates how many items of
the specified type are taken from the data. If present, the
<i>count</i> is a non-negative decimal integer or <b>*</b>, which
normally indicates that all of the remaining items in the data are
to be used. If there are not enough bytes left after the current
cursor position to satisfy the current field specifier, then the
corresponding variable is left untouched and <b>binary scan</b>
returns immediately with the number of variables that were set. If
there are not enough arguments for all of the fields in the format
string that consume arguments, then an error is generated. The flag
character &ldquo;u&rdquo; may be given to cause some types to be
read as unsigned values. The flag is accepted for all field types
but is ignored for non-integer fields.</p>

<p>A similar example as with <b>binary format</b> should explain
the relation between field specifiers and arguments in case of the
binary scan subcommand:</p>

<pre>
<b>binary scan</b> $bytes s3s first second
</pre>

<p>This command (provided the binary string in the variable
<i>bytes</i> is long enough) assigns a list of three integers to
the variable <i>first</i> and assigns a single value to the
variable <i>second</i>. If <i>bytes</i> contains fewer than 8 bytes
(i.e. four 2-byte integers), no assignment to <i>second</i> will be
made, and if <i>bytes</i> contains fewer than 6 bytes (i.e. three
2-byte integers), no assignment to <i>first</i> will be made.
Hence:</p>

<pre>
puts [<b>binary scan</b> abcdefg s3s first second]
puts $first
puts $second
</pre>

will print (assuming neither variable is set previously): 

<pre>
1
25185 25699 26213
can't read "second": no such variable
</pre>

<p>It is <i>important</i> to note that the <b>c</b>, <b>s</b>, and
<b>S</b> (and <b>i</b> and <b>I</b> on 64bit systems) will be
scanned into long data size values. In doing this, values that have
their high bit set (0x80 for chars, 0x8000 for shorts, 0x80000000
for ints), will be sign extended. Thus the following will
occur:</p>

<pre>
set signShort [<b>binary format</b> s1 0x8000]
<b>binary scan</b> $signShort s1 val; <i># val == 0xFFFF8000</i>
</pre>

If you require unsigned values you can include the &ldquo;u&rdquo;
flag character following the field type. For example, to read an
unsigned short value: 

<pre>
set signShort [<b>binary format</b> s1 0x8000]
<b>binary scan</b> $signShort su1 val; <i># val == 0x00008000</i>
</pre>

<p>Each type-count pair moves an imaginary cursor through the
binary data, reading bytes from the current position. The cursor is
initially at position 0 at the beginning of the data. The type may
be any one of the following characters:</p>

<dl class="binary scan">
<dt><a name="M32"><b>a</b></a></dt>

<dd>The data is a byte string of length <i>count</i>. If
<i>count</i> is <b>*</b>, then all of the remaining bytes in
<i>string</i> will be scanned into the variable. If <i>count</i> is
omitted, then one byte will be scanned. All bytes scanned will be
interpreted as being characters in the range \u0000-\u00ff so the
<b>encoding convertfrom</b> command will be needed if the string is
not a binary string or a string encoded in ISO 8859-1. For example,


<pre>
<b>binary scan</b> abcde\000fghi a6a10 var1 var2
</pre>

will return <b>1</b> with the string equivalent to <b>abcde\000</b>
stored in <i>var1</i> and <i>var2</i> left unmodified, and 

<pre>
<b>binary scan</b> \342\202\254 a* var1
set var2 [encoding convertfrom utf-8 $var1]
</pre>

will store a Euro-currency character in <i>var2</i>.</dd>

<dt><a name="M33"><b>A</b></a></dt>

<dd>This form is the same as <b>a</b>, except trailing blanks and
nulls are stripped from the scanned value before it is stored in
the variable. For example, 

<pre>
<b>binary scan</b> "abc efghi  \000" A* var1
</pre>

will return <b>1</b> with <b>abc efghi</b> stored in
<i>var1</i>.</dd>

<dt><a name="M34"><b>b</b></a></dt>

<dd>The data is turned into a string of <i>count</i> binary digits
in low-to-high order represented as a sequence of &ldquo;1&rdquo;
and &ldquo;0&rdquo; characters. The data bytes are scanned in first
to last order with the bits being taken in low-to-high order within
each byte. Any extra bits in the last byte are ignored. If
<i>count</i> is <b>*</b>, then all of the remaining bits in
<i>string</i> will be scanned. If <i>count</i> is omitted, then one
bit will be scanned. For example, 

<pre>
<b>binary scan</b> \x07\x87\x05 b5b* var1 var2
</pre>

will return <b>2</b> with <b>11100</b> stored in <i>var1</i> and
<b>1110000110100000</b> stored in <i>var2</i>.</dd>

<dt><a name="M35"><b>B</b></a></dt>

<dd>This form is the same as <b>b</b>, except the bits are taken in
high-to-low order within each byte. For example, 

<pre>
<b>binary scan</b> \x70\x87\x05 B5B* var1 var2
</pre>

will return <b>2</b> with <b>01110</b> stored in <i>var1</i> and
<b>1000011100000101</b> stored in <i>var2</i>.</dd>

<dt><a name="M36"><b>H</b></a></dt>

<dd>The data is turned into a string of <i>count</i> hexadecimal
digits in high-to-low order represented as a sequence of characters
in the set &ldquo;0123456789abcdef&rdquo;. The data bytes are
scanned in first to last order with the hex digits being taken in
high-to-low order within each byte. Any extra bits in the last byte
are ignored. If <i>count</i> is <b>*</b>, then all of the remaining
hex digits in <i>string</i> will be scanned. If <i>count</i> is
omitted, then one hex digit will be scanned. For example, 

<pre>
<b>binary scan</b> \x07\xC6\x05\x1f\x34 H3H* var1 var2
</pre>

will return <b>2</b> with <b>07c</b> stored in <i>var1</i> and
<b>051f34</b> stored in <i>var2</i>.</dd>

<dt><a name="M37"><b>h</b></a></dt>

<dd>This form is the same as <b>H</b>, except the digits are taken
in reverse (low-to-high) order within each byte. For example, 

<pre>
<b>binary scan</b> \x07\x86\x05\x12\x34 h3h* var1 var2
</pre>

will return <b>2</b> with <b>706</b> stored in <i>var1</i> and
<b>502143</b> stored in <i>var2</i>. Note that most code that
wishes to parse the hexadecimal digits from multiple bytes in order
should use the <b>H</b> format.</dd>

<dt><a name="M38"><b>c</b></a></dt>

<dd>The data is turned into <i>count</i> 8-bit signed integers and
stored in the corresponding variable as a list. If <i>count</i> is
<b>*</b>, then all of the remaining bytes in <i>string</i> will be
scanned. If <i>count</i> is omitted, then one 8-bit integer will be
scanned. For example, 

<pre>
<b>binary scan</b> \x07\x86\x05 c2c* var1 var2
</pre>

will return <b>2</b> with <b>7 -122</b> stored in <i>var1</i> and
<b>5</b> stored in <i>var2</i>. Note that the integers returned are
signed, but they can be converted to unsigned 8-bit quantities
using an expression like: 

<pre>
set num [expr { $num &amp; 0xff }]
</pre>
</dd>

<dt><a name="M39"><b>s</b></a></dt>

<dd>The data is interpreted as <i>count</i> 16-bit signed integers
represented in little-endian byte order. The integers are stored in
the corresponding variable as a list. If <i>count</i> is <b>*</b>,
then all of the remaining bytes in <i>string</i> will be scanned.
If <i>count</i> is omitted, then one 16-bit integer will be
scanned. For example, 

<pre>
<b>binary scan</b> \x05\x00\x07\x00\xf0\xff s2s* var1 var2
</pre>

will return <b>2</b> with <b>5 7</b> stored in <i>var1</i> and
<b>-16</b> stored in <i>var2</i>. Note that the integers returned
are signed, but they can be converted to unsigned 16-bit quantities
using an expression like: 

<pre>
set num [expr { $num &amp; 0xffff }]
</pre>
</dd>

<dt><a name="M40"><b>S</b></a></dt>

<dd>This form is the same as <b>s</b> except that the data is
interpreted as <i>count</i> 16-bit signed integers represented in
big-endian byte order. For example, 

<pre>
<b>binary scan</b> \x00\x05\x00\x07\xff\xf0 S2S* var1 var2
</pre>

will return <b>2</b> with <b>5 7</b> stored in <i>var1</i> and
<b>-16</b> stored in <i>var2</i>.</dd>

<dt><a name="M41"><b>t</b></a></dt>

<dd>The data is interpreted as <i>count</i> 16-bit signed integers
represented in the native byte order of the machine running the Tcl
script. It is otherwise identical to <b>s</b> and <b>S</b>. To
determine what the native byte order of the machine is, refer to
the <b>byteOrder</b> element of the <b>tcl_platform</b> array.</dd>

<dt><a name="M42"><b>i</b></a></dt>

<dd>The data is interpreted as <i>count</i> 32-bit signed integers
represented in little-endian byte order. The integers are stored in
the corresponding variable as a list. If <i>count</i> is <b>*</b>,
then all of the remaining bytes in <i>string</i> will be scanned.
If <i>count</i> is omitted, then one 32-bit integer will be
scanned. For example, 

<pre>
set str \x05\x00\x00\x00\x07\x00\x00\x00\xf0\xff\xff\xff
<b>binary scan</b> $str i2i* var1 var2
</pre>

will return <b>2</b> with <b>5 7</b> stored in <i>var1</i> and
<b>-16</b> stored in <i>var2</i>. Note that the integers returned
are signed, but they can be converted to unsigned 32-bit quantities
using an expression like: 

<pre>
set num [expr { $num &amp; 0xffffffff }]
</pre>
</dd>

<dt><a name="M43"><b>I</b></a></dt>

<dd>This form is the same as <b>I</b> except that the data is
interpreted as <i>count</i> 32-bit signed integers represented in
big-endian byte order. For example, 

<pre>
set str \x00\x00\x00\x05\x00\x00\x00\x07\xff\xff\xff\xf0
<b>binary scan</b> $str I2I* var1 var2
</pre>

will return <b>2</b> with <b>5 7</b> stored in <i>var1</i> and
<b>-16</b> stored in <i>var2</i>.</dd>

<dt><a name="M44"><b>n</b></a></dt>

<dd>The data is interpreted as <i>count</i> 32-bit signed integers
represented in the native byte order of the machine running the Tcl
script. It is otherwise identical to <b>i</b> and <b>I</b>. To
determine what the native byte order of the machine is, refer to
the <b>byteOrder</b> element of the <b>tcl_platform</b> array.</dd>

<dt><a name="M45"><b>w</b></a></dt>

<dd>The data is interpreted as <i>count</i> 64-bit signed integers
represented in little-endian byte order. The integers are stored in
the corresponding variable as a list. If <i>count</i> is <b>*</b>,
then all of the remaining bytes in <i>string</i> will be scanned.
If <i>count</i> is omitted, then one 64-bit integer will be
scanned. For example, 

<pre>
set str \x05\x00\x00\x00\x07\x00\x00\x00\xf0\xff\xff\xff
<b>binary scan</b> $str wi* var1 var2
</pre>

will return <b>2</b> with <b>30064771077</b> stored in <i>var1</i>
and <b>-16</b> stored in <i>var2</i>. Note that the integers
returned are signed and cannot be represented by Tcl as unsigned
values.</dd>

<dt><a name="M46"><b>W</b></a></dt>

<dd>This form is the same as <b>w</b> except that the data is
interpreted as <i>count</i> 64-bit signed integers represented in
big-endian byte order. For example, 

<pre>
set str \x00\x00\x00\x05\x00\x00\x00\x07\xff\xff\xff\xf0
<b>binary scan</b> $str WI* var1 var2
</pre>

will return <b>2</b> with <b>21474836487</b> stored in <i>var1</i>
and <b>-16</b> stored in <i>var2</i>.</dd>

<dt><a name="M47"><b>m</b></a></dt>

<dd>The data is interpreted as <i>count</i> 64-bit signed integers
represented in the native byte order of the machine running the Tcl
script. It is otherwise identical to <b>w</b> and <b>W</b>. To
determine what the native byte order of the machine is, refer to
the <b>byteOrder</b> element of the <b>tcl_platform</b> array.</dd>

<dt><a name="M48"><b>f</b></a></dt>

<dd>The data is interpreted as <i>count</i> single-precision
floating point numbers in the machine's native representation. The
floating point numbers are stored in the corresponding variable as
a list. If <i>count</i> is <b>*</b>, then all of the remaining
bytes in <i>string</i> will be scanned. If <i>count</i> is omitted,
then one single-precision floating point number will be scanned.
The size of a floating point number may vary across architectures,
so the number of bytes that are scanned may vary. If the data does
not represent a valid floating point number, the resulting value is
undefined and compiler dependent. For example, on a Windows system
running on an Intel Pentium processor, 

<pre>
<b>binary scan</b> \x3f\xcc\xcc\xcd f var1
</pre>

will return <b>1</b> with <b>1.6000000238418579</b> stored in
<i>var1</i>.</dd>

<dt><a name="M49"><b>r</b></a></dt>

<dd>This form is the same as <b>f</b> except that the data is
interpreted as <i>count</i> single-precision floating point number
in little-endian order. This conversion is not portable to the
minority of systems not using IEEE floating point
representations.</dd>

<dt><a name="M50"><b>R</b></a></dt>

<dd>This form is the same as <b>f</b> except that the data is
interpreted as <i>count</i> single-precision floating point number
in big-endian order. This conversion is not portable to the
minority of systems not using IEEE floating point
representations.</dd>

<dt><a name="M51"><b>d</b></a></dt>

<dd>This form is the same as <b>f</b> except that the data is
interpreted as <i>count</i> double-precision floating point numbers
in the machine's native representation. For example, on a Windows
system running on an Intel Pentium processor, 

<pre>
<b>binary scan</b> \x9a\x99\x99\x99\x99\x99\xf9\x3f d var1
</pre>

will return <b>1</b> with <b>1.6000000000000001</b> stored in
<i>var1</i>.</dd>

<dt><a name="M52"><b>q</b></a></dt>

<dd>This form is the same as <b>d</b> except that the data is
interpreted as <i>count</i> double-precision floating point number
in little-endian order. This conversion is not portable to the
minority of systems not using IEEE floating point
representations.</dd>

<dt><a name="M53"><b>Q</b></a></dt>

<dd>This form is the same as <b>d</b> except that the data is
interpreted as <i>count</i> double-precision floating point number
in big-endian order. This conversion is not portable to the
minority of systems not using IEEE floating point
representations.</dd>

<dt><a name="M54"><b>x</b></a></dt>

<dd>Moves the cursor forward <i>count</i> bytes in <i>string</i>.
If <i>count</i> is <b>*</b> or is larger than the number of bytes
after the current cursor position, then the cursor is positioned
after the last byte in <i>string</i>. If <i>count</i> is omitted,
then the cursor is moved forward one byte. Note that this type does
not consume an argument. For example, 

<pre>
<b>binary scan</b> \x01\x02\x03\x04 x2H* var1
</pre>

will return <b>1</b> with <b>0304</b> stored in <i>var1</i>.</dd>

<dt><a name="M55"><b>X</b></a></dt>

<dd>Moves the cursor back <i>count</i> bytes in <i>string</i>. If
<i>count</i> is <b>*</b> or is larger than the current cursor
position, then the cursor is positioned at location 0 so that the
next byte scanned will be the first byte in <i>string</i>. If
<i>count</i> is omitted then the cursor is moved back one byte.
Note that this type does not consume an argument. For example, 

<pre>
<b>binary scan</b> \x01\x02\x03\x04 c2XH* var1 var2
</pre>

will return <b>2</b> with <b>1 2</b> stored in <i>var1</i> and
<b>020304</b> stored in <i>var2</i>.</dd>

<dt><a name="M56"><b>@</b></a></dt>

<dd>Moves the cursor to the absolute location in the data string
specified by <i>count</i>. Note that position 0 refers to the first
byte in <i>string</i>. If <i>count</i> refers to a position beyond
the end of <i>string</i>, then the cursor is positioned after the
last byte. If <i>count</i> is omitted, then an error will be
generated. For example, 

<pre>
<b>binary scan</b> \x01\x02\x03\x04 c2@1H* var1 var2
</pre>

will return <b>2</b> with <b>1 2</b> stored in <i>var1</i> and
<b>020304</b> stored in <i>var2</i>.</dd>
</dl>

<h3><a name="M57">PORTABILITY ISSUES</a></h3>

The <b>r</b>, <b>R</b>, <b>q</b> and <b>Q</b> conversions will only
work reliably for transferring data between computers which are all
using IEEE floating point representations. This is very common, but
not universal. To transfer floating-point numbers portably between
all architectures, use their textual representation (as produced by
<b><a href="../TclCmd/format.htm">format</a></b>) instead. 

<h3><a name="M58">EXAMPLES</a></h3>

This is a procedure to write a Tcl string to a binary-encoded
channel as UTF-8 data preceded by a length word: 

<pre>
proc <i>writeString</i> {channel string} {
    set data [encoding convertto utf-8 $string]
    puts -nonewline [<b>binary format</b> Ia* \
            [string length $data] $data]
}
</pre>

<p>This procedure reads a string from a channel that was written by
the previously presented <i>writeString</i> procedure:</p>

<pre>
proc <i>readString</i> {channel} {
    if {![<b>binary scan</b> [read $channel 4] I length]} {
        error "missing length"
    }
    set data [read $channel $length]
    return [encoding convertfrom utf-8 $data]
}
</pre>

<h3><a name="M59">SEE ALSO</a></h3>

<b><a href="../TclCmd/format.htm">format</a></b>, <b><a href=
"../TclCmd/scan.htm">scan</a></b>, <b><a href=
"../TclCmd/tclvars.htm">tclvars</a></b> 

<h3><a name="M60">KEYWORDS</a></h3>

<a href="../Keywords/B.htm#binary">binary</a>, <a href=
"../Keywords/F.htm#format">format</a>, <a href=
"../Keywords/S.htm#scan">scan</a> 

<div class="copy">Copyright &copy; 1995-1997 Roger E. Critchlow Jr.
Copyright &copy; 1997 by Sun Microsystems, Inc.</div>
</body>
</html>

