<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<meta name="generator" content="HTML Tidy, see www.w3.org">
<meta name='Author' content='ActiveState'>
<link rel='stylesheet' type='text/css' href='../../aspn.css'>
<title>Tcl Library Procedures - Tcl_CreateChannel manual
page</title>
<link rel="stylesheet" href="../docs.css" type="text/css" media=
"all">
</head>
<body>
<div class="banner">
<table width="100%" border="0" cellspacing="0" cellpadding="3">
<tr>
<td align="left"><a target="_blank" href=
"http://www.activestate.com/activetcl"><img src=
"../../images/ActiveTcl.gif" border="0" align="left" alt=
"ActiveTcl"></a> </td>
<td align="center" class="heading">ActiveTcl User Guide</td>
<td align="right"><a target="_blank" href=
"http://www.activestate.com"><img src="../../images/AS_logo.gif"
border="0" align="right" alt="ActiveState Software Inc."></a> </td>
</tr>
</table>
</div>

<br>
<h2><a href="../contents.htm">Tcl/Tk Documentation</a>
<small>&gt;</small> <a href="contents.htm">TclLib</a>
<small>&gt;</small> CrtChannel</h2>

<h3><a href="../UserCmd/contents.htm">Tcl/Tk Applications</a> | <a
href="../TclCmd/contents.htm">Tcl Commands</a> | <a href=
"../TkCmd/contents.htm">Tk Commands</a> | <a href=
"../TclLib/contents.htm">Tcl Library</a> | <a href=
"../TkLib/contents.htm">Tk Library</a></h3>

<dl>
<dd><a href="CrtChannel.htm#M2" name="L84">NAME</a> 

<dl>
<dd>Tcl_CreateChannel, Tcl_GetChannelInstanceData,
Tcl_GetChannelType, Tcl_GetChannelName, Tcl_GetChannelHandle,
Tcl_GetChannelMode, Tcl_GetChannelBufferSize,
Tcl_SetChannelBufferSize, Tcl_NotifyChannel, Tcl_BadChannelOption,
Tcl_ChannelName, Tcl_ChannelVersion, Tcl_ChannelBlockModeProc,
Tcl_ChannelCloseProc, Tcl_ChannelClose2Proc, Tcl_ChannelInputProc,
Tcl_ChannelOutputProc, Tcl_ChannelSeekProc,
Tcl_ChannelWideSeekProc, Tcl_ChannelTruncateProc,
Tcl_ChannelSetOptionProc, Tcl_ChannelGetOptionProc,
Tcl_ChannelWatchProc, Tcl_ChannelGetHandleProc,
Tcl_ChannelFlushProc, Tcl_ChannelHandlerProc,
Tcl_ChannelThreadActionProc, Tcl_IsChannelShared,
Tcl_IsChannelRegistered, Tcl_CutChannel, Tcl_SpliceChannel,
Tcl_IsChannelExisting, Tcl_ClearChannelHandlers,
Tcl_GetChannelThread, Tcl_ChannelBuffered - procedures for creating
and manipulating channels</dd>
</dl>
</dd>

<dd><a href="CrtChannel.htm#M3" name="L85">SYNOPSIS</a></dd>

<dd><a href="CrtChannel.htm#M4" name="L86">ARGUMENTS</a></dd>

<dd><a href="CrtChannel.htm#M5" name="L87">DESCRIPTION</a></dd>

<dd><a href="CrtChannel.htm#M6" name="L88">TCL_CHANNELTYPE</a></dd>

<dd><a href="CrtChannel.htm#M7" name="L89">TYPENAME</a></dd>

<dd><a href="CrtChannel.htm#M8" name="L90">VERSION</a></dd>

<dd><a href="CrtChannel.htm#M9" name="L91">BLOCKMODEPROC</a></dd>

<dd><a href="CrtChannel.htm#M10" name="L92">CLOSEPROC AND
CLOSE2PROC</a></dd>

<dd><a href="CrtChannel.htm#M11" name="L93">INPUTPROC</a></dd>

<dd><a href="CrtChannel.htm#M12" name="L94">OUTPUTPROC</a></dd>

<dd><a href="CrtChannel.htm#M13" name="L95">SEEKPROC AND
WIDESEEKPROC</a></dd>

<dd><a href="CrtChannel.htm#M14" name="L96">SETOPTIONPROC</a></dd>

<dd><a href="CrtChannel.htm#M15" name="L97">GETOPTIONPROC</a></dd>

<dd><a href="CrtChannel.htm#M16" name="L98">WATCHPROC</a></dd>

<dd><a href="CrtChannel.htm#M17" name="L99">GETHANDLEPROC</a></dd>

<dd><a href="CrtChannel.htm#M18" name="L100">FLUSHPROC</a></dd>

<dd><a href="CrtChannel.htm#M19" name="L101">HANDLERPROC</a></dd>

<dd><a href="CrtChannel.htm#M20" name=
"L102">THREADACTIONPROC</a></dd>

<dd><a href="CrtChannel.htm#M21" name="L103">TRUNCATEPROC</a></dd>

<dd><a href="CrtChannel.htm#M22" name=
"L104">TCL_BADCHANNELOPTION</a></dd>

<dd><a href="CrtChannel.htm#M23" name="L105">OLD CHANNEL
TYPES</a></dd>

<dd><a href="CrtChannel.htm#M24" name="L106">SEE ALSO</a></dd>

<dd><a href="CrtChannel.htm#M25" name="L107">KEYWORDS</a></dd>
</dl>

<h3><a name="M2">NAME</a></h3>

Tcl_CreateChannel, Tcl_GetChannelInstanceData, Tcl_GetChannelType,
Tcl_GetChannelName, Tcl_GetChannelHandle, Tcl_GetChannelMode,
Tcl_GetChannelBufferSize, Tcl_SetChannelBufferSize,
Tcl_NotifyChannel, Tcl_BadChannelOption, Tcl_ChannelName,
Tcl_ChannelVersion, Tcl_ChannelBlockModeProc, Tcl_ChannelCloseProc,
Tcl_ChannelClose2Proc, Tcl_ChannelInputProc, Tcl_ChannelOutputProc,
Tcl_ChannelSeekProc, Tcl_ChannelWideSeekProc,
Tcl_ChannelTruncateProc, Tcl_ChannelSetOptionProc,
Tcl_ChannelGetOptionProc, Tcl_ChannelWatchProc,
Tcl_ChannelGetHandleProc, Tcl_ChannelFlushProc,
Tcl_ChannelHandlerProc, Tcl_ChannelThreadActionProc,
Tcl_IsChannelShared, Tcl_IsChannelRegistered, Tcl_CutChannel,
Tcl_SpliceChannel, Tcl_IsChannelExisting, Tcl_ClearChannelHandlers,
Tcl_GetChannelThread, Tcl_ChannelBuffered - procedures for creating
and manipulating channels 

<h3><a name="M3">SYNOPSIS</a></h3>

<b>#include &lt;tcl.h&gt;</b><br>
Tcl_Channel<br>
<b>Tcl_CreateChannel</b>(<i>typePtr, channelName, instanceData,
mask</i>)<br>
ClientData<br>
<b>Tcl_GetChannelInstanceData</b>(<i>channel</i>)<br>
Tcl_ChannelType *<br>
<b>Tcl_GetChannelType</b>(<i>channel</i>)<br>
const char *<br>
<b>Tcl_GetChannelName</b>(<i>channel</i>)<br>
int<br>
<b>Tcl_GetChannelHandle</b>(<i>channel, direction,
handlePtr</i>)<br>
Tcl_ThreadId<br>
<b>Tcl_GetChannelThread</b>(<i>channel</i>)<br>
int<br>
<b>Tcl_GetChannelMode</b>(<i>channel</i>)<br>
int<br>
<b>Tcl_GetChannelBufferSize</b>(<i>channel</i>)<br>
<b>Tcl_SetChannelBufferSize</b>(<i>channel, size</i>)<br>
<b>Tcl_NotifyChannel</b>(<i>channel, mask</i>)<br>
int<br>
<b>Tcl_BadChannelOption</b>(<i>interp, optionName,
optionList</i>)<br>
int<br>
<b>Tcl_IsChannelShared</b>(<i>channel</i>)<br>
int<br>
<b>Tcl_IsChannelRegistered</b>(<i>interp, channel</i>)<br>
int<br>
<b>Tcl_IsChannelExisting</b>(<i>channelName</i>)<br>
void<br>
<b>Tcl_CutChannel</b>(<i>channel</i>)<br>
void<br>
<b>Tcl_SpliceChannel</b>(<i>channel</i>)<br>
void<br>
<b>Tcl_ClearChannelHandlers</b>(<i>channel</i>)<br>
int<br>
<b>Tcl_ChannelBuffered</b>(<i>channel</i>)<br>
const char *<br>
<b>Tcl_ChannelName</b>(<i>typePtr</i>)<br>
Tcl_ChannelTypeVersion<br>
<b>Tcl_ChannelVersion</b>(<i>typePtr</i>)<br>
Tcl_DriverBlockModeProc *<br>
<b>Tcl_ChannelBlockModeProc</b>(<i>typePtr</i>)<br>
Tcl_DriverCloseProc *<br>
<b>Tcl_ChannelCloseProc</b>(<i>typePtr</i>)<br>
Tcl_DriverClose2Proc *<br>
<b>Tcl_ChannelClose2Proc</b>(<i>typePtr</i>)<br>
Tcl_DriverInputProc *<br>
<b>Tcl_ChannelInputProc</b>(<i>typePtr</i>)<br>
Tcl_DriverOutputProc *<br>
<b>Tcl_ChannelOutputProc</b>(<i>typePtr</i>)<br>
Tcl_DriverSeekProc *<br>
<b>Tcl_ChannelSeekProc</b>(<i>typePtr</i>)<br>
Tcl_DriverWideSeekProc *<br>
<b>Tcl_ChannelWideSeekProc</b>(<i>typePtr</i>)<br>
Tcl_DriverThreadActionProc *<br>
<b>Tcl_ChannelThreadActionProc</b>(<i>typePtr</i>)<br>
Tcl_DriverTruncateProc *<br>
<b>Tcl_ChannelTruncateProc</b>(<i>typePtr</i>)<br>
Tcl_DriverSetOptionProc *<br>
<b>Tcl_ChannelSetOptionProc</b>(<i>typePtr</i>)<br>
Tcl_DriverGetOptionProc *<br>
<b>Tcl_ChannelGetOptionProc</b>(<i>typePtr</i>)<br>
Tcl_DriverWatchProc *<br>
<b>Tcl_ChannelWatchProc</b>(<i>typePtr</i>)<br>
Tcl_DriverGetHandleProc *<br>
<b>Tcl_ChannelGetHandleProc</b>(<i>typePtr</i>)<br>
Tcl_DriverFlushProc *<br>
<b>Tcl_ChannelFlushProc</b>(<i>typePtr</i>)<br>
Tcl_DriverHandlerProc *<br>
<b>Tcl_ChannelHandlerProc</b>(<i>typePtr</i>)<br>
<h3><a name="M4">ARGUMENTS</a></h3>

<dl class="arguments">
<dt>const Tcl_ChannelType <b>*typePtr</b> (in)</dt>

<dd>Points to a structure containing the addresses of procedures
that can be called to perform I/O and other functions on the
channel.</dd>

<dt>const char <b>*channelName</b> (in)</dt>

<dd>The name of this channel, such as <b>file3</b>; must not be in
use by any other channel. Can be NULL, in which case the channel is
created without a name.</dd>

<dt>ClientData <b>instanceData</b> (in)</dt>

<dd>Arbitrary one-word value to be associated with this channel.
This value is passed to procedures in <i>typePtr</i> when they are
invoked.</dd>

<dt>int <b>mask</b> (in)</dt>

<dd>OR-ed combination of <b>TCL_READABLE</b> and
<b>TCL_WRITABLE</b> to indicate whether a channel is readable and
writable.</dd>

<dt>Tcl_Channel <b>channel</b> (in)</dt>

<dd>The channel to operate on.</dd>

<dt>int <b>direction</b> (in)</dt>

<dd><b>TCL_READABLE</b> means the input handle is wanted;
<b>TCL_WRITABLE</b> means the output handle is wanted.</dd>

<dt>ClientData <b>*handlePtr</b> (out)</dt>

<dd>Points to the location where the desired OS-specific handle
should be stored.</dd>

<dt>int <b>size</b> (in)</dt>

<dd>The size, in bytes, of buffers to allocate in this
channel.</dd>

<dt>int <b>mask</b> (in)</dt>

<dd>An OR-ed combination of <b>TCL_READABLE</b>,
<b>TCL_WRITABLE</b> and <b>TCL_EXCEPTION</b> that indicates events
that have occurred on this channel.</dd>

<dt><a href="../TclLib/Interp.htm">Tcl_Interp</a> <b>*interp</b>
(in)</dt>

<dd>Current interpreter. (can be NULL)</dd>

<dt>const char <b>*optionName</b> (in)</dt>

<dd>Name of the invalid option.</dd>

<dt>const char <b>*optionList</b> (in)</dt>

<dd>Specific options list (space separated words, without
&ldquo;-&rdquo;) to append to the standard generic options list.
Can be NULL for generic options error message only.</dd>
</dl>

<h3><a name="M5">DESCRIPTION</a></h3>

Tcl uses a two-layered channel architecture. It provides a generic
upper layer to enable C and Tcl programs to perform input and
output using the same APIs for a variety of files, devices, sockets
etc. The generic C APIs are described in the manual entry for <b><a
href="../TclLib/OpenFileChnl.htm">Tcl_OpenFileChannel</a></b>. 

<p>The lower layer provides type-specific channel drivers for each
type of device supported on each platform. This manual entry
describes the C APIs used to communicate between the generic layer
and the type-specific channel drivers. It also explains how new
types of channels can be added by providing new channel
drivers.</p>

<p>Channel drivers consist of a number of components: First, each
channel driver provides a <b>Tcl_ChannelType</b> structure
containing pointers to functions implementing the various
operations used by the generic layer to communicate with the
channel driver. The <b>Tcl_ChannelType</b> structure and the
functions referenced by it are described in the section
<b>TCL_CHANNELTYPE</b>, below.</p>

<p>Second, channel drivers usually provide a Tcl command to create
instances of that type of channel. For example, the Tcl <b><a href=
"../TclCmd/open.htm">open</a></b> command creates channels that use
the file and command channel drivers, and the Tcl <b><a href=
"../TclCmd/socket.htm">socket</a></b> command creates channels that
use TCP sockets for network communication.</p>

<p>Third, a channel driver optionally provides a C function to open
channel instances of that type. For example, <b><a href=
"../TclLib/OpenFileChnl.htm">Tcl_OpenFileChannel</a></b> opens a
channel that uses the file channel driver, and <b><a href=
"../TclLib/OpenTcp.htm">Tcl_OpenTcpClient</a></b> opens a channel
that uses the TCP network protocol. These creation functions
typically use <b>Tcl_CreateChannel</b> internally to open the
channel.</p>

<p>To add a new type of channel you must implement a C API or a Tcl
command that opens a channel by invoking <b>Tcl_CreateChannel</b>.
When your driver calls <b>Tcl_CreateChannel</b> it passes in a
<b>Tcl_ChannelType</b> structure describing the driver's I/O
procedures. The generic layer will then invoke the functions
referenced in that structure to perform operations on the
channel.</p>

<p><b>Tcl_CreateChannel</b> opens a new channel and associates the
supplied <i>typePtr</i> and <i>instanceData</i> with it. The
channel is opened in the mode indicated by <i>mask</i>. For a
discussion of channel drivers, their operations and the
<b>Tcl_ChannelType</b> structure, see the section
<b>TCL_CHANNELTYPE</b>, below.</p>

<p><b>Tcl_CreateChannel</b> interacts with the code managing the
standard channels. Once a standard channel was initialized either
through a call to <b><a href=
"../TclLib/GetStdChan.htm">Tcl_GetStdChannel</a></b> or a call to
<b><a href="../TclLib/GetStdChan.htm">Tcl_SetStdChannel</a></b>
closing this standard channel will cause the next call to
<b>Tcl_CreateChannel</b> to make the new channel the new standard
channel too. See <b><a href=
"../TclLib/StdChannels.htm">Tcl_StandardChannels</a></b> for a
general treatise about standard channels and the behaviour of the
Tcl library with regard to them.</p>

<p><b>Tcl_GetChannelInstanceData</b> returns the instance data
associated with the channel in <i>channel</i>. This is the same as
the <i>instanceData</i> argument in the call to
<b>Tcl_CreateChannel</b> that created this channel.</p>

<p><b>Tcl_GetChannelType</b> returns a pointer to the
<b>Tcl_ChannelType</b> structure used by the channel in the
<i>channel</i> argument. This is the same as the <i>typePtr</i>
argument in the call to <b>Tcl_CreateChannel</b> that created this
channel.</p>

<p><b>Tcl_GetChannelName</b> returns a string containing the name
associated with the channel, or NULL if the <i>channelName</i>
argument to <b>Tcl_CreateChannel</b> was NULL.</p>

<p><b>Tcl_GetChannelHandle</b> places the OS-specific device handle
associated with <i>channel</i> for the given <i>direction</i> in
the location specified by <i>handlePtr</i> and returns
<b>TCL_OK</b>. If the channel does not have a device handle for the
specified direction, then <b>TCL_ERROR</b> is returned instead.
Different channel drivers will return different types of handle.
Refer to the manual entries for each driver to determine what type
of handle is returned.</p>

<p><b>Tcl_GetChannelThread</b> returns the id of the thread
currently managing the specified <i>channel</i>. This allows
channel drivers to send their file events to the correct event
queue even for a multi-threaded core.</p>

<p><b>Tcl_GetChannelMode</b> returns an OR-ed combination of
<b>TCL_READABLE</b> and <b>TCL_WRITABLE</b>, indicating whether the
channel is open for input and output.</p>

<p><b>Tcl_GetChannelBufferSize</b> returns the size, in bytes, of
buffers allocated to store input or output in <i>channel</i>. If
the value was not set by a previous call to
<b>Tcl_SetChannelBufferSize</b>, described below, then the default
value of 4096 is returned.</p>

<p><b>Tcl_SetChannelBufferSize</b> sets the size, in bytes, of
buffers that will be allocated in subsequent operations on the
channel to store input or output. The <i>size</i> argument should
be between ten and one million, allowing buffers of ten bytes to
one million bytes. If <i>size</i> is outside this range,
<b>Tcl_SetChannelBufferSize</b> sets the buffer size to 4096.</p>

<p><b>Tcl_NotifyChannel</b> is called by a channel driver to
indicate to the generic layer that the events specified by
<i>mask</i> have occurred on the channel. Channel drivers are
responsible for invoking this function whenever the channel
handlers need to be called for the channel. See <b>WATCHPROC</b>
below for more details.</p>

<p><b>Tcl_BadChannelOption</b> is called from driver specific
<i>setOptionProc</i> or <i>getOptionProc</i> to generate a complete
error message.</p>

<p><b>Tcl_ChannelBuffered</b> returns the number of bytes of input
currently buffered in the internal buffer (push back area) of the
channel itself. It does not report about the data in the overall
buffers for the stack of channels the supplied channel is part
of.</p>

<p><b>Tcl_IsChannelShared</b> checks the refcount of the specified
<i>channel</i> and returns whether the <i>channel</i> was shared
among multiple interpreters (result == 1) or not (result == 0).</p>

<p><b>Tcl_IsChannelRegistered</b> checks whether the specified
<i>channel</i> is registered in the given <i>interp</i>reter
(result == 1) or not (result == 0).</p>

<p><b>Tcl_IsChannelExisting</b> checks whether a channel with the
specified name is registered in the (thread)-global list of all
channels (result == 1) or not (result == 0).</p>

<p><b>Tcl_CutChannel</b> removes the specified <i>channel</i> from
the (thread)global list of all channels (of the current thread).
Application to a channel still registered in some interpreter is
not allowed. Also notifies the driver if the <b>Tcl_ChannelType</b>
version is <b>TCL_CHANNEL_VERSION_4</b> (or higher), and
<b>Tcl_DriverThreadActionProc</b> is defined for it.</p>

<p><b>Tcl_SpliceChannel</b> adds the specified <i>channel</i> to
the (thread)global list of all channels (of the current thread).
Application to a channel registered in some interpreter is not
allowed. Also notifies the driver if the <b>Tcl_ChannelType</b>
version is <b>TCL_CHANNEL_VERSION_4</b> (or higher), and
<b>Tcl_DriverThreadActionProc</b> is defined for it.</p>

<p><b>Tcl_ClearChannelHandlers</b> removes all channel handlers and
event scripts associated with the specified <i>channel</i>, thus
shutting down all event processing for this channel.</p>

<h3><a name="M6">TCL_CHANNELTYPE</a></h3>

A channel driver provides a <b>Tcl_ChannelType</b> structure that
contains pointers to functions that implement the various
operations on a channel; these operations are invoked as needed by
the generic layer. The structure was versioned starting in Tcl
8.3.2/8.4 to correct a problem with stacked channel drivers. See
the <b>OLD CHANNEL TYPES</b> section below for details about the
old structure. 

<p>The <b>Tcl_ChannelType</b> structure contains the following
fields:</p>

<pre>
typedef struct Tcl_ChannelType {
        char *<i>typeName</i>;
        Tcl_ChannelTypeVersion <i>version</i>;
        Tcl_DriverCloseProc *<i>closeProc</i>;
        Tcl_DriverInputProc *<i>inputProc</i>;
        Tcl_DriverOutputProc *<i>outputProc</i>;
        Tcl_DriverSeekProc *<i>seekProc</i>;
        Tcl_DriverSetOptionProc *<i>setOptionProc</i>;
        Tcl_DriverGetOptionProc *<i>getOptionProc</i>;
        Tcl_DriverWatchProc *<i>watchProc</i>;
        Tcl_DriverGetHandleProc *<i>getHandleProc</i>;
        Tcl_DriverClose2Proc *<i>close2Proc</i>;
        Tcl_DriverBlockModeProc *<i>blockModeProc</i>;
        Tcl_DriverFlushProc *<i>flushProc</i>;
        Tcl_DriverHandlerProc *<i>handlerProc</i>;
        Tcl_DriverWideSeekProc *<i>wideSeekProc</i>;
        Tcl_DriverThreadActionProc *<i>threadActionProc</i>;
        Tcl_DriverTruncateProc *<i>truncateProc</i>;
} Tcl_ChannelType;
</pre>

<p>It is not necessary to provide implementations for all channel
operations. Those which are not necessary may be set to NULL in the
struct: <i>blockModeProc</i>, <i>seekProc</i>,
<i>setOptionProc</i>, <i>getOptionProc</i>, and <i>close2Proc</i>,
in addition to <i>flushProc</i>, <i>handlerProc</i>,
<i>threadActionProc</i>, and <i>truncateProc</i>. Other functions
that cannot be implemented in a meaningful way should return
<b>EINVAL</b> when called, to indicate that the operations they
represent are not available. Also note that <i>wideSeekProc</i> can
be NULL if <i>seekProc</i> is.</p>

<p>The user should only use the above structure for
<b>Tcl_ChannelType</b> instantiation. When referencing fields in a
<b>Tcl_ChannelType</b> structure, the following functions should be
used to obtain the values: <b>Tcl_ChannelName</b>,
<b>Tcl_ChannelVersion</b>, <b>Tcl_ChannelBlockModeProc</b>,
<b>Tcl_ChannelCloseProc</b>, <b>Tcl_ChannelClose2Proc</b>,
<b>Tcl_ChannelInputProc</b>, <b>Tcl_ChannelOutputProc</b>,
<b>Tcl_ChannelSeekProc</b>, <b>Tcl_ChannelWideSeekProc</b>,
<b>Tcl_ChannelThreadActionProc</b>, <b>Tcl_ChannelTruncateProc</b>,
<b>Tcl_ChannelSetOptionProc</b>, <b>Tcl_ChannelGetOptionProc</b>,
<b>Tcl_ChannelWatchProc</b>, <b>Tcl_ChannelGetHandleProc</b>,
<b>Tcl_ChannelFlushProc</b>, or <b>Tcl_ChannelHandlerProc</b>.</p>

<p>The change to the structures was made in such a way that
standard channel types are binary compatible. However, channel
types that use stacked channels (i.e. TLS, Trf) have new versions
to correspond to the above change since the previous code for
stacked channels had problems.</p>

<h4><a name="M7">TYPENAME</a></h4>

The <i>typeName</i> field contains a null-terminated string that
identifies the type of the device implemented by this driver, e.g.
<b><a href="../TclCmd/file.htm">file</a></b> or <b><a href=
"../TclCmd/socket.htm">socket</a></b>. 

<p>This value can be retrieved with <b>Tcl_ChannelName</b>, which
returns a pointer to the string.</p>

<h4><a name="M8">VERSION</a></h4>

The <i>version</i> field should be set to the version of the
structure that you require. <b>TCL_CHANNEL_VERSION_2</b> is the
minimum recommended. <b>TCL_CHANNEL_VERSION_3</b> must be set to
specify the <i>wideSeekProc</i> member.
<b>TCL_CHANNEL_VERSION_4</b> must be set to specify the
<i>threadActionProc</i> member (includes <i>wideSeekProc</i>).
<b>TCL_CHANNEL_VERSION_5</b> must be set to specify the
<i>truncateProc</i> members (includes <i>wideSeekProc</i> and
<i>threadActionProc</i>). If it is not set to any of these, then
this <b>Tcl_ChannelType</b> is assumed to have the original
structure. See <b>OLD CHANNEL TYPES</b> for more details. While Tcl
will recognize and function with either structures, stacked
channels must be of at least <b>TCL_CHANNEL_VERSION_2</b> to
function correctly. 

<p>This value can be retrieved with <b>Tcl_ChannelVersion</b>,
which returns one of <b>TCL_CHANNEL_VERSION_5</b>,
<b>TCL_CHANNEL_VERSION_4</b>, <b>TCL_CHANNEL_VERSION_3</b>,
<b>TCL_CHANNEL_VERSION_2</b> or <b>TCL_CHANNEL_VERSION_1</b>.</p>

<h4><a name="M9">BLOCKMODEPROC</a></h4>

The <i>blockModeProc</i> field contains the address of a function
called by the generic layer to set blocking and nonblocking mode on
the device. <i>BlockModeProc</i> should match the following
prototype: 

<pre>
typedef int Tcl_DriverBlockModeProc(
        ClientData <i>instanceData</i>,
        int <i>mode</i>);
</pre>

<p>The <i>instanceData</i> is the same as the value passed to
<b>Tcl_CreateChannel</b> when this channel was created. The
<i>mode</i> argument is either <b>TCL_MODE_BLOCKING</b> or
<b>TCL_MODE_NONBLOCKING</b> to set the device into blocking or
nonblocking mode. The function should return zero if the operation
was successful, or a nonzero POSIX error code if the operation
failed.</p>

<p>If the operation is successful, the function can modify the
supplied <i>instanceData</i> to record that the channel entered
blocking or nonblocking mode and to implement the blocking or
nonblocking behavior. For some device types, the blocking and
nonblocking behavior can be implemented by the underlying operating
system; for other device types, the behavior must be emulated in
the channel driver.</p>

<p>This value can be retrieved with
<b>Tcl_ChannelBlockModeProc</b>, which returns a pointer to the
function.</p>

<p>A channel driver <b>not</b> supplying a <i>blockModeProc</i> has
to be very, very careful. It has to tell the generic layer exactly
which blocking mode is acceptable to it, and should this also
document for the user so that the blocking mode of the channel is
not changed to an unacceptable value. Any confusion here may lead
the interpreter into a (spurious and difficult to find)
deadlock.</p>

<h4><a name="M10">CLOSEPROC AND CLOSE2PROC</a></h4>

The <i>closeProc</i> field contains the address of a function
called by the generic layer to clean up driver-related information
when the channel is closed. <i>CloseProc</i> must match the
following prototype: 

<pre>
typedef int Tcl_DriverCloseProc(
        ClientData <i>instanceData</i>,
        <a href=
"../TclLib/Interp.htm">Tcl_Interp</a> *<i>interp</i>);
</pre>

<p>The <i>instanceData</i> argument is the same as the value
provided to <b>Tcl_CreateChannel</b> when the channel was created.
The function should release any storage maintained by the channel
driver for this channel, and close the input and output devices
encapsulated by this channel. All queued output will have been
flushed to the device before this function is called, and no
further driver operations will be invoked on this instance after
calling the <i>closeProc</i>. If the close operation is successful,
the procedure should return zero; otherwise it should return a
nonzero POSIX error code. In addition, if an error occurs and
<i>interp</i> is not NULL, the procedure should store an error
message in the interpreter's result.</p>

<p>Alternatively, channels that support closing the read and write
sides independently may set <i>closeProc</i> to
<b>TCL_CLOSE2PROC</b> and set <i>close2Proc</i> to the address of a
function that matches the following prototype:</p>

<pre>
typedef int Tcl_DriverClose2Proc(
        ClientData <i>instanceData</i>,
        <a href=
"../TclLib/Interp.htm">Tcl_Interp</a> *<i>interp</i>,
        int <i>flags</i>);
</pre>

<p>The <i>close2Proc</i> will be called with <i>flags</i> set to an
OR'ed combination of <b>TCL_CLOSE_READ</b> or
<b>TCL_CLOSE_WRITE</b> to indicate that the driver should close the
read and/or write side of the channel. The channel driver may be
invoked to perform additional operations on the channel after
<i>close2Proc</i> is called to close one or both sides of the
channel. If <i>flags</i> is <b>0</b> (zero), the driver should
close the channel in the manner described above for
<i>closeProc</i>. No further operations will be invoked on this
instance after <i>close2Proc</i> is called with all flags cleared.
In all cases, the <i>close2Proc</i> function should return zero if
the close operation was successful; otherwise it should return a
nonzero POSIX error code. In addition, if an error occurs and
<i>interp</i> is not NULL, the procedure should store an error
message in the interpreter's result.</p>

<p>The <i>closeProc</i> and <i>close2Proc</i> values can be
retrieved with <b>Tcl_ChannelCloseProc</b> or
<b>Tcl_ChannelClose2Proc</b>, which return a pointer to the
respective function.</p>

<h4><a name="M11">INPUTPROC</a></h4>

The <i>inputProc</i> field contains the address of a function
called by the generic layer to read data from the file or device
and store it in an internal buffer. <i>InputProc</i> must match the
following prototype: 

<pre>
typedef int Tcl_DriverInputProc(
        ClientData <i>instanceData</i>,
        char *<i>buf</i>,
        int <i>bufSize</i>,
        int *<i>errorCodePtr</i>);
</pre>

<p><i>InstanceData</i> is the same as the value passed to
<b>Tcl_CreateChannel</b> when the channel was created. The
<i>buf</i> argument points to an array of bytes in which to store
input from the device, and the <i>bufSize</i> argument indicates
how many bytes are available at <i>buf</i>.</p>

<p>The <i>errorCodePtr</i> argument points to an integer variable
provided by the generic layer. If an error occurs, the function
should set the variable to a POSIX error code that identifies the
error that occurred.</p>

<p>The function should read data from the input device encapsulated
by the channel and store it at <i>buf</i>. On success, the function
should return a nonnegative integer indicating how many bytes were
read from the input device and stored at <i>buf</i>. On error, the
function should return -1. If an error occurs after some data has
been read from the device, that data is lost.</p>

<p>If <i>inputProc</i> can determine that the input device has some
data available but less than requested by the <i>bufSize</i>
argument, the function should only attempt to read as much data as
is available and return without blocking. If the input device has
no data available whatsoever and the channel is in nonblocking
mode, the function should return an <b>EAGAIN</b> error. If the
input device has no data available whatsoever and the channel is in
blocking mode, the function should block for the shortest possible
time until at least one byte of data can be read from the device;
then, it should return as much data as it can read without
blocking.</p>

<p>This value can be retrieved with <b>Tcl_ChannelInputProc</b>,
which returns a pointer to the function.</p>

<h4><a name="M12">OUTPUTPROC</a></h4>

The <i>outputProc</i> field contains the address of a function
called by the generic layer to transfer data from an internal
buffer to the output device. <i>OutputProc</i> must match the
following prototype: 

<pre>
typedef int Tcl_DriverOutputProc(
        ClientData <i>instanceData</i>,
        const char *<i>buf</i>,
        int <i>toWrite</i>,
        int *<i>errorCodePtr</i>);
</pre>

<p><i>InstanceData</i> is the same as the value passed to
<b>Tcl_CreateChannel</b> when the channel was created. The
<i>buf</i> argument contains an array of bytes to be written to the
device, and the <i>toWrite</i> argument indicates how many bytes
are to be written from the <i>buf</i> argument.</p>

<p>The <i>errorCodePtr</i> argument points to an integer variable
provided by the generic layer. If an error occurs, the function
should set this variable to a POSIX error code that identifies the
error.</p>

<p>The function should write the data at <i>buf</i> to the output
device encapsulated by the channel. On success, the function should
return a nonnegative integer indicating how many bytes were written
to the output device. The return value is normally the same as
<i>toWrite</i>, but may be less in some cases such as if the output
operation is interrupted by a signal. If an error occurs the
function should return -1. In case of error, some data may have
been written to the device.</p>

<p>If the channel is nonblocking and the output device is unable to
absorb any data whatsoever, the function should return -1 with an
<b>EAGAIN</b> error without writing any data.</p>

<p>This value can be retrieved with <b>Tcl_ChannelOutputProc</b>,
which returns a pointer to the function.</p>

<h4><a name="M13">SEEKPROC AND WIDESEEKPROC</a></h4>

The <i>seekProc</i> field contains the address of a function called
by the generic layer to move the access point at which subsequent
input or output operations will be applied. <i>SeekProc</i> must
match the following prototype: 

<pre>
typedef int Tcl_DriverSeekProc(
        ClientData <i>instanceData</i>,
        long <i>offset</i>,
        int <i>seekMode</i>,
        int *<i>errorCodePtr</i>);
</pre>

<p>The <i>instanceData</i> argument is the same as the value given
to <b>Tcl_CreateChannel</b> when this channel was created.
<i>Offset</i> and <i>seekMode</i> have the same meaning as for the
<b><a href="../TclLib/OpenFileChnl.htm">Tcl_Seek</a></b> procedure
(described in the manual entry for <b><a href=
"../TclLib/OpenFileChnl.htm">Tcl_OpenFileChannel</a></b>).</p>

<p>The <i>errorCodePtr</i> argument points to an integer variable
provided by the generic layer for returning <b>errno</b> values
from the function. The function should set this variable to a POSIX
error code if an error occurs. The function should store an
<b>EINVAL</b> error code if the channel type does not implement
seeking.</p>

<p>The return value is the new access point or -1 in case of error.
If an error occurred, the function should not move the access
point.</p>

<p>If there is a non-NULL <i>seekProc</i> field, the
<i>wideSeekProc</i> field may contain the address of an alternative
function to use which handles wide (i.e. larger than 32-bit)
offsets, so allowing seeks within files larger than 2GB. The
<i>wideSeekProc</i> will be called in preference to the
<i>seekProc</i>, but both must be defined if the
<i>wideSeekProc</i> is defined. <i>WideSeekProc</i> must match the
following prototype:</p>

<pre>
typedef Tcl_WideInt Tcl_DriverWideSeekProc(
        ClientData <i>instanceData</i>,
        Tcl_WideInt <i>offset</i>,
        int <i>seekMode</i>,
        int *<i>errorCodePtr</i>);
</pre>

<p>The arguments and return values mean the same thing as with
<i>seekProc</i> above, except that the type of offsets and the
return type are different.</p>

<p>The <i>seekProc</i> value can be retrieved with
<b>Tcl_ChannelSeekProc</b>, which returns a pointer to the
function, and similarly the <i>wideSeekProc</i> can be retrieved
with <b>Tcl_ChannelWideSeekProc</b>.</p>

<h4><a name="M14">SETOPTIONPROC</a></h4>

The <i>setOptionProc</i> field contains the address of a function
called by the generic layer to set a channel type specific option
on a channel. <i>setOptionProc</i> must match the following
prototype: 

<pre>
typedef int Tcl_DriverSetOptionProc(
        ClientData <i>instanceData</i>,
        <a href=
"../TclLib/Interp.htm">Tcl_Interp</a> *<i>interp</i>,
        const char *<i>optionName</i>,
        const char *<i>newValue</i>);
</pre>

<p><i>optionName</i> is the name of an option to set, and
<i>newValue</i> is the new value for that option, as a string. The
<i>instanceData</i> is the same as the value given to
<b>Tcl_CreateChannel</b> when this channel was created. The
function should do whatever channel type specific action is
required to implement the new value of the option.</p>

<p>Some options are handled by the generic code and this function
is never called to set them, e.g. <b>-blockmode</b>. Other options
are specific to each channel type and the <i>setOptionProc</i>
procedure of the channel driver will get called to implement them.
The <i>setOptionProc</i> field can be NULL, which indicates that
this channel type supports no type specific options.</p>

<p>If the option value is successfully modified to the new value,
the function returns <b>TCL_OK</b>. It should call
<b>Tcl_BadChannelOption</b> which itself returns <b>TCL_ERROR</b>
if the <i>optionName</i> is unrecognized. If <i>newValue</i>
specifies a value for the option that is not supported or if a
system call error occurs, the function should leave an error
message in the <i>result</i> field of <i>interp</i> if
<i>interp</i> is not NULL. The function should also call <b><a
href="../TclLib/SetErrno.htm">Tcl_SetErrno</a></b> to store an
appropriate POSIX error code.</p>

<p>This value can be retrieved with
<b>Tcl_ChannelSetOptionProc</b>, which returns a pointer to the
function.</p>

<h4><a name="M15">GETOPTIONPROC</a></h4>

The <i>getOptionProc</i> field contains the address of a function
called by the generic layer to get the value of a channel type
specific option on a channel. <i>getOptionProc</i> must match the
following prototype: 

<pre>
typedef int Tcl_DriverGetOptionProc(
        ClientData <i>instanceData</i>,
        <a href=
"../TclLib/Interp.htm">Tcl_Interp</a> *<i>interp</i>,
        const char *<i>optionName</i>,
        Tcl_DString *<i>optionValue</i>);
</pre>

<p><i>OptionName</i> is the name of an option supported by this
type of channel. If the option name is not NULL, the function
stores its current value, as a string, in the Tcl dynamic string
<i>optionValue</i>. If <i>optionName</i> is NULL, the function
stores in <i>optionValue</i> an alternating list of all supported
options and their current values. On success, the function returns
<b>TCL_OK</b>. It should call <b>Tcl_BadChannelOption</b> which
itself returns <b>TCL_ERROR</b> if the <i>optionName</i> is
unrecognized. If a system call error occurs, the function should
leave an error message in the result of <i>interp</i> if
<i>interp</i> is not NULL. The function should also call <b><a
href="../TclLib/SetErrno.htm">Tcl_SetErrno</a></b> to store an
appropriate POSIX error code.</p>

<p>Some options are handled by the generic code and this function
is never called to retrieve their value, e.g. <b>-blockmode</b>.
Other options are specific to each channel type and the
<i>getOptionProc</i> procedure of the channel driver will get
called to implement them. The <i>getOptionProc</i> field can be
NULL, which indicates that this channel type supports no type
specific options.</p>

<p>This value can be retrieved with
<b>Tcl_ChannelGetOptionProc</b>, which returns a pointer to the
function.</p>

<h4><a name="M16">WATCHPROC</a></h4>

The <i>watchProc</i> field contains the address of a function
called by the generic layer to initialize the event notification
mechanism to notice events of interest on this channel.
<i>WatchProc</i> should match the following prototype: 

<pre>
typedef void Tcl_DriverWatchProc(
        ClientData <i>instanceData</i>,
        int <i>mask</i>);
</pre>

<p>The <i>instanceData</i> is the same as the value passed to
<b>Tcl_CreateChannel</b> when this channel was created. The
<i>mask</i> argument is an OR-ed combination of
<b>TCL_READABLE</b>, <b>TCL_WRITABLE</b> and <b>TCL_EXCEPTION</b>;
it indicates events the caller is interested in noticing on this
channel.</p>

<p>The function should initialize device type specific mechanisms
to notice when an event of interest is present on the channel. When
one or more of the designated events occurs on the channel, the
channel driver is responsible for calling <b>Tcl_NotifyChannel</b>
to inform the generic channel module. The driver should take care
not to starve other channel drivers or sources of callbacks by
invoking Tcl_NotifyChannel too frequently. Fairness can be insured
by using the Tcl event queue to allow the channel event to be
scheduled in sequence with other events. See the description of
<b><a href="../TclLib/Notifier.htm">Tcl_QueueEvent</a></b> for
details on how to queue an event.</p>

<p>This value can be retrieved with <b>Tcl_ChannelWatchProc</b>,
which returns a pointer to the function.</p>

<h4><a name="M17">GETHANDLEPROC</a></h4>

The <i>getHandleProc</i> field contains the address of a function
called by the generic layer to retrieve a device-specific handle
from the channel. <i>GetHandleProc</i> should match the following
prototype: 

<pre>
typedef int Tcl_DriverGetHandleProc(
        ClientData <i>instanceData</i>,
        int <i>direction</i>,
        ClientData *<i>handlePtr</i>);
</pre>

<p><i>InstanceData</i> is the same as the value passed to
<b>Tcl_CreateChannel</b> when this channel was created. The
<i>direction</i> argument is either <b>TCL_READABLE</b> to retrieve
the handle used for input, or <b>TCL_WRITABLE</b> to retrieve the
handle used for output.</p>

<p>If the channel implementation has device-specific handles, the
function should retrieve the appropriate handle associated with the
channel, according the <i>direction</i> argument. The handle should
be stored in the location referred to by <i>handlePtr</i>, and
<b>TCL_OK</b> should be returned. If the channel is not open for
the specified direction, or if the channel implementation does not
use device handles, the function should return
<b>TCL_ERROR</b>.</p>

<p>This value can be retrieved with
<b>Tcl_ChannelGetHandleProc</b>, which returns a pointer to the
function.</p>

<h4><a name="M18">FLUSHPROC</a></h4>

The <i>flushProc</i> field is currently reserved for future use. It
should be set to NULL. <i>FlushProc</i> should match the following
prototype: 

<pre>
typedef int Tcl_DriverFlushProc(
        ClientData <i>instanceData</i>);
</pre>

<p>This value can be retrieved with <b>Tcl_ChannelFlushProc</b>,
which returns a pointer to the function.</p>

<h4><a name="M19">HANDLERPROC</a></h4>

The <i>handlerProc</i> field contains the address of a function
called by the generic layer to notify the channel that an event
occurred. It should be defined for stacked channel drivers that
wish to be notified of events that occur on the underlying
(stacked) channel. <i>HandlerProc</i> should match the following
prototype: 

<pre>
typedef int Tcl_DriverHandlerProc(
        ClientData <i>instanceData</i>,
        int <i>interestMask</i>);
</pre>

<p><i>InstanceData</i> is the same as the value passed to
<b>Tcl_CreateChannel</b> when this channel was created. The
<i>interestMask</i> is an OR-ed combination of <b>TCL_READABLE</b>
or <b>TCL_WRITABLE</b>; it indicates what type of event occurred on
this channel.</p>

<p>This value can be retrieved with <b>Tcl_ChannelHandlerProc</b>,
which returns a pointer to the function.</p>

<h4><a name="M20">THREADACTIONPROC</a></h4>

The <i>threadActionProc</i> field contains the address of the
function called by the generic layer when a channel is created,
closed, or going to move to a different thread, i.e. whenever
thread-specific driver state might have to initialized or updated.
It can be NULL. The action <i>TCL_CHANNEL_THREAD_REMOVE</i> is used
to notify the driver that it should update or remove any
thread-specific data it might be maintaining for the channel. 

<p>The action <i>TCL_CHANNEL_THREAD_INSERT</i> is used to notify
the driver that it should update or initialize any thread-specific
data it might be maintaining using the calling thread as the
associate. See <b>Tcl_CutChannel</b> and <b>Tcl_SpliceChannel</b>
for more detail.</p>

<pre>
typedef void Tcl_DriverThreadActionProc(
        ClientData <i>instanceData</i>,
        int        <i>action</i>);
</pre>

<p><i>InstanceData</i> is the same as the value passed to
<b>Tcl_CreateChannel</b> when this channel was created.</p>

<p>These values can be retrieved with
<b>Tcl_ChannelThreadActionProc</b>, which returns a pointer to the
function.</p>

<h4><a name="M21">TRUNCATEPROC</a></h4>

The <i>truncateProc</i> field contains the address of the function
called by the generic layer when a channel is truncated to some
length. It can be NULL. 

<pre>
typedef int Tcl_DriverTruncateProc(
        ClientData <i>instanceData</i>,
        Tcl_WideInt <i>length</i>);
</pre>

<p><i>InstanceData</i> is the same as the value passed to
<b>Tcl_CreateChannel</b> when this channel was created, and
<i>length</i> is the new length of the underlying file, which
should not be negative. The result should be 0 on success or an
errno code (suitable for use with <b><a href=
"../TclLib/SetErrno.htm">Tcl_SetErrno</a></b>) on failure.</p>

<p>These values can be retrieved with
<b>Tcl_ChannelTruncateProc</b>, which returns a pointer to the
function.</p>

<h3><a name="M22">TCL_BADCHANNELOPTION</a></h3>

This procedure generates a &ldquo;bad option&rdquo; error message
in an (optional) interpreter. It is used by channel drivers when an
invalid Set/Get option is requested. Its purpose is to concatenate
the generic options list to the specific ones and factorize the
generic options error message string. 

<p>It always returns <b>TCL_ERROR</b></p>

<p>An error message is generated in <i>interp</i>'s result object
to indicate that a command was invoked with a bad option. The
message has the form</p>

<pre>
bad option "blah": should be one of 
    &lt;...generic options...&gt;+&lt;...specific options...&gt;
</pre>

so you get for instance: 

<pre>
bad option "-blah": should be one of -blocking,
    -buffering, -buffersize, -eofchar, -translation,
    -peername, or -sockname
</pre>

when called with <i>optionList</i> equal to &ldquo;peername
sockname&rdquo; 

<p>&ldquo;blah&rdquo; is the <i>optionName</i> argument and
&ldquo;&lt;specific options&gt;&rdquo; is a space separated list of
specific option words. The function takes good care of inserting
minus signs before each option, commas after, and an
&ldquo;or&rdquo; before the last option.</p>

<h3><a name="M23">OLD CHANNEL TYPES</a></h3>

The original (8.3.1 and below) <b>Tcl_ChannelType</b> structure
contains the following fields: 

<pre>
typedef struct Tcl_ChannelType {
        char *<i>typeName</i>;
        Tcl_DriverBlockModeProc *<i>blockModeProc</i>;
        Tcl_DriverCloseProc *<i>closeProc</i>;
        Tcl_DriverInputProc *<i>inputProc</i>;
        Tcl_DriverOutputProc *<i>outputProc</i>;
        Tcl_DriverSeekProc *<i>seekProc</i>;
        Tcl_DriverSetOptionProc *<i>setOptionProc</i>;
        Tcl_DriverGetOptionProc *<i>getOptionProc</i>;
        Tcl_DriverWatchProc *<i>watchProc</i>;
        Tcl_DriverGetHandleProc *<i>getHandleProc</i>;
        Tcl_DriverClose2Proc *<i>close2Proc</i>;
} Tcl_ChannelType;
</pre>

<p>It is still possible to create channel with the above structure.
The internal channel code will determine the version. It is
imperative to use the new <b>Tcl_ChannelType</b> structure if you
are creating a stacked channel driver, due to problems with the
earlier stacked channel implementation (in 8.2.0 to 8.3.1).</p>

<p>Prior to 8.4.0 (i.e. during the later releases of 8.3 and early
part of the 8.4 development cycle) the <b>Tcl_ChannelType</b>
structure contained the following fields:</p>

<pre>
typedef struct Tcl_ChannelType {
        char *<i>typeName</i>;
        Tcl_ChannelTypeVersion <i>version</i>;
        Tcl_DriverCloseProc *<i>closeProc</i>;
        Tcl_DriverInputProc *<i>inputProc</i>;
        Tcl_DriverOutputProc *<i>outputProc</i>;
        Tcl_DriverSeekProc *<i>seekProc</i>;
        Tcl_DriverSetOptionProc *<i>setOptionProc</i>;
        Tcl_DriverGetOptionProc *<i>getOptionProc</i>;
        Tcl_DriverWatchProc *<i>watchProc</i>;
        Tcl_DriverGetHandleProc *<i>getHandleProc</i>;
        Tcl_DriverClose2Proc *<i>close2Proc</i>;
        Tcl_DriverBlockModeProc *<i>blockModeProc</i>;
        Tcl_DriverFlushProc *<i>flushProc</i>;
        Tcl_DriverHandlerProc *<i>handlerProc</i>;
        Tcl_DriverTruncateProc *<i>truncateProc</i>;
} Tcl_ChannelType;
</pre>

<p>When the above structure is registered as a channel type, the
<i>version</i> field should always be
<b>TCL_CHANNEL_VERSION_2</b>.</p>

<h3><a name="M24">SEE ALSO</a></h3>

<b><a href="../TclLib/OpenFileChnl.htm">Tcl_Close</a></b>, <b><a
href="../TclLib/OpenFileChnl.htm">Tcl_OpenFileChannel</a></b>,
<b><a href="../TclLib/SetErrno.htm">Tcl_SetErrno</a></b>, <b><a
href="../TclLib/Notifier.htm">Tcl_QueueEvent</a></b>, <b><a href=
"../TclLib/ChnlStack.htm">Tcl_StackChannel</a></b>, <b><a href=
"../TclLib/GetStdChan.htm">Tcl_GetStdChannel</a></b> 

<h3><a name="M25">KEYWORDS</a></h3>

<a href="../Keywords/B.htm#blocking">blocking</a>, <a href=
"../Keywords/C.htm#channel driver">channel driver</a>, <a href=
"../Keywords/C.htm#channel registration">channel registration</a>,
<a href="../Keywords/C.htm#channel type">channel type</a>, <a href=
"../Keywords/N.htm#nonblocking">nonblocking</a> 

<div class="copy">Copyright &copy; 1995-1997 Roger E. Critchlow Jr.
Copyright &copy; 1996-1997 Sun Microsystems, Inc. Copyright &copy;
1997-2000 Ajuba Solutions.</div>
</body>
</html>

