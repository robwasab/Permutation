<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<meta name="generator" content="HTML Tidy, see www.w3.org">
<meta name='Author' content='ActiveState'>
<link rel='stylesheet' type='text/css' href='../../aspn.css'>
<title>Tcl Built-In Commands - interp manual page</title>
<link rel="stylesheet" href="../docs.css" type="text/css" media=
"all">
</head>
<body>
<div class="banner">
<table width="100%" border="0" cellspacing="0" cellpadding="3">
<tr>
<td align="left"><a target="_blank" href=
"http://www.activestate.com/activetcl"><img src=
"../../images/ActiveTcl.gif" border="0" align="left" alt=
"ActiveTcl"></a> </td>
<td align="center" class="heading">ActiveTcl User Guide</td>
<td align="right"><a target="_blank" href=
"http://www.activestate.com"><img src="../../images/AS_logo.gif"
border="0" align="right" alt="ActiveState Software Inc."></a> </td>
</tr>
</table>
</div>

<br>
<h2><a href="../contents.htm">Tcl/Tk Documentation</a>
<small>&gt;</small> <a href="contents.htm">TclCmd</a>
<small>&gt;</small> interp</h2>

<h3><a href="../UserCmd/contents.htm">Tcl/Tk Applications</a> | <a
href="../TclCmd/contents.htm">Tcl Commands</a> | <a href=
"../TkCmd/contents.htm">Tk Commands</a> | <a href=
"../TclLib/contents.htm">Tcl Library</a> | <a href=
"../TkLib/contents.htm">Tk Library</a></h3>

<dl>
<dd><a href="interp.htm#M2" name="L720">NAME</a> 

<dl>
<dd>interp - Create and manipulate Tcl interpreters</dd>
</dl>
</dd>

<dd><a href="interp.htm#M3" name="L721">SYNOPSIS</a> 

<dl>
<dd><b>interp</b> <i>subcommand</i> ?<i>arg arg ...</i>?</dd>
</dl>
</dd>

<dd><a href="interp.htm#M4" name="L722">DESCRIPTION</a></dd>

<dd><a href="interp.htm#M5" name="L723">THE INTERP COMMAND</a> 

<dl class="the interp command">
<dd><a href="interp.htm#M6" name="L724"><b>interp</b> <b>alias</b>
<i>srcPath</i> <i>srcToken</i></a></dd>

<dd><a href="interp.htm#M7" name="L725"><b>interp</b> <b>alias</b>
<i>srcPath</i> <i>srcToken</i> <b>{}</b></a></dd>

<dd><a href="interp.htm#M8" name="L726"><b>interp</b> <b>alias</b>
<i>srcPath</i> <i>srcCmd</i> <i>targetPath</i> <i>targetCmd</i>
?<i>arg arg ...</i>?</a></dd>

<dd><a href="interp.htm#M9" name="L727"><b>interp</b>
<b>aliases</b> ?<i>path</i>?</a></dd>

<dd><a href="interp.htm#M10" name="L728"><b>interp bgerror</b>
<i>path</i> ?<i>cmdPrefix</i>?</a></dd>

<dd><a href="interp.htm#M11" name="L729"><b>interp</b>
<b>create</b> ?<b>-safe</b>? ?<b>--</b>? ?<i>path</i>?</a></dd>

<dd><a href="interp.htm#M12" name="L730"><b>interp</b> <b>debug</b>
<i>path</i> ?<i>-frame</i> ?<i>bool</i>??</a></dd>
</dl>

<dl class="the interp command">
<dd><a href="interp.htm#M13" name="L731"><b>interp</b>
<b>delete</b> ?<i>path ...?</i></a></dd>

<dd><a href="interp.htm#M14" name="L732"><b>interp</b> <b>eval</b>
<i>path arg</i> ?<i>arg ...</i>?</a></dd>

<dd><a href="interp.htm#M15" name="L733"><b>interp exists</b>
<i>path</i></a></dd>

<dd><a href="interp.htm#M16" name="L734"><b>interp expose</b>
<i>path</i> <i>hiddenName</i> ?<i>exposedCmdName</i>?</a></dd>

<dd><a href="interp.htm#M17" name="L735"><b>interp</b> <b>hide</b>
<i>path</i> <i>exposedCmdName</i> ?<i>hiddenCmdName</i>?</a></dd>

<dd><a href="interp.htm#M18" name="L736"><b>interp</b>
<b>hidden</b> <i>path</i></a></dd>

<dd><a href="interp.htm#M19" name="L737"><b>interp</b>
<b>invokehidden</b> <i>path</i> ?<i>-option ...</i>?
<i>hiddenCmdName</i> ?<i>arg ...</i>?</a></dd>

<dd><a href="interp.htm#M20" name="L738"><b>interp</b> <b>limit</b>
<i>path</i> <i>limitType</i> ?<i>-option</i>? ?<i>value</i>
<i>...</i>?</a></dd>

<dd><a href="interp.htm#M21" name="L739"><b>interp issafe</b>
?<i>path</i>?</a></dd>

<dd><a href="interp.htm#M22" name="L740"><b>interp marktrusted</b>
<i>path</i></a></dd>

<dd><a href="interp.htm#M23" name="L741"><b>interp</b>
<b>recursionlimit</b> <i>path</i> ?<i>newlimit</i>?</a></dd>

<dd><a href="interp.htm#M24" name="L742"><b>interp</b> <b>share</b>
<i>srcPath channelId destPath</i></a></dd>

<dd><a href="interp.htm#M25" name="L743"><b>interp</b>
<b>slaves</b> ?<i>path</i>?</a></dd>

<dd><a href="interp.htm#M26" name="L744"><b>interp</b>
<b>target</b> <i>path alias</i></a></dd>

<dd><a href="interp.htm#M27" name="L745"><b>interp</b>
<b>transfer</b> <i>srcPath channelId destPath</i></a></dd>
</dl>
</dd>

<dd><a href="interp.htm#M28" name="L746">SLAVE COMMAND</a> 

<dl class="slave command">
<dd><a href="interp.htm#M29" name="L747"><i>slave</i>
<b>aliases</b></a></dd>

<dd><a href="interp.htm#M30" name="L748"><i>slave</i> <b>alias</b>
<i>srcToken</i></a></dd>

<dd><a href="interp.htm#M31" name="L749"><i>slave</i> <b>alias</b>
<i>srcToken</i> <b>{}</b></a></dd>

<dd><a href="interp.htm#M32" name="L750"><i>slave</i> <b>alias</b>
<i>srcCmd targetCmd</i> ?<i>arg ..</i>?</a></dd>

<dd><a href="interp.htm#M33" name="L751"><i>slave</i>
<b>bgerror</b> ?<i>cmdPrefix</i>?</a></dd>

<dd><a href="interp.htm#M34" name="L752"><i>slave</i> <b>eval</b>
<i>arg</i> ?<i>arg ..</i>?</a></dd>

<dd><a href="interp.htm#M35" name="L753"><i>slave</i> <b>expose</b>
<i>hiddenName</i> ?<i>exposedCmdName</i>?</a></dd>

<dd><a href="interp.htm#M36" name="L754"><i>slave</i> <b>hide</b>
<i>exposedCmdName</i> ?<i>hiddenCmdName</i>?</a></dd>

<dd><a href="interp.htm#M37" name="L755"><i>slave</i>
<b>hidden</b></a></dd>

<dd><a href="interp.htm#M38" name="L756"><i>slave</i>
<b>invokehidden</b> ?<i>-option ...</i>? <i>hiddenName</i> ?<i>arg
..</i>?</a></dd>

<dd><a href="interp.htm#M39" name="L757"><i>slave</i>
<b>issafe</b></a></dd>

<dd><a href="interp.htm#M40" name="L758"><i>slave</i> <b>limit</b>
<i>limitType</i> ?<i>-option</i>? ?<i>value</i>
<i>...</i>?</a></dd>

<dd><a href="interp.htm#M41" name="L759"><i>slave</i>
<b>marktrusted</b></a></dd>

<dd><a href="interp.htm#M42" name="L760"><i>slave</i>
<b>recursionlimit</b> ?<i>newlimit</i>?</a></dd>
</dl>
</dd>

<dd><a href="interp.htm#M43" name="L761">SAFE INTERPRETERS</a></dd>

<dd><a href="interp.htm#M44" name="L762">ALIAS INVOCATION</a></dd>

<dd><a href="interp.htm#M45" name="L763">HIDDEN COMMANDS</a></dd>

<dd><a href="interp.htm#M46" name="L764">RESOURCE LIMITS</a></dd>

<dd><a href="interp.htm#M47" name="L765">LIMIT OPTIONS</a> 

<dl class="limit options">
<dd><a href="interp.htm#M48" name="L766"><b>-command</b></a></dd>

<dd><a href="interp.htm#M49" name=
"L767"><b>-granularity</b></a></dd>

<dd><a href="interp.htm#M50" name=
"L768"><b>-milliseconds</b></a></dd>

<dd><a href="interp.htm#M51" name="L769"><b>-seconds</b></a></dd>

<dd><a href="interp.htm#M52" name="L770"><b>-value</b></a></dd>
</dl>
</dd>

<dd><a href="interp.htm#M53" name="L771">BACKGROUND ERROR
HANDLING</a></dd>

<dd><a href="interp.htm#M54" name="L772">CREDITS</a></dd>

<dd><a href="interp.htm#M55" name="L773">EXAMPLES</a></dd>

<dd><a href="interp.htm#M56" name="L774">SEE ALSO</a></dd>

<dd><a href="interp.htm#M57" name="L775">KEYWORDS</a></dd>
</dl>

<h3><a name="M2">NAME</a></h3>

interp - Create and manipulate Tcl interpreters 

<h3><a name="M3">SYNOPSIS</a></h3>

<b>interp</b> <i>subcommand</i> ?<i>arg arg ...</i>?<br>
<h3><a name="M4">DESCRIPTION</a></h3>

This command makes it possible to create one or more new Tcl
interpreters that co-exist with the creating interpreter in the
same application. The creating interpreter is called the
<i>master</i> and the new interpreter is called a <i>slave</i>. A
master can create any number of slaves, and each slave can itself
create additional slaves for which it is master, resulting in a
hierarchy of interpreters. 

<p>Each interpreter is independent from the others: it has its own
name space for commands, procedures, and global variables. A master
interpreter may create connections between its slaves and itself
using a mechanism called an <i>alias</i>. An <i>alias</i> is a
command in a slave interpreter which, when invoked, causes a
command to be invoked in its master interpreter or in another slave
interpreter. The only other connections between interpreters are
through environment variables (the <b>env</b> variable), which are
normally shared among all interpreters in the application, and by
resource limit exceeded callbacks. Note that the name space for
files (such as the names returned by the <b><a href=
"../TclCmd/open.htm">open</a></b> command) is no longer shared
between interpreters. Explicit commands are provided to share files
and to transfer references to open files from one interpreter to
another.</p>

<p>The <b>interp</b> command also provides support for <i>safe</i>
interpreters. A safe interpreter is a slave whose functions have
been greatly restricted, so that it is safe to execute untrusted
scripts without fear of them damaging other interpreters or the
application's environment. For example, all IO channel creation
commands and subprocess creation commands are made inaccessible to
safe interpreters. See <b>SAFE INTERPRETERS</b> below for more
information on what features are present in a safe interpreter. The
dangerous functionality is not removed from the safe interpreter;
instead, it is <i>hidden</i>, so that only trusted interpreters can
obtain access to it. For a detailed explanation of hidden commands,
see <b>HIDDEN COMMANDS</b>, below. The alias mechanism can be used
for protected communication (analogous to a kernel call) between a
slave interpreter and its master. See <b>ALIAS INVOCATION</b>,
below, for more details on how the alias mechanism works.</p>

<p>A qualified interpreter name is a proper Tcl lists containing a
subset of its ancestors in the interpreter hierarchy, terminated by
the string naming the interpreter in its immediate master.
Interpreter names are relative to the interpreter in which they are
used. For example, if <b>a</b> is a slave of the current
interpreter and it has a slave <b>a1</b>, which in turn has a slave
<b>a11</b>, the qualified name of <b>a11</b> in <b>a</b> is the
list <b>a1 a11</b>.</p>

<p>The <b>interp</b> command, described below, accepts qualified
interpreter names as arguments; the interpreter in which the
command is being evaluated can always be referred to as <b>{}</b>
(the empty list or string). Note that it is impossible to refer to
a master (ancestor) interpreter by name in a slave interpreter
except through aliases. Also, there is no global name by which one
can refer to the first interpreter created in an application. Both
restrictions are motivated by safety concerns.</p>

<h3><a name="M5">THE INTERP COMMAND</a></h3>

The <b>interp</b> command is used to create, delete, and manipulate
slave interpreters, and to share or transfer channels between
interpreters. It can have any of several forms, depending on the
<i>subcommand</i> argument: 

<dl class="the interp command">
<dt><a name="M6"><b>interp</b> <b>alias</b> <i>srcPath</i>
<i>srcToken</i></a></dt>

<dd>Returns a Tcl list whose elements are the <i>targetCmd</i> and
<i>arg</i>s associated with the alias represented by
<i>srcToken</i> (this is the value returned when the alias was
created; it is possible that the name of the source command in the
slave is different from <i>srcToken</i>).</dd>

<dt><a name="M7"><b>interp</b> <b>alias</b> <i>srcPath</i>
<i>srcToken</i> <b>{}</b></a></dt>

<dd>Deletes the alias for <i>srcToken</i> in the slave interpreter
identified by <i>srcPath</i>. <i>srcToken</i> refers to the value
returned when the alias was created; if the source command has been
renamed, the renamed command will be deleted.</dd>

<dt><a name="M8"><b>interp</b> <b>alias</b> <i>srcPath</i>
<i>srcCmd</i> <i>targetPath</i> <i>targetCmd</i> ?<i>arg arg
...</i>?</a></dt>

<dd>This command creates an alias between one slave and another
(see the <b>alias</b> slave command below for creating aliases
between a slave and its master). In this command, either of the
slave interpreters may be anywhere in the hierarchy of interpreters
under the interpreter invoking the command. <i>SrcPath</i> and
<i>srcCmd</i> identify the source of the alias. <i>SrcPath</i> is a
Tcl list whose elements select a particular interpreter. For
example, &ldquo;<b>a b</b>&rdquo; identifies an interpreter
<b>b</b>, which is a slave of interpreter <b>a</b>, which is a
slave of the invoking interpreter. An empty list specifies the
interpreter invoking the command. <i>srcCmd</i> gives the name of a
new command, which will be created in the source interpreter.
<i>TargetPath</i> and <i>targetCmd</i> specify a target interpreter
and command, and the <i>arg</i> arguments, if any, specify
additional arguments to <i>targetCmd</i> which are prepended to any
arguments specified in the invocation of <i>srcCmd</i>.
<i>TargetCmd</i> may be undefined at the time of this call, or it
may already exist; it is not created by this command. The alias
arranges for the given target command to be invoked in the target
interpreter whenever the given source command is invoked in the
source interpreter. See <b>ALIAS INVOCATION</b> below for more
details. The command returns a token that uniquely identifies the
command created <i>srcCmd</i>, even if the command is renamed
afterwards. The token may but does not have to be equal to
<i>srcCmd</i>.</dd>

<dt><a name="M9"><b>interp</b> <b>aliases</b>
?<i>path</i>?</a></dt>

<dd>This command returns a Tcl list of the tokens of all the source
commands for aliases defined in the interpreter identified by
<i>path</i>. The tokens correspond to the values returned when the
aliases were created (which may not be the same as the current
names of the commands).</dd>

<dt><a name="M10"><b>interp bgerror</b> <i>path</i>
?<i>cmdPrefix</i>?</a></dt>

<dd>This command either gets or sets the current background error
handler for the interpreter identified by <i>path</i>. If
<i>cmdPrefix</i> is absent, the current background error handler is
returned, and if it is present, it is a list of words (of minimum
length one) that describes what to set the interpreter's background
error to. See the <b>BACKGROUND ERROR HANDLING</b> section for more
details.</dd>

<dt><a name="M11"><b>interp</b> <b>create</b> ?<b>-safe</b>?
?<b>--</b>? ?<i>path</i>?</a></dt>

<dd>Creates a slave interpreter identified by <i>path</i> and a new
command, called a <i>slave command</i>. The name of the slave
command is the last component of <i>path</i>. The new slave
interpreter and the slave command are created in the interpreter
identified by the path obtained by removing the last component from
<i>path</i>. For example, if <i>path</i> is <b>a b c</b> then a new
slave interpreter and slave command named <b>c</b> are created in
the interpreter identified by the path <b>a b</b>. The slave
command may be used to manipulate the new interpreter as described
below. If <i>path</i> is omitted, Tcl creates a unique name of the
form <b>interp</b><i>x</i>, where <i>x</i> is an integer, and uses
it for the interpreter and the slave command. If the <b>-safe</b>
switch is specified (or if the master interpreter is a safe
interpreter), the new slave interpreter will be created as a safe
interpreter with limited functionality; otherwise the slave will
include the full set of Tcl built-in commands and variables. The
<b>--</b> switch can be used to mark the end of switches; it may be
needed if <i>path</i> is an unusual value such as <b>-safe</b>. The
result of the command is the name of the new interpreter. The name
of a slave interpreter must be unique among all the slaves for its
master; an error occurs if a slave interpreter by the given name
already exists in this master. The initial recursion limit of the
slave interpreter is set to the current recursion limit of its
parent interpreter.</dd>

<dt><a name="M12"><b>interp</b> <b>debug</b> <i>path</i>
?<i>-frame</i> ?<i>bool</i>??</a></dt>

<dd>Controls whether frame-level stack information is captured in
the slave interpreter identified by <i>path</i>. If no arguments
are given, option and current setting are returned. If
<i>-frame</i> is given, the debug setting is set to the given
boolean if provided and the current setting is returned. This only
effects the output of <b><a href="../TclCmd/info.htm">info
frame</a></b>, in that exact frame-level information for command
invocation at the bytecode level is only captured with this setting
on.</dd>
</dl>

<dl>
<dd>For example, with code like 

<pre>
<b><a href=
"../TclCmd/proc.htm">proc</a></b> mycontrol {... script} {
  ...
  <b><a href="../TclCmd/uplevel.htm">uplevel</a></b> 1 $script
  ...
}

<b><a href="../TclCmd/proc.htm">proc</a></b> dosomething {...} {
  ...
  mycontrol {
    somecode
  }
}
</pre>

<p>the standard setting will provide a relative line number for the
command <b>somecode</b> and the relevant frame will be of type
<b><a href="../TclCmd/eval.htm">eval</a></b>. With frame-debug
active on the other hand the tracking extends so far that the
system will be able to determine the file and absolute line number
of this command, and return a frame of type <b><a href=
"../TclCmd/source.htm">source</a></b>. This more exact information
is paid for with slower execution of all commands.</p>
</dd>
</dl>

<dl class="the interp command">
<dt><a name="M13"><b>interp</b> <b>delete</b> ?<i>path
...?</i></a></dt>

<dd>Deletes zero or more interpreters given by the optional
<i>path</i> arguments, and for each interpreter, it also deletes
its slaves. The command also deletes the slave command for each
interpreter deleted. For each <i>path</i> argument, if no
interpreter by that name exists, the command raises an error.</dd>

<dt><a name="M14"><b>interp</b> <b>eval</b> <i>path arg</i> ?<i>arg
...</i>?</a></dt>

<dd>This command concatenates all of the <i>arg</i> arguments in
the same fashion as the <b><a href=
"../TclCmd/concat.htm">concat</a></b> command, then evaluates the
resulting string as a Tcl script in the slave interpreter
identified by <i>path</i>. The result of this evaluation (including
all <b><a href="../TclCmd/return.htm">return</a></b> options, such
as <b>-errorinfo</b> and <b>-errorcode</b> information, if an error
occurs) is returned to the invoking interpreter. Note that the
script will be executed in the current context stack frame of the
<i>path</i> interpreter; this is so that the implementations (in a
master interpreter) of aliases in a slave interpreter can execute
scripts in the slave that find out information about the slave's
current state and stack frame.</dd>

<dt><a name="M15"><b>interp exists</b> <i>path</i></a></dt>

<dd>Returns <b>1</b> if a slave interpreter by the specified
<i>path</i> exists in this master, <b>0</b> otherwise. If
<i>path</i> is omitted, the invoking interpreter is used.</dd>

<dt><a name="M16"><b>interp expose</b> <i>path</i>
<i>hiddenName</i> ?<i>exposedCmdName</i>?</a></dt>

<dd>Makes the hidden command <i>hiddenName</i> exposed, eventually
bringing it back under a new <i>exposedCmdName</i> name (this name
is currently accepted only if it is a valid global name space name
without any ::), in the interpreter denoted by <i>path</i>. If an
exposed command with the targeted name already exists, this command
fails. Hidden commands are explained in more detail in <b>HIDDEN
COMMANDS</b>, below.</dd>

<dt><a name="M17"><b>interp</b> <b>hide</b> <i>path</i>
<i>exposedCmdName</i> ?<i>hiddenCmdName</i>?</a></dt>

<dd>Makes the exposed command <i>exposedCmdName</i> hidden,
renaming it to the hidden command <i>hiddenCmdName</i>, or keeping
the same name if <i>hiddenCmdName</i> is not given, in the
interpreter denoted by <i>path</i>. If a hidden command with the
targeted name already exists, this command fails. Currently both
<i>exposedCmdName</i> and <i>hiddenCmdName</i> can not contain
namespace qualifiers, or an error is raised. Commands to be hidden
by <b>interp hide</b> are looked up in the global namespace even if
the current namespace is not the global one. This prevents slaves
from fooling a master interpreter into hiding the wrong command, by
making the current namespace be different from the global one.
Hidden commands are explained in more detail in <b>HIDDEN
COMMANDS</b>, below.</dd>

<dt><a name="M18"><b>interp</b> <b>hidden</b> <i>path</i></a></dt>

<dd>Returns a list of the names of all hidden commands in the
interpreter identified by <i>path</i>.</dd>

<dt><a name="M19"><b>interp</b> <b>invokehidden</b> <i>path</i>
?<i>-option ...</i>? <i>hiddenCmdName</i> ?<i>arg ...</i>?</a></dt>

<dd>Invokes the hidden command <i>hiddenCmdName</i> with the
arguments supplied in the interpreter denoted by <i>path</i>. No
substitutions or evaluation are applied to the arguments. Three
<i>-option</i>s are supported, all of which start with <b>-</b>:
<b>-namespace</b> (which takes a single argument afterwards,
<i>nsName</i>), <b>-global</b>, and <b>--</b>. If the
<b>-namespace</b> flag is present, the hidden command is invoked in
the namespace called <i>nsName</i> in the target interpreter. If
the <b>-global</b> flag is present, the hidden command is invoked
at the global level in the target interpreter; otherwise it is
invoked at the current call frame and can access local variables in
that and outer call frames. The <b>--</b> flag allows the
<i>hiddenCmdName</i> argument to start with a &ldquo;-&rdquo;
character, and is otherwise unnecessary. If both the
<b>-namespace</b> and <b>-global</b> flags are present, the
<b>-namespace</b> flag is ignored. Note that the hidden command
will be executed (by default) in the current context stack frame of
the <i>path</i> interpreter. Hidden commands are explained in more
detail in <b>HIDDEN COMMANDS</b>, below.</dd>

<dt><a name="M20"><b>interp</b> <b>limit</b> <i>path</i>
<i>limitType</i> ?<i>-option</i>? ?<i>value</i>
<i>...</i>?</a></dt>

<dd>Sets up, manipulates and queries the configuration of the
resource limit <i>limitType</i> for the interpreter denoted by
<i>path</i>. If no <i>-option</i> is specified, return the current
configuration of the limit. If <i>-option</i> is the sole argument,
return the value of that option. Otherwise, a list of
<i>-option</i>/<i>value</i> argument pairs must supplied. See
<b>RESOURCE LIMITS</b> below for a more detailed explanation of
what limits and options are supported.</dd>

<dt><a name="M21"><b>interp issafe</b> ?<i>path</i>?</a></dt>

<dd>Returns <b>1</b> if the interpreter identified by the specified
<i>path</i> is safe, <b>0</b> otherwise.</dd>

<dt><a name="M22"><b>interp marktrusted</b> <i>path</i></a></dt>

<dd>Marks the interpreter identified by <i>path</i> as trusted.
Does not expose the hidden commands. This command can only be
invoked from a trusted interpreter. The command has no effect if
the interpreter identified by <i>path</i> is already trusted.</dd>

<dt><a name="M23"><b>interp</b> <b>recursionlimit</b> <i>path</i>
?<i>newlimit</i>?</a></dt>

<dd>Returns the maximum allowable nesting depth for the interpreter
specified by <i>path</i>. If <i>newlimit</i> is specified, the
interpreter recursion limit will be set so that nesting of more
than <i>newlimit</i> calls to <b>Tcl_Eval()</b> and related
procedures in that interpreter will return an error. The
<i>newlimit</i> value is also returned. The <i>newlimit</i> value
must be a positive integer between 1 and the maximum value of a
non-long integer on the platform. 

<p>The command sets the maximum size of the Tcl call stack only. It
cannot by itself prevent stack overflows on the C stack being used
by the application. If your machine has a limit on the size of the
C stack, you may get stack overflows before reaching the limit set
by the command. If this happens, see if there is a mechanism in
your system for increasing the maximum size of the C stack.</p>
</dd>

<dt><a name="M24"><b>interp</b> <b>share</b> <i>srcPath channelId
destPath</i></a></dt>

<dd>Causes the IO channel identified by <i>channelId</i> to become
shared between the interpreter identified by <i>srcPath</i> and the
interpreter identified by <i>destPath</i>. Both interpreters have
the same permissions on the IO channel. Both interpreters must
close it to close the underlying IO channel; IO channels accessible
in an interpreter are automatically closed when an interpreter is
destroyed.</dd>

<dt><a name="M25"><b>interp</b> <b>slaves</b>
?<i>path</i>?</a></dt>

<dd>Returns a Tcl list of the names of all the slave interpreters
associated with the interpreter identified by <i>path</i>. If
<i>path</i> is omitted, the invoking interpreter is used.</dd>

<dt><a name="M26"><b>interp</b> <b>target</b> <i>path
alias</i></a></dt>

<dd>Returns a Tcl list describing the target interpreter for an
alias. The alias is specified with an interpreter path and source
command name, just as in <b>interp alias</b> above. The name of the
target interpreter is returned as an interpreter path, relative to
the invoking interpreter. If the target interpreter for the alias
is the invoking interpreter then an empty list is returned. If the
target interpreter for the alias is not the invoking interpreter or
one of its descendants then an error is generated. The target
command does not have to be defined at the time of this
invocation.</dd>

<dt><a name="M27"><b>interp</b> <b>transfer</b> <i>srcPath
channelId destPath</i></a></dt>

<dd>Causes the IO channel identified by <i>channelId</i> to become
available in the interpreter identified by <i>destPath</i> and
unavailable in the interpreter identified by <i>srcPath</i>.</dd>
</dl>

<h3><a name="M28">SLAVE COMMAND</a></h3>

For each slave interpreter created with the <b>interp</b> command,
a new Tcl command is created in the master interpreter with the
same name as the new interpreter. This command may be used to
invoke various operations on the interpreter. It has the following
general form: 

<pre>
<i>slave command</i> ?<i>arg arg ...</i>?
</pre>

<i>Slave</i> is the name of the interpreter, and <i>command</i> and
the <i>arg</i>s determine the exact behavior of the command. The
valid forms of this command are: 

<dl class="slave command">
<dt><a name="M29"><i>slave</i> <b>aliases</b></a></dt>

<dd>Returns a Tcl list whose elements are the tokens of all the
aliases in <i>slave</i>. The tokens correspond to the values
returned when the aliases were created (which may not be the same
as the current names of the commands).</dd>

<dt><a name="M30"><i>slave</i> <b>alias</b>
<i>srcToken</i></a></dt>

<dd>Returns a Tcl list whose elements are the <i>targetCmd</i> and
<i>arg</i>s associated with the alias represented by
<i>srcToken</i> (this is the value returned when the alias was
created; it is possible that the actual source command in the slave
is different from <i>srcToken</i>).</dd>

<dt><a name="M31"><i>slave</i> <b>alias</b> <i>srcToken</i>
<b>{}</b></a></dt>

<dd>Deletes the alias for <i>srcToken</i> in the slave interpreter.
<i>srcToken</i> refers to the value returned when the alias was
created; if the source command has been renamed, the renamed
command will be deleted.</dd>

<dt><a name="M32"><i>slave</i> <b>alias</b> <i>srcCmd targetCmd</i>
?<i>arg ..</i>?</a></dt>

<dd>Creates an alias such that whenever <i>srcCmd</i> is invoked in
<i>slave</i>, <i>targetCmd</i> is invoked in the master. The
<i>arg</i> arguments will be passed to <i>targetCmd</i> as
additional arguments, prepended before any arguments passed in the
invocation of <i>srcCmd</i>. See <b>ALIAS INVOCATION</b> below for
details. The command returns a token that uniquely identifies the
command created <i>srcCmd</i>, even if the command is renamed
afterwards. The token may but does not have to be equal to
<i>srcCmd</i>.</dd>

<dt><a name="M33"><i>slave</i> <b>bgerror</b>
?<i>cmdPrefix</i>?</a></dt>

<dd>This command either gets or sets the current background error
handler for the <i>slave</i> interpreter. If <i>cmdPrefix</i> is
absent, the current background error handler is returned, and if it
is present, it is a list of words (of minimum length one) that
describes what to set the interpreter's background error to. See
the <b>BACKGROUND ERROR HANDLING</b> section for more details.</dd>

<dt><a name="M34"><i>slave</i> <b>eval</b> <i>arg</i> ?<i>arg
..</i>?</a></dt>

<dd>This command concatenates all of the <i>arg</i> arguments in
the same fashion as the <b><a href=
"../TclCmd/concat.htm">concat</a></b> command, then evaluates the
resulting string as a Tcl script in <i>slave</i>. The result of
this evaluation (including all <b><a href=
"../TclCmd/return.htm">return</a></b> options, such as
<b>-errorinfo</b> and <b>-errorcode</b> information, if an error
occurs) is returned to the invoking interpreter. Note that the
script will be executed in the current context stack frame of
<i>slave</i>; this is so that the implementations (in a master
interpreter) of aliases in a slave interpreter can execute scripts
in the slave that find out information about the slave's current
state and stack frame.</dd>

<dt><a name="M35"><i>slave</i> <b>expose</b> <i>hiddenName</i>
?<i>exposedCmdName</i>?</a></dt>

<dd>This command exposes the hidden command <i>hiddenName</i>,
eventually bringing it back under a new <i>exposedCmdName</i> name
(this name is currently accepted only if it is a valid global name
space name without any ::), in <i>slave</i>. If an exposed command
with the targeted name already exists, this command fails. For more
details on hidden commands, see <b>HIDDEN COMMANDS</b>, below.</dd>

<dt><a name="M36"><i>slave</i> <b>hide</b> <i>exposedCmdName</i>
?<i>hiddenCmdName</i>?</a></dt>

<dd>This command hides the exposed command <i>exposedCmdName</i>,
renaming it to the hidden command <i>hiddenCmdName</i>, or keeping
the same name if the argument is not given, in the <i>slave</i>
interpreter. If a hidden command with the targeted name already
exists, this command fails. Currently both <i>exposedCmdName</i>
and <i>hiddenCmdName</i> can not contain namespace qualifiers, or
an error is raised. Commands to be hidden are looked up in the
global namespace even if the current namespace is not the global
one. This prevents slaves from fooling a master interpreter into
hiding the wrong command, by making the current namespace be
different from the global one. For more details on hidden commands,
see <b>HIDDEN COMMANDS</b>, below.</dd>

<dt><a name="M37"><i>slave</i> <b>hidden</b></a></dt>

<dd>Returns a list of the names of all hidden commands in
<i>slave</i>.</dd>

<dt><a name="M38"><i>slave</i> <b>invokehidden</b> ?<i>-option
...</i>? <i>hiddenName</i> ?<i>arg ..</i>?</a></dt>

<dd>This command invokes the hidden command <i>hiddenName</i> with
the supplied arguments, in <i>slave</i>. No substitutions or
evaluations are applied to the arguments. Three <i>-option</i>s are
supported, all of which start with <b>-</b>: <b>-namespace</b>
(which takes a single argument afterwards, <i>nsName</i>),
<b>-global</b>, and <b>--</b>. If the <b>-namespace</b> flag is
given, the hidden command is invoked in the specified namespace in
the slave. If the <b>-global</b> flag is given, the command is
invoked at the global level in the slave; otherwise it is invoked
at the current call frame and can access local variables in that or
outer call frames. The <b>--</b> flag allows the
<i>hiddenCmdName</i> argument to start with a &ldquo;-&rdquo;
character, and is otherwise unnecessary. If both the
<b>-namespace</b> and <b>-global</b> flags are given, the
<b>-namespace</b> flag is ignored. Note that the hidden command
will be executed (by default) in the current context stack frame of
<i>slave</i>. For more details on hidden commands, see <b>HIDDEN
COMMANDS</b>, below.</dd>

<dt><a name="M39"><i>slave</i> <b>issafe</b></a></dt>

<dd>Returns <b>1</b> if the slave interpreter is safe, <b>0</b>
otherwise.</dd>

<dt><a name="M40"><i>slave</i> <b>limit</b> <i>limitType</i>
?<i>-option</i>? ?<i>value</i> <i>...</i>?</a></dt>

<dd>Sets up, manipulates and queries the configuration of the
resource limit <i>limitType</i> for the slave interpreter. If no
<i>-option</i> is specified, return the current configuration of
the limit. If <i>-option</i> is the sole argument, return the value
of that option. Otherwise, a list of <i>-option</i>/<i>value</i>
argument pairs must supplied. See <b>RESOURCE LIMITS</b> below for
a more detailed explanation of what limits and options are
supported.</dd>

<dt><a name="M41"><i>slave</i> <b>marktrusted</b></a></dt>

<dd>Marks the slave interpreter as trusted. Can only be invoked by
a trusted interpreter. This command does not expose any hidden
commands in the slave interpreter. The command has no effect if the
slave is already trusted.</dd>

<dt><a name="M42"><i>slave</i> <b>recursionlimit</b>
?<i>newlimit</i>?</a></dt>

<dd>Returns the maximum allowable nesting depth for the
<i>slave</i> interpreter. If <i>newlimit</i> is specified, the
recursion limit in <i>slave</i> will be set so that nesting of more
than <i>newlimit</i> calls to <b>Tcl_Eval()</b> and related
procedures in <i>slave</i> will return an error. The
<i>newlimit</i> value is also returned. The <i>newlimit</i> value
must be a positive integer between 1 and the maximum value of a
non-long integer on the platform. 

<p>The command sets the maximum size of the Tcl call stack only. It
cannot by itself prevent stack overflows on the C stack being used
by the application. If your machine has a limit on the size of the
C stack, you may get stack overflows before reaching the limit set
by the command. If this happens, see if there is a mechanism in
your system for increasing the maximum size of the C stack.</p>
</dd>
</dl>

<h3><a name="M43">SAFE INTERPRETERS</a></h3>

A safe interpreter is one with restricted functionality, so that is
safe to execute an arbitrary script from your worst enemy without
fear of that script damaging the enclosing application or the rest
of your computing environment. In order to make an interpreter
safe, certain commands and variables are removed from the
interpreter. For example, commands to create files on disk are
removed, and the <b><a href="../TclCmd/exec.htm">exec</a></b>
command is removed, since it could be used to cause damage through
subprocesses. Limited access to these facilities can be provided,
by creating aliases to the master interpreter which check their
arguments carefully and provide restricted access to a safe subset
of facilities. For example, file creation might be allowed in a
particular subdirectory and subprocess invocation might be allowed
for a carefully selected and fixed set of programs. 

<p>A safe interpreter is created by specifying the <b>-safe</b>
switch to the <b>interp create</b> command. Furthermore, any slave
created by a safe interpreter will also be safe.</p>

<p>A safe interpreter is created with exactly the following set of
built-in commands:</p>

<pre>
<b><a href="../TclCmd/after.htm">after</a></b> <b><a href=
"../TclCmd/append.htm">append</a></b>    <b><a href=
"../TclCmd/apply.htm">apply</a></b>  <b><a href=
"../TclCmd/array.htm">array</a></b>
<b><a href="../TclCmd/binary.htm">binary</a></b>    <b><a href=
"../TclCmd/break.htm">break</a></b>  <b><a href=
"../TclCmd/catch.htm">catch</a></b>  <b><a href=
"../TclCmd/chan.htm">chan</a></b>
<b><a href="../TclCmd/clock.htm">clock</a></b>  <b><a href=
"../TclCmd/close.htm">close</a></b>  <b><a href=
"../TclCmd/concat.htm">concat</a></b>    <b><a href=
"../TclCmd/continue.htm">continue</a></b>
<b><a href="../TclCmd/dict.htm">dict</a></b>    <b><a href=
"../TclCmd/eof.htm">eof</a></b>  <b><a href=
"../TclCmd/error.htm">error</a></b>  <b><a href=
"../TclCmd/eval.htm">eval</a></b>
<b><a href="../TclCmd/expr.htm">expr</a></b>    <b><a href=
"../TclCmd/fblocked.htm">fblocked</a></b>    <b><a href=
"../TclCmd/fcopy.htm">fcopy</a></b>  <b><a href=
"../TclCmd/fileevent.htm">fileevent</a></b>
<b><a href="../TclCmd/flush.htm">flush</a></b>  <b><a href=
"../TclCmd/for.htm">for</a></b>  <b><a href=
"../TclCmd/foreach.htm">foreach</a></b>  <b><a href=
"../TclCmd/format.htm">format</a></b>
<b><a href="../TclCmd/gets.htm">gets</a></b>    <b><a href=
"../TclCmd/global.htm">global</a></b>    <b><a href=
"../TclCmd/if.htm">if</a></b>    <b><a href=
"../TclCmd/incr.htm">incr</a></b>
<b><a href=
"../TclCmd/info.htm">info</a></b>    <b>interp</b>   <b><a href=
"../TclCmd/join.htm">join</a></b>    <b><a href=
"../TclCmd/lappend.htm">lappend</a></b>
<b><a href="../TclCmd/lassign.htm">lassign</a></b>  <b><a href=
"../TclCmd/lindex.htm">lindex</a></b>    <b><a href=
"../TclCmd/linsert.htm">linsert</a></b>  <b><a href=
"../TclCmd/list.htm">list</a></b>
<b><a href="../TclCmd/llength.htm">llength</a></b>  <b><a href=
"../TclCmd/lrange.htm">lrange</a></b>    <b><a href=
"../TclCmd/lrepeat.htm">lrepeat</a></b>  <b><a href=
"../TclCmd/lreplace.htm">lreplace</a></b>
<b><a href="../TclCmd/lsearch.htm">lsearch</a></b>  <b><a href=
"../TclCmd/lset.htm">lset</a></b>    <b><a href=
"../TclCmd/lsort.htm">lsort</a></b>  <b><a href=
"../TclCmd/namespace.htm">namespace</a></b>
<b><a href="../TclCmd/package.htm">package</a></b>  <b><a href=
"../TclCmd/pid.htm">pid</a></b>  <b><a href=
"../TclCmd/proc.htm">proc</a></b>    <b><a href=
"../TclCmd/puts.htm">puts</a></b>
<b><a href="../TclCmd/read.htm">read</a></b>    <b><a href=
"../TclCmd/regexp.htm">regexp</a></b>    <b><a href=
"../TclCmd/regsub.htm">regsub</a></b>    <b><a href=
"../TclCmd/rename.htm">rename</a></b>
<b><a href="../TclCmd/return.htm">return</a></b>    <b><a href=
"../TclCmd/scan.htm">scan</a></b>    <b><a href=
"../TclCmd/seek.htm">seek</a></b>    <b><a href=
"../TclCmd/set.htm">set</a></b>
<b><a href="../TclCmd/split.htm">split</a></b>  <b><a href=
"../TclCmd/string.htm">string</a></b>    <b><a href=
"../TclCmd/subst.htm">subst</a></b>  <b><a href=
"../TclCmd/switch.htm">switch</a></b>
<b><a href="../TclCmd/tell.htm">tell</a></b>    <b><a href=
"../TclCmd/time.htm">time</a></b>    <b><a href=
"../TclCmd/trace.htm">trace</a></b>  <b><a href=
"../TclCmd/unset.htm">unset</a></b>
<b><a href="../TclCmd/update.htm">update</a></b>    <b><a href=
"../TclCmd/uplevel.htm">uplevel</a></b>  <b><a href=
"../TclCmd/upvar.htm">upvar</a></b>  <b><a href=
"../TclCmd/variable.htm">variable</a></b>
<b><a href="../TclCmd/vwait.htm">vwait</a></b>  <b><a href=
"../TclCmd/while.htm">while</a></b>
</pre>

The following commands are hidden by <b>interp create</b> when it
creates a safe interpreter: 

<pre>
<b><a href="../TclCmd/cd.htm">cd</a></b>   <b><a href=
"../TclCmd/encoding.htm">encoding</a></b>    <b><a href=
"../TclCmd/exec.htm">exec</a></b>    <b><a href=
"../TclCmd/exit.htm">exit</a></b>
<b><a href="../TclCmd/fconfigure.htm">fconfigure</a></b>    <b><a
href="../TclCmd/file.htm">file</a></b>    <b><a href=
"../TclCmd/glob.htm">glob</a></b>    <b><a href=
"../TclCmd/load.htm">load</a></b>
<b><a href="../TclCmd/open.htm">open</a></b>    <b><a href=
"../TclCmd/pwd.htm">pwd</a></b>  <b><a href=
"../TclCmd/socket.htm">socket</a></b>    <b><a href=
"../TclCmd/source.htm">source</a></b>
<b><a href="../TclCmd/unload.htm">unload</a></b>
</pre>

These commands can be recreated later as Tcl procedures or aliases,
or re-exposed by <b>interp expose</b>. 

<p>The following commands from Tcl's library of support procedures
are not present in a safe interpreter:</p>

<pre>
<b>auto_exec_ok</b>    <b><a href=
"../TclCmd/library.htm">auto_import</a></b>  <b><a href=
"../TclCmd/library.htm">auto_load</a></b>
<b>auto_load_index</b>  <b><a href=
"../TclCmd/library.htm">auto_qualify</a></b> <b><a href=
"../TclCmd/unknown.htm">unknown</a></b>
</pre>

Note in particular that safe interpreters have no default <b><a
href="../TclCmd/unknown.htm">unknown</a></b> command, so Tcl's
default autoloading facilities are not available. Autoload access
to Tcl's commands that are normally autoloaded: 

<pre>
<b><a href="../TclCmd/library.htm">auto_mkindex</a></b>    <b><a
href="../TclCmd/library.htm">auto_mkindex_old</a></b>
<b><a href="../TclCmd/library.htm">auto_reset</a></b>   <b><a href=
"../TclCmd/history.htm">history</a></b>
<b><a href=
"../TclCmd/library.htm">parray</a></b>   <b>pkg_mkIndex</b>
<b>::pkg::create</b>    <b>::safe::interpAddToAccessPath</b>
<b>::safe::interpCreate</b> <b>::safe::interpConfigure</b>
<b>::safe::interpDelete</b> <b>::safe::interpFindInAccessPath</b>
<b>::safe::interpInit</b>   <b>::safe::setLogCmd</b>
<b>tcl_endOfWord</b>    <b>tcl_findLibrary</b>
<b>tcl_startOfNextWord</b>  <b>tcl_startOfPreviousWord</b>
<b>tcl_wordBreakAfter</b>   <b>tcl_wordBreakBefore</b>
</pre>

can only be provided by explicit definition of an <b><a href=
"../TclCmd/unknown.htm">unknown</a></b> command in the safe
interpreter. This will involve exposing the <b><a href=
"../TclCmd/source.htm">source</a></b> command. This is most easily
accomplished by creating the safe interpreter with Tcl's
<b>Safe-Tcl</b> mechanism. <b>Safe-Tcl</b> provides safe versions
of <b><a href="../TclCmd/source.htm">source</a></b>, <b><a href=
"../TclCmd/load.htm">load</a></b>, and other Tcl commands needed to
support autoloading of commands and the loading of packages. 

<p>In addition, the <b>env</b> variable is not present in a safe
interpreter, so it cannot share environment variables with other
interpreters. The <b>env</b> variable poses a security risk,
because users can store sensitive information in an environment
variable. For example, the PGP manual recommends storing the PGP
private key protection password in the environment variable
<i>PGPPASS</i>. Making this variable available to untrusted code
executing in a safe interpreter would incur a security risk.</p>

<p>If extensions are loaded into a safe interpreter, they may also
restrict their own functionality to eliminate unsafe commands. For
a discussion of management of extensions for safety see the manual
entries for <b>Safe-Tcl</b> and the <b><a href=
"../TclCmd/load.htm">load</a></b> Tcl command.</p>

<p>A safe interpreter may not alter the recursion limit of any
interpreter, including itself.</p>

<h3><a name="M44">ALIAS INVOCATION</a></h3>

The alias mechanism has been carefully designed so that it can be
used safely when an untrusted script is executing in a safe slave
and the target of the alias is a trusted master. The most important
thing in guaranteeing safety is to ensure that information passed
from the slave to the master is never evaluated or substituted in
the master; if this were to occur, it would enable an evil script
in the slave to invoke arbitrary functions in the master, which
would compromise security. 

<p>When the source for an alias is invoked in the slave
interpreter, the usual Tcl substitutions are performed when parsing
that command. These substitutions are carried out in the source
interpreter just as they would be for any other command invoked in
that interpreter. The command procedure for the source command
takes its arguments and merges them with the <i>targetCmd</i> and
<i>arg</i>s for the alias to create a new array of arguments. If
the words of <i>srcCmd</i> were &ldquo;<i>srcCmd arg1 arg2 ...
argN</i>&rdquo;, the new set of words will be &ldquo;<i>targetCmd
arg arg ... arg arg1 arg2 ... argN</i>&rdquo;, where
<i>targetCmd</i> and <i>arg</i>s are the values supplied when the
alias was created. <i>TargetCmd</i> is then used to locate a
command procedure in the target interpreter, and that command
procedure is invoked with the new set of arguments. An error occurs
if there is no command named <i>targetCmd</i> in the target
interpreter. No additional substitutions are performed on the
words: the target command procedure is invoked directly, without
going through the normal Tcl evaluation mechanism. Substitutions
are thus performed on each word exactly once: <i>targetCmd</i> and
<i>args</i> were substituted when parsing the command that created
the alias, and <i>arg1 - argN</i> are substituted when the alias's
source command is parsed in the source interpreter.</p>

<p>When writing the <i>targetCmd</i>s for aliases in safe
interpreters, it is very important that the arguments to that
command never be evaluated or substituted, since this would provide
an escape mechanism whereby the slave interpreter could execute
arbitrary code in the master. This in turn would compromise the
security of the system.</p>

<h3><a name="M45">HIDDEN COMMANDS</a></h3>

Safe interpreters greatly restrict the functionality available to
Tcl programs executing within them. Allowing the untrusted Tcl
program to have direct access to this functionality is unsafe,
because it can be used for a variety of attacks on the environment.
However, there are times when there is a legitimate need to use the
dangerous functionality in the context of the safe interpreter. For
example, sometimes a program must be <b><a href=
"../TclCmd/source.htm">source</a></b>d into the interpreter.
Another example is Tk, where windows are bound to the hierarchy of
windows for a specific interpreter; some potentially dangerous
functions, e.g. window management, must be performed on these
windows within the interpreter context. 

<p>The <b>interp</b> command provides a solution to this problem in
the form of <i>hidden commands</i>. Instead of removing the
dangerous commands entirely from a safe interpreter, these commands
are hidden so they become unavailable to Tcl scripts executing in
the interpreter. However, such hidden commands can be invoked by
any trusted ancestor of the safe interpreter, in the context of the
safe interpreter, using <b>interp invoke</b>. Hidden commands and
exposed commands reside in separate name spaces. It is possible to
define a hidden command and an exposed command by the same name
within one interpreter.</p>

<p>Hidden commands in a slave interpreter can be invoked in the
body of procedures called in the master during alias invocation.
For example, an alias for <b><a href=
"../TclCmd/source.htm">source</a></b> could be created in a slave
interpreter. When it is invoked in the slave interpreter, a
procedure is called in the master interpreter to check that the
operation is allowable (e.g. it asks to source a file that the
slave interpreter is allowed to access). The procedure then it
invokes the hidden <b><a href="../TclCmd/source.htm">source</a></b>
command in the slave interpreter to actually source in the contents
of the file. Note that two commands named <b><a href=
"../TclCmd/source.htm">source</a></b> exist in the slave
interpreter: the alias, and the hidden command.</p>

<p>Because a master interpreter may invoke a hidden command as part
of handling an alias invocation, great care must be taken to avoid
evaluating any arguments passed in through the alias invocation.
Otherwise, malicious slave interpreters could cause a trusted
master interpreter to execute dangerous commands on their behalf.
See the section on <b>ALIAS INVOCATION</b> for a more complete
discussion of this topic. To help avoid this problem, no
substitutions or evaluations are applied to arguments of <b>interp
invokehidden</b>.</p>

<p>Safe interpreters are not allowed to invoke hidden commands in
themselves or in their descendants. This prevents safe slaves from
gaining access to hidden functionality in themselves or their
descendants.</p>

<p>The set of hidden commands in an interpreter can be manipulated
by a trusted interpreter using <b>interp expose</b> and <b>interp
hide</b>. The <b>interp expose</b> command moves a hidden command
to the set of exposed commands in the interpreter identified by
<i>path</i>, potentially renaming the command in the process. If an
exposed command by the targeted name already exists, the operation
fails. Similarly, <b>interp hide</b> moves an exposed command to
the set of hidden commands in that interpreter. Safe interpreters
are not allowed to move commands between the set of hidden and
exposed commands, in either themselves or their descendants.</p>

<p>Currently, the names of hidden commands cannot contain namespace
qualifiers, and you must first rename a command in a namespace to
the global namespace before you can hide it. Commands to be hidden
by <b>interp hide</b> are looked up in the global namespace even if
the current namespace is not the global one. This prevents slaves
from fooling a master interpreter into hiding the wrong command, by
making the current namespace be different from the global one.</p>

<h3><a name="M46">RESOURCE LIMITS</a></h3>

Every interpreter has two kinds of resource limits that may be
imposed by any master interpreter upon its slaves. Command limits
(of type <b>command</b>) restrict the total number of Tcl commands
that may be executed by an interpreter (as can be inspected via the
<b><a href="../TclCmd/info.htm">info cmdcount</a></b> command), and
time limits (of type <b><a href="../TclCmd/time.htm">time</a></b>)
place a limit by which execution within the interpreter must
complete. Note that time limits are expressed as <i>absolute</i>
times (as in <b>clock seconds</b>) and not relative times (as in
<b><a href="../TclCmd/after.htm">after</a></b>) because they may be
modified after creation. 

<p>When a limit is exceeded for an interpreter, first any handler
callbacks defined by master interpreters are called. If those
callbacks increase or remove the limit, execution within the
(previously) limited interpreter continues. If the limit is still
in force, an error is generated at that point and normal processing
of errors within the interpreter (by the <b><a href=
"../TclCmd/catch.htm">catch</a></b> command) is disabled, so the
error propagates outwards (building a stack-trace as it goes) to
the point where the limited interpreter was invoked (e.g. by
<b>interp eval</b>) where it becomes the responsibility of the
calling code to catch and handle.</p>

<h4><a name="M47">LIMIT OPTIONS</a></h4>

Every limit has a number of options associated with it, some of
which are common across all kinds of limits, and others of which
are particular to the kind of limit. 

<dl class="limit options">
<dt><a name="M48"><b>-command</b></a></dt>

<dd>This option (common for all limit types) specifies (if
non-empty) a Tcl script to be executed in the global namespace of
the interpreter reading and writing the option when the particular
limit in the limited interpreter is exceeded. The callback may
modify the limit on the interpreter if it wishes the limited
interpreter to continue executing. If the callback generates an
error, it is reported through the background error mechanism (see
<b>BACKGROUND ERROR HANDLING</b>). Note that the callbacks defined
by one interpreter are completely isolated from the callbacks
defined by another, and that the order in which those callbacks are
called is undefined.</dd>

<dt><a name="M49"><b>-granularity</b></a></dt>

<dd>This option (common for all limit types) specifies how
frequently (out of the points when the Tcl interpreter is in a
consistent state where limit checking is possible) that the limit
is actually checked. This allows the tuning of how frequently a
limit is checked, and hence how often the limit-checking overhead
(which may be substantial in the case of time limits) is
incurred.</dd>

<dt><a name="M50"><b>-milliseconds</b></a></dt>

<dd>This option specifies the number of milliseconds after the
moment defined in the <b>-seconds</b> option that the time limit
will fire. It should only ever be specified in conjunction with the
<b>-seconds</b> option (whether it was set previously or is being
set this invocation.)</dd>

<dt><a name="M51"><b>-seconds</b></a></dt>

<dd>This option specifies the number of seconds after the epoch
(see <b>clock seconds</b>) that the time limit for the interpreter
will be triggered. The limit will be triggered at the start of the
second unless specified at a sub-second level using the
<b>-milliseconds</b> option. This option may be the empty string,
which indicates that a time limit is not set for the
interpreter.</dd>

<dt><a name="M52"><b>-value</b></a></dt>

<dd>This option specifies the number of commands that the
interpreter may execute before triggering the command limit. This
option may be the empty string, which indicates that a command
limit is not set for the interpreter.</dd>
</dl>

<p>Where an interpreter with a resource limit set on it creates a
slave interpreter, that slave interpreter will have resource limits
imposed on it that are at least as restrictive as the limits on the
creating master interpreter. If the master interpreter of the
limited master wishes to relax these conditions, it should hide the
<b>interp</b> command in the child and then use aliases and the
<b>interp invokehidden</b> subcommand to provide such access as it
chooses to the <b>interp</b> command to the limited master as
necessary.</p>

<h3><a name="M53">BACKGROUND ERROR HANDLING</a></h3>

When an error happens in a situation where it cannot be reported
directly up the stack (e.g. when processing events in an <b><a
href="../TclCmd/update.htm">update</a></b> or <b><a href=
"../TclCmd/vwait.htm">vwait</a></b> call) the error is instead
reported through the background error handling mechanism. Every
interpreter has a background error handler registered; the default
error handler arranges for the <b><a href=
"../TclCmd/bgerror.htm">bgerror</a></b> command in the
interpreter's global namespace to be called, but other error
handlers may be installed and process background errors in
substantially different ways. 

<p>A background error handler consists of a non-empty list of words
to which will be appended two further words at invocation time. The
first word will be the error message string, and the second will a
dictionary of return options (this is also the sort of information
that can be obtained by trapping a normal error using <b><a href=
"../TclCmd/catch.htm">catch</a></b> of course.) The resulting list
will then be executed in the interpreter's global namespace without
further substitutions being performed.</p>

<h3><a name="M54">CREDITS</a></h3>

The safe interpreter mechanism is based on the Safe-Tcl prototype
implemented by Nathaniel Borenstein and Marshall Rose. 

<h3><a name="M55">EXAMPLES</a></h3>

Creating and using an alias for a command in the current
interpreter: 

<pre>
<b>interp alias</b> {} getIndex {} lsearch {alpha beta gamma delta}
set idx [getIndex delta]
</pre>

<p>Executing an arbitrary command in a safe interpreter where every
invocation of <b><a href="../TclCmd/lappend.htm">lappend</a></b> is
logged:</p>

<pre>
set i [<b>interp create</b> -safe]
<b>interp hide</b> $i lappend
<b>interp alias</b> $i lappend {} loggedLappend $i
proc loggedLappend {i args} {
   puts "logged invocation of lappend $args"
   <b>interp invokehidden</b> $i lappend {*}$args
}
<b>interp eval</b> $i $someUntrustedScript
</pre>

<p>Setting a resource limit on an interpreter so that an infinite
loop terminates.</p>

<pre>
set i [<b>interp create</b>]
<b>interp limit</b> $i command -value 1000
<b>interp eval</b> $i {
   set x 0
   while {1} {
      puts "Counting up... [incr x]"
   }
}
</pre>

<h3><a name="M56">SEE ALSO</a></h3>

<b><a href="../TclCmd/bgerror.htm">bgerror</a></b>, <b><a href=
"../TclCmd/load.htm">load</a></b>, <b>safe</b>, <b><a href=
"../TclLib/CrtSlave.htm">Tcl_CreateSlave</a></b> 

<h3><a name="M57">KEYWORDS</a></h3>

<a href="../Keywords/A.htm#alias">alias</a>, <a href=
"../Keywords/M.htm#master interpreter">master interpreter</a>, <a
href="../Keywords/S.htm#safe interpreter">safe interpreter</a>, <a
href="../Keywords/S.htm#slave interpreter">slave interpreter</a> 

<div class="copy">Copyright &copy; 1995-1997 Roger E. Critchlow Jr.
Copyright &copy; 1995-1996 Sun Microsystems, Inc. Copyright &copy;
2004 Donal K. Fellows</div>
</body>
</html>

