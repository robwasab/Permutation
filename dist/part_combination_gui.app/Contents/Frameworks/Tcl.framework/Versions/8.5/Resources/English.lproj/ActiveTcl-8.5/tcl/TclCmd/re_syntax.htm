<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<meta name="generator" content="HTML Tidy, see www.w3.org">
<meta name='Author' content='ActiveState'>
<link rel='stylesheet' type='text/css' href='../../aspn.css'>
<title>Tcl Built-In Commands - re_syntax manual page</title>
<link rel="stylesheet" href="../docs.css" type="text/css" media=
"all">
</head>
<body>
<div class="banner">
<table width="100%" border="0" cellspacing="0" cellpadding="3">
<tr>
<td align="left"><a target="_blank" href=
"http://www.activestate.com/activetcl"><img src=
"../../images/ActiveTcl.gif" border="0" align="left" alt=
"ActiveTcl"></a> </td>
<td align="center" class="heading">ActiveTcl User Guide</td>
<td align="right"><a target="_blank" href=
"http://www.activestate.com"><img src="../../images/AS_logo.gif"
border="0" align="right" alt="ActiveState Software Inc."></a> </td>
</tr>
</table>
</div>

<br>
<h2><a href="../contents.htm">Tcl/Tk Documentation</a>
<small>&gt;</small> <a href="contents.htm">TclCmd</a>
<small>&gt;</small> re_syntax</h2>

<h3><a href="../UserCmd/contents.htm">Tcl/Tk Applications</a> | <a
href="../TclCmd/contents.htm">Tcl Commands</a> | <a href=
"../TkCmd/contents.htm">Tk Commands</a> | <a href=
"../TclLib/contents.htm">Tcl Library</a> | <a href=
"../TkLib/contents.htm">Tk Library</a></h3>

<dl>
<dd><a href="re_syntax.htm#M2" name="L1229">NAME</a> 

<dl>
<dd>re_syntax - Syntax of Tcl regular expressions</dd>
</dl>
</dd>

<dd><a href="re_syntax.htm#M3" name="L1230">DESCRIPTION</a></dd>

<dd><a href="re_syntax.htm#M4" name="L1231">DIFFERENT FLAVORS OF
REs</a></dd>

<dd><a href="re_syntax.htm#M5" name="L1232">REGULAR EXPRESSION
SYNTAX</a></dd>

<dd><a href="re_syntax.htm#M6" name="L1233">QUANTIFIERS</a> 

<dl class="quantifiers">
<dd><a href="re_syntax.htm#M7" name="L1234"><b>*</b></a></dd>

<dd><a href="re_syntax.htm#M8" name="L1235"><b>+</b></a></dd>

<dd><a href="re_syntax.htm#M9" name="L1236"><b>?</b></a></dd>

<dd><a href="re_syntax.htm#M10" name=
"L1237"><b>{</b><i>m</i><b>}</b></a></dd>

<dd><a href="re_syntax.htm#M11" name=
"L1238"><b>{</b><i>m</i><b>,}</b></a></dd>

<dd><a href="re_syntax.htm#M12" name=
"L1239"><b>{</b><i>m</i><b>,</b><i>n</i><b>}</b></a></dd>

<dd><a href="re_syntax.htm#M13" name="L1240"><b>*? +? ??
{</b><i>m</i><b>}? {</b><i>m</i><b>,}?
{</b><i>m</i><b>,</b><i>n</i><b>}?</b></a></dd>
</dl>
</dd>

<dd><a href="re_syntax.htm#M14" name="L1241">ATOMS</a> 

<dl class="atoms">
<dd><a href="re_syntax.htm#M15" name=
"L1242"><b>(</b><i>re</i><b>)</b></a></dd>

<dd><a href="re_syntax.htm#M16" name=
"L1243"><b>(?:</b><i>re</i><b>)</b></a></dd>

<dd><a href="re_syntax.htm#M17" name="L1244"><b>()</b></a></dd>

<dd><a href="re_syntax.htm#M18" name="L1245"><b>(?:)</b></a></dd>

<dd><a href="re_syntax.htm#M19" name=
"L1246"><b>[</b><i>chars</i><b>]</b></a></dd>

<dd><a href="re_syntax.htm#M20" name="L1247"><b>.</b></a></dd>

<dd><a href="re_syntax.htm#M21" name=
"L1248"><b>\</b><i>k</i></a></dd>

<dd><a href="re_syntax.htm#M22" name=
"L1249"><b>\</b><i>c</i></a></dd>

<dd><a href="re_syntax.htm#M23" name="L1250"><b>{</b></a></dd>

<dd><a href="re_syntax.htm#M24" name="L1251"><i>x</i></a></dd>
</dl>
</dd>

<dd><a href="re_syntax.htm#M25" name="L1252">CONSTRAINTS</a> 

<dl class="constraints">
<dd><a href="re_syntax.htm#M26" name="L1253"><b>^</b></a></dd>

<dd><a href="re_syntax.htm#M27" name="L1254"><b>$</b></a></dd>

<dd><a href="re_syntax.htm#M28" name=
"L1255"><b>(?=</b><i>re</i><b>)</b></a></dd>

<dd><a href="re_syntax.htm#M29" name=
"L1256"><b>(?!</b><i>re</i><b>)</b></a></dd>
</dl>
</dd>

<dd><a href="re_syntax.htm#M30" name="L1257">BRACKET
EXPRESSIONS</a></dd>

<dd><a href="re_syntax.htm#M31" name="L1258">CHARACTER CLASSES</a> 

<dl class="character classes">
<dd><a href="re_syntax.htm#M32" name="L1259"><b>alpha</b></a></dd>

<dd><a href="re_syntax.htm#M33" name="L1260"><b>upper</b></a></dd>

<dd><a href="re_syntax.htm#M34" name="L1261"><b>lower</b></a></dd>

<dd><a href="re_syntax.htm#M35" name="L1262"><b>digit</b></a></dd>

<dd><a href="re_syntax.htm#M36" name="L1263"><b>xdigit</b></a></dd>

<dd><a href="re_syntax.htm#M37" name="L1264"><b>alnum</b></a></dd>

<dd><a href="re_syntax.htm#M38" name="L1265"><b>print</b></a></dd>

<dd><a href="re_syntax.htm#M39" name="L1266"><b>blank</b></a></dd>

<dd><a href="re_syntax.htm#M40" name="L1267"><b>space</b></a></dd>

<dd><a href="re_syntax.htm#M41" name="L1268"><b>punct</b></a></dd>

<dd><a href="re_syntax.htm#M42" name="L1269"><b>graph</b></a></dd>

<dd><a href="re_syntax.htm#M43" name="L1270"><b>cntrl</b></a></dd>
</dl>
</dd>

<dd><a href="re_syntax.htm#M44" name="L1271">BRACKETED
CONSTRAINTS</a></dd>

<dd><a href="re_syntax.htm#M45" name="L1272">COLLATING
ELEMENTS</a></dd>

<dd><a href="re_syntax.htm#M46" name="L1273">EQUIVALENCE
CLASSES</a></dd>

<dd><a href="re_syntax.htm#M47" name="L1274">ESCAPES</a></dd>

<dd><a href="re_syntax.htm#M48" name="L1275">CHARACTER-ENTRY
ESCAPES</a> 

<dl class="character-entry escapes">
<dd><a href="re_syntax.htm#M49" name="L1276"><b>\a</b></a></dd>

<dd><a href="re_syntax.htm#M50" name="L1277"><b>\b</b></a></dd>

<dd><a href="re_syntax.htm#M51" name="L1278"><b>\B</b></a></dd>

<dd><a href="re_syntax.htm#M52" name=
"L1279"><b>\c</b><i>X</i></a></dd>

<dd><a href="re_syntax.htm#M53" name="L1280"><b>\e</b></a></dd>

<dd><a href="re_syntax.htm#M54" name="L1281"><b>\f</b></a></dd>

<dd><a href="re_syntax.htm#M55" name="L1282"><b>\n</b></a></dd>

<dd><a href="re_syntax.htm#M56" name="L1283"><b>\r</b></a></dd>

<dd><a href="re_syntax.htm#M57" name="L1284"><b>\t</b></a></dd>

<dd><a href="re_syntax.htm#M58" name=
"L1285"><b>\u</b><i>wxyz</i></a></dd>

<dd><a href="re_syntax.htm#M59" name=
"L1286"><b>\U</b><i>stuvwxyz</i></a></dd>

<dd><a href="re_syntax.htm#M60" name="L1287"><b>\v</b></a></dd>

<dd><a href="re_syntax.htm#M61" name=
"L1288"><b>\x</b><i>hhh</i></a></dd>

<dd><a href="re_syntax.htm#M62" name="L1289"><b>\0</b></a></dd>

<dd><a href="re_syntax.htm#M63" name=
"L1290"><b>\</b><i>xy</i></a></dd>

<dd><a href="re_syntax.htm#M64" name=
"L1291"><b>\</b><i>xyz</i></a></dd>
</dl>
</dd>

<dd><a href="re_syntax.htm#M65" name="L1292">CLASS-SHORTHAND
ESCAPES</a> 

<dl class="class-shorthand escapes">
<dd><a href="re_syntax.htm#M66" name="L1293"><b>\d</b></a></dd>

<dd><a href="re_syntax.htm#M67" name="L1294"><b>\s</b></a></dd>

<dd><a href="re_syntax.htm#M68" name="L1295"><b>\w</b></a></dd>

<dd><a href="re_syntax.htm#M69" name="L1296"><b>\D</b></a></dd>

<dd><a href="re_syntax.htm#M70" name="L1297"><b>\S</b></a></dd>

<dd><a href="re_syntax.htm#M71" name="L1298"><b>\W</b></a></dd>
</dl>
</dd>

<dd><a href="re_syntax.htm#M72" name="L1299">CONSTRAINT ESCAPES</a>


<dl class="constraint escapes">
<dd><a href="re_syntax.htm#M73" name="L1300"><b>\A</b></a></dd>

<dd><a href="re_syntax.htm#M74" name="L1301"><b>\m</b></a></dd>

<dd><a href="re_syntax.htm#M75" name="L1302"><b>\M</b></a></dd>

<dd><a href="re_syntax.htm#M76" name="L1303"><b>\y</b></a></dd>

<dd><a href="re_syntax.htm#M77" name="L1304"><b>\Y</b></a></dd>

<dd><a href="re_syntax.htm#M78" name="L1305"><b>\Z</b></a></dd>

<dd><a href="re_syntax.htm#M79" name=
"L1306"><b>\</b><i>m</i></a></dd>

<dd><a href="re_syntax.htm#M80" name=
"L1307"><b>\</b><i>mnn</i></a></dd>
</dl>
</dd>

<dd><a href="re_syntax.htm#M81" name="L1308">BACK
REFERENCES</a></dd>

<dd><a href="re_syntax.htm#M82" name="L1309">METASYNTAX</a> 

<dl class="metasyntax">
<dd><a href="re_syntax.htm#M83" name="L1310"><b>b</b></a></dd>

<dd><a href="re_syntax.htm#M84" name="L1311"><b>c</b></a></dd>

<dd><a href="re_syntax.htm#M85" name="L1312"><b>e</b></a></dd>

<dd><a href="re_syntax.htm#M86" name="L1313"><b>i</b></a></dd>

<dd><a href="re_syntax.htm#M87" name="L1314"><b>m</b></a></dd>

<dd><a href="re_syntax.htm#M88" name="L1315"><b>n</b></a></dd>

<dd><a href="re_syntax.htm#M89" name="L1316"><b>p</b></a></dd>

<dd><a href="re_syntax.htm#M90" name="L1317"><b>q</b></a></dd>

<dd><a href="re_syntax.htm#M91" name="L1318"><b>s</b></a></dd>

<dd><a href="re_syntax.htm#M92" name="L1319"><b>t</b></a></dd>

<dd><a href="re_syntax.htm#M93" name="L1320"><b>w</b></a></dd>

<dd><a href="re_syntax.htm#M94" name="L1321"><b>x</b></a></dd>
</dl>
</dd>

<dd><a href="re_syntax.htm#M95" name="L1322">MATCHING</a></dd>

<dd><a href="re_syntax.htm#M96" name="L1323">LIMITS AND
COMPATIBILITY</a></dd>

<dd><a href="re_syntax.htm#M97" name="L1324">BASIC REGULAR
EXPRESSIONS</a></dd>

<dd><a href="re_syntax.htm#M98" name="L1325">SEE ALSO</a></dd>

<dd><a href="re_syntax.htm#M99" name="L1326">KEYWORDS</a></dd>
</dl>

<h3><a name="M2">NAME</a></h3>

re_syntax - Syntax of Tcl regular expressions 

<h3><a name="M3">DESCRIPTION</a></h3>

A <i>regular expression</i> describes strings of characters. It's a
pattern that matches certain strings and does not match others. 

<h3><a name="M4">DIFFERENT FLAVORS OF REs</a></h3>

Regular expressions (&ldquo;RE&rdquo;s), as defined by POSIX, come
in two flavors: <i>extended</i> REs (&ldquo;ERE&rdquo;s) and
<i>basic</i> REs (&ldquo;BRE&rdquo;s). EREs are roughly those of
the traditional <i>egrep</i>, while BREs are roughly those of the
traditional <i>ed</i>. This implementation adds a third flavor,
<i>advanced</i> REs (&ldquo;ARE&rdquo;s), basically EREs with some
significant extensions. 

<p>This manual page primarily describes AREs. BREs mostly exist for
backward compatibility in some old programs; they will be discussed
at the end. POSIX EREs are almost an exact subset of AREs. Features
of AREs that are not present in EREs will be indicated.</p>

<h3><a name="M5">REGULAR EXPRESSION SYNTAX</a></h3>

Tcl regular expressions are implemented using the package written
by Henry Spencer, based on the 1003.2 spec and some (not quite all)
of the Perl5 extensions (thanks, Henry!). Much of the description
of regular expressions below is copied verbatim from his manual
entry. 

<p>An ARE is one or more <i>branches</i>, separated by
&ldquo;<b>|</b>&rdquo;, matching anything that matches any of the
branches.</p>

<p>A branch is zero or more <i>constraints</i> or <i>quantified
atoms</i>, concatenated. It matches a match for the first, followed
by a match for the second, etc; an empty branch matches the empty
string.</p>

<h4><a name="M6">QUANTIFIERS</a></h4>

A quantified atom is an <i>atom</i> possibly followed by a single
<i>quantifier</i>. Without a quantifier, it matches a single match
for the atom. The quantifiers, and what a so-quantified atom
matches, are: 

<dl class="quantifiers">
<dt><a name="M7"><b>*</b></a></dt>

<dd>a sequence of 0 or more matches of the atom</dd>

<dt><a name="M8"><b>+</b></a></dt>

<dd>a sequence of 1 or more matches of the atom</dd>

<dt><a name="M9"><b>?</b></a></dt>

<dd>a sequence of 0 or 1 matches of the atom</dd>

<dt><a name="M10"><b>{</b><i>m</i><b>}</b></a></dt>

<dd>a sequence of exactly <i>m</i> matches of the atom</dd>

<dt><a name="M11"><b>{</b><i>m</i><b>,}</b></a></dt>

<dd>a sequence of <i>m</i> or more matches of the atom</dd>

<dt><a name="M12"><b>{</b><i>m</i><b>,</b><i>n</i><b>}</b></a></dt>

<dd>a sequence of <i>m</i> through <i>n</i> (inclusive) matches of
the atom; <i>m</i> may not exceed <i>n</i></dd>

<dt><a name="M13"><b>*? +? ?? {</b><i>m</i><b>}?
{</b><i>m</i><b>,}? {</b><i>m</i><b>,</b><i>n</i><b>}?</b></a></dt>

<dd><i>non-greedy</i> quantifiers, which match the same
possibilities, but prefer the smallest number rather than the
largest number of matches (see <b>MATCHING</b>)</dd>
</dl>

<p>The forms using <b>{</b> and <b>}</b> are known as
<i>bound</i>s. The numbers <i>m</i> and <i>n</i> are unsigned
decimal integers with permissible values from 0 to 255
inclusive.</p>

<h4><a name="M14">ATOMS</a></h4>

An atom is one of: 

<dl class="atoms">
<dt><a name="M15"><b>(</b><i>re</i><b>)</b></a></dt>

<dd>matches a match for <i>re</i> (<i>re</i> is any regular
expression) with the match noted for possible reporting</dd>

<dt><a name="M16"><b>(?:</b><i>re</i><b>)</b></a></dt>

<dd>as previous, but does no reporting (a
&ldquo;non-capturing&rdquo; set of parentheses)</dd>

<dt><a name="M17"><b>()</b></a></dt>

<dd>matches an empty string, noted for possible reporting</dd>

<dt><a name="M18"><b>(?:)</b></a></dt>

<dd>matches an empty string, without reporting</dd>

<dt><a name="M19"><b>[</b><i>chars</i><b>]</b></a></dt>

<dd>a <i>bracket expression</i>, matching any one of the
<i>chars</i> (see <b>BRACKET EXPRESSIONS</b> for more detail)</dd>

<dt><a name="M20"><b>.</b></a></dt>

<dd>matches any single character</dd>

<dt><a name="M21"><b>\</b><i>k</i></a></dt>

<dd>matches the non-alphanumeric character <i>k</i> taken as an
ordinary character, e.g. <b>\\</b> matches a backslash
character</dd>

<dt><a name="M22"><b>\</b><i>c</i></a></dt>

<dd>where <i>c</i> is alphanumeric (possibly followed by other
characters), an <i>escape</i> (AREs only), see <b>ESCAPES</b>
below</dd>

<dt><a name="M23"><b>{</b></a></dt>

<dd>when followed by a character other than a digit, matches the
left-brace character &ldquo;<b>{</b>&rdquo;; when followed by a
digit, it is the beginning of a <i>bound</i> (see above)</dd>

<dt><a name="M24"><i>x</i></a></dt>

<dd>where <i>x</i> is a single character with no other
significance, matches that character.</dd>
</dl>

<h4><a name="M25">CONSTRAINTS</a></h4>

A <i>constraint</i> matches an empty string when specific
conditions are met. A constraint may not be followed by a
quantifier. The simple constraints are as follows; some more
constraints are described later, under <b>ESCAPES</b>. 

<dl class="constraints">
<dt><a name="M26"><b>^</b></a></dt>

<dd>matches at the beginning of a line</dd>

<dt><a name="M27"><b>$</b></a></dt>

<dd>matches at the end of a line</dd>

<dt><a name="M28"><b>(?=</b><i>re</i><b>)</b></a></dt>

<dd><i>positive lookahead</i> (AREs only), matches at any point
where a substring matching <i>re</i> begins</dd>

<dt><a name="M29"><b>(?!</b><i>re</i><b>)</b></a></dt>

<dd><i>negative lookahead</i> (AREs only), matches at any point
where no substring matching <i>re</i> begins</dd>
</dl>

<p>The lookahead constraints may not contain back references (see
later), and all parentheses within them are considered
non-capturing.</p>

<p>An RE may not end with &ldquo;<b>\</b>&rdquo;.</p>

<h3><a name="M30">BRACKET EXPRESSIONS</a></h3>

A <i>bracket expression</i> is a list of characters enclosed in
&ldquo;<b>[&nbsp;]</b>&rdquo;. It normally matches any single
character from the list (but see below). If the list begins with
&ldquo;<b>^</b>&rdquo;, it matches any single character (but see
below) <i>not</i> from the rest of the list. 

<p>If two characters in the list are separated by
&ldquo;<b>-</b>&rdquo;, this is shorthand for the full <i>range</i>
of characters between those two (inclusive) in the collating
sequence, e.g. &ldquo;<b>[0-9]</b>&rdquo; in Unicode matches any
conventional decimal digit. Two ranges may not share an endpoint,
so e.g. &ldquo;<b>a-c-e</b>&rdquo; is illegal. Ranges in Tcl always
use the Unicode collating sequence, but other programs may use
other collating sequences and this can be a source of
incompatability between programs.</p>

<p>To include a literal <b>]</b> or <b>-</b> in the list, the
simplest method is to enclose it in <b>[.</b> and <b>.]</b> to make
it a collating element (see below). Alternatively, make it the
first character (following a possible &ldquo;<b>^</b>&rdquo;), or
(AREs only) precede it with &ldquo;<b>\</b>&rdquo;. Alternatively,
for &ldquo;<b>-</b>&rdquo;, make it the last character, or the
second endpoint of a range. To use a literal <b>-</b> as the first
endpoint of a range, make it a collating element or (AREs only)
precede it with &ldquo;<b>\</b>&rdquo;. With the exception of
these, some combinations using <b>[</b> (see next paragraphs), and
escapes, all other special characters lose their special
significance within a bracket expression.</p>

<h4><a name="M31">CHARACTER CLASSES</a></h4>

Within a bracket expression, the name of a <i>character class</i>
enclosed in <b>[:</b> and <b>:]</b> stands for the list of all
characters (not all collating elements!) belonging to that class.
Standard character classes are: 

<dl class="character classes">
<dt><a name="M32"><b>alpha</b></a></dt>

<dd>A letter.</dd>

<dt><a name="M33"><b>upper</b></a></dt>

<dd>An upper-case letter.</dd>

<dt><a name="M34"><b>lower</b></a></dt>

<dd>A lower-case letter.</dd>

<dt><a name="M35"><b>digit</b></a></dt>

<dd>A decimal digit.</dd>

<dt><a name="M36"><b>xdigit</b></a></dt>

<dd>A hexadecimal digit.</dd>

<dt><a name="M37"><b>alnum</b></a></dt>

<dd>An alphanumeric (letter or digit).</dd>

<dt><a name="M38"><b>print</b></a></dt>

<dd>A "printable" (same as graph, except also including
space).</dd>

<dt><a name="M39"><b>blank</b></a></dt>

<dd>A space or tab character.</dd>

<dt><a name="M40"><b>space</b></a></dt>

<dd>A character producing white space in displayed text.</dd>

<dt><a name="M41"><b>punct</b></a></dt>

<dd>A punctuation character.</dd>

<dt><a name="M42"><b>graph</b></a></dt>

<dd>A character with a visible representation (includes both alnum
and punct).</dd>

<dt><a name="M43"><b>cntrl</b></a></dt>

<dd>A control character.</dd>
</dl>

<p>A locale may provide others. A character class may not be used
as an endpoint of a range.</p>

<dl>
<dd>
<p>(<i>Note:</i> the current Tcl implementation has only one
locale, the Unicode locale, which supports exactly the above
classes.)</p>
</dd>
</dl>

<h4><a name="M44">BRACKETED CONSTRAINTS</a></h4>

There are two special cases of bracket expressions: the bracket
expressions &ldquo;<b>[[:&lt;:]]</b>&rdquo; and
&ldquo;<b>[[:&gt;:]]</b>&rdquo; are constraints, matching empty
strings at the beginning and end of a word respectively. A word is
defined as a sequence of word characters that is neither preceded
nor followed by word characters. A word character is an
<i>alnum</i> character or an underscore (&ldquo;<b>_</b>&rdquo;).
These special bracket expressions are deprecated; users of AREs
should use constraint escapes instead (see below). 

<h4><a name="M45">COLLATING ELEMENTS</a></h4>

Within a bracket expression, a collating element (a character, a
multi-character sequence that collates as if it were a single
character, or a collating-sequence name for either) enclosed in
<b>[.</b> and <b>.]</b> stands for the sequence of characters of
that collating element. The sequence is a single element of the
bracket expression's list. A bracket expression in a locale that
has multi-character collating elements can thus match more than one
character. So (insidiously), a bracket expression that starts with
<b>^</b> can match multi-character collating elements even if none
of them appear in the bracket expression! 

<dl>
<dd>
<p>(<i>Note:</i> Tcl has no multi-character collating elements.
This information is only for illustration.)</p>
</dd>
</dl>

<p>For example, assume the collating sequence includes a <b>ch</b>
multi-character collating element. Then the RE
&ldquo;<b>[[.ch.]]*c</b>&rdquo; (zero or more
&ldquo;<b>ch</b>s&rdquo; followed by &ldquo;<b>c</b>&rdquo;)
matches the first five characters of &ldquo;<b>chchcc</b>&rdquo;.
Also, the RE &ldquo;<b>[^c]b</b>&rdquo; matches all of
&ldquo;<b>chb</b>&rdquo; (because &ldquo;<b>[^c]</b>&rdquo; matches
the multi-character &ldquo;<b>ch</b>&rdquo;).</p>

<h4><a name="M46">EQUIVALENCE CLASSES</a></h4>

Within a bracket expression, a collating element enclosed in
<b>[=</b> and <b>=]</b> is an equivalence class, standing for the
sequences of characters of all collating elements equivalent to
that one, including itself. (If there are no other equivalent
collating elements, the treatment is as if the enclosing delimiters
were &ldquo;<b>[.</b>&rdquo; and &ldquo;<b>.]</b>&rdquo;.) For
example, if <b>o</b> and <b>&ocirc;</b> are the members of an
equivalence class, then &ldquo;<b>[[=o=]]</b>&rdquo;,
&ldquo;<b>[[=&ocirc;=]]</b>&rdquo;, and
&ldquo;<b>[o&ocirc;]</b>&rdquo; are all synonymous. An equivalence
class may not be an endpoint of a range. 

<dl>
<dd>
<p>(<i>Note:</i> Tcl implements only the Unicode locale. It does
not define any equivalence classes. The examples above are just
illustrations.)</p>
</dd>
</dl>

<h3><a name="M47">ESCAPES</a></h3>

Escapes (AREs only), which begin with a <b>\</b> followed by an
alphanumeric character, come in several varieties: character entry,
class shorthands, constraint escapes, and back references. A
<b>\</b> followed by an alphanumeric character but not constituting
a valid escape is illegal in AREs. In EREs, there are no escapes:
outside a bracket expression, a <b>\</b> followed by an
alphanumeric character merely stands for that character as an
ordinary character, and inside a bracket expression, <b>\</b> is an
ordinary character. (The latter is the one actual incompatibility
between EREs and AREs.) 

<h4><a name="M48">CHARACTER-ENTRY ESCAPES</a></h4>

Character-entry escapes (AREs only) exist to make it easier to
specify non-printing and otherwise inconvenient characters in REs: 

<dl class="character-entry escapes">
<dt><a name="M49"><b>\a</b></a></dt>

<dd>alert (bell) character, as in C</dd>

<dt><a name="M50"><b>\b</b></a></dt>

<dd>backspace, as in C</dd>

<dt><a name="M51"><b>\B</b></a></dt>

<dd>synonym for <b>\</b> to help reduce backslash doubling in some
applications where there are multiple levels of backslash
processing</dd>

<dt><a name="M52"><b>\c</b><i>X</i></a></dt>

<dd>(where <i>X</i> is any character) the character whose low-order
5 bits are the same as those of <i>X</i>, and whose other bits are
all zero</dd>

<dt><a name="M53"><b>\e</b></a></dt>

<dd>the character whose collating-sequence name is
&ldquo;<b>ESC</b>&rdquo;, or failing that, the character with octal
value 033</dd>

<dt><a name="M54"><b>\f</b></a></dt>

<dd>formfeed, as in C</dd>

<dt><a name="M55"><b>\n</b></a></dt>

<dd>newline, as in C</dd>

<dt><a name="M56"><b>\r</b></a></dt>

<dd>carriage return, as in C</dd>

<dt><a name="M57"><b>\t</b></a></dt>

<dd>horizontal tab, as in C</dd>

<dt><a name="M58"><b>\u</b><i>wxyz</i></a></dt>

<dd>(where <i>wxyz</i> is exactly four hexadecimal digits) the
Unicode character <b>U+</b><i>wxyz</i> in the local byte
ordering</dd>

<dt><a name="M59"><b>\U</b><i>stuvwxyz</i></a></dt>

<dd>(where <i>stuvwxyz</i> is exactly eight hexadecimal digits)
reserved for a somewhat-hypothetical Unicode extension to 32
bits</dd>

<dt><a name="M60"><b>\v</b></a></dt>

<dd>vertical tab, as in C are all available.</dd>

<dt><a name="M61"><b>\x</b><i>hhh</i></a></dt>

<dd>(where <i>hhh</i> is any sequence of hexadecimal digits) the
character whose hexadecimal value is <b>0x</b><i>hhh</i> (a single
character no matter how many hexadecimal digits are used).</dd>

<dt><a name="M62"><b>\0</b></a></dt>

<dd>the character whose value is <b>0</b></dd>

<dt><a name="M63"><b>\</b><i>xy</i></a></dt>

<dd>(where <i>xy</i> is exactly two octal digits, and is not a
<i>back reference</i> (see below)) the character whose octal value
is <b>0</b><i>xy</i></dd>

<dt><a name="M64"><b>\</b><i>xyz</i></a></dt>

<dd>(where <i>xyz</i> is exactly three octal digits, and is not a
back reference (see below)) the character whose octal value is
<b>0</b><i>xyz</i></dd>
</dl>

<p>Hexadecimal digits are &ldquo;<b>0</b>-<b>9</b>&rdquo;,
&ldquo;<b>a</b>-<b>f</b>&rdquo;, and
&ldquo;<b>A</b>-<b>F</b>&rdquo;. Octal digits are
&ldquo;<b>0</b>-<b>7</b>&rdquo;.</p>

<p>The character-entry escapes are always taken as ordinary
characters. For example, <b>\135</b> is <b>]</b> in Unicode, but
<b>\135</b> does not terminate a bracket expression. Beware,
however, that some applications (e.g., C compilers and the Tcl
interpreter if the regular expression is not quoted with braces)
interpret such sequences themselves before the regular-expression
package gets to see them, which may require doubling (quadrupling,
etc.) the &ldquo;<b>\</b>&rdquo;.</p>

<h4><a name="M65">CLASS-SHORTHAND ESCAPES</a></h4>

Class-shorthand escapes (AREs only) provide shorthands for certain
commonly-used character classes: 

<dl class="class-shorthand escapes">
<dt><a name="M66"><b>\d</b></a></dt>

<dd><b>[[:digit:]]</b></dd>

<dt><a name="M67"><b>\s</b></a></dt>

<dd><b>[[:space:]]</b></dd>

<dt><a name="M68"><b>\w</b></a></dt>

<dd><b>[[:alnum:]_]</b> (note underscore)</dd>

<dt><a name="M69"><b>\D</b></a></dt>

<dd><b>[^[:digit:]]</b></dd>

<dt><a name="M70"><b>\S</b></a></dt>

<dd><b>[^[:space:]]</b></dd>

<dt><a name="M71"><b>\W</b></a></dt>

<dd><b>[^[:alnum:]_]</b> (note underscore)</dd>
</dl>

<p>Within bracket expressions, &ldquo;<b>\d</b>&rdquo;,
&ldquo;<b>\s</b>&rdquo;, and &ldquo;<b>\w</b>&rdquo; lose their
outer brackets, and &ldquo;<b>\D</b>&rdquo;,
&ldquo;<b>\S</b>&rdquo;, and &ldquo;<b>\W</b>&rdquo; are illegal.
(So, for example, &ldquo;<b>[a-c\d]</b>&rdquo; is equivalent to
&ldquo;<b>[a-c[:digit:]]</b>&rdquo;. Also,
&ldquo;<b>[a-c\D]</b>&rdquo;, which is equivalent to
&ldquo;<b>[a-c^[:digit:]]</b>&rdquo;, is illegal.)</p>

<h4><a name="M72">CONSTRAINT ESCAPES</a></h4>

A constraint escape (AREs only) is a constraint, matching the empty
string if specific conditions are met, written as an escape: 

<dl class="constraint escapes">
<dt><a name="M73"><b>\A</b></a></dt>

<dd>matches only at the beginning of the string (see
<b>MATCHING</b>, below, for how this differs from
&ldquo;<b>^</b>&rdquo;)</dd>

<dt><a name="M74"><b>\m</b></a></dt>

<dd>matches only at the beginning of a word</dd>

<dt><a name="M75"><b>\M</b></a></dt>

<dd>matches only at the end of a word</dd>

<dt><a name="M76"><b>\y</b></a></dt>

<dd>matches only at the beginning or end of a word</dd>

<dt><a name="M77"><b>\Y</b></a></dt>

<dd>matches only at a point that is not the beginning or end of a
word</dd>

<dt><a name="M78"><b>\Z</b></a></dt>

<dd>matches only at the end of the string (see <b>MATCHING</b>,
below, for how this differs from &ldquo;<b>$</b>&rdquo;)</dd>

<dt><a name="M79"><b>\</b><i>m</i></a></dt>

<dd>(where <i>m</i> is a nonzero digit) a <i>back reference</i>,
see below</dd>

<dt><a name="M80"><b>\</b><i>mnn</i></a></dt>

<dd>(where <i>m</i> is a nonzero digit, and <i>nn</i> is some more
digits, and the decimal value <i>mnn</i> is not greater than the
number of closing capturing parentheses seen so far) a <i>back
reference</i>, see below</dd>
</dl>

<p>A word is defined as in the specification of
&ldquo;<b>[[:&lt;:]]</b>&rdquo; and &ldquo;<b>[[:&gt;:]]</b>&rdquo;
above. Constraint escapes are illegal within bracket
expressions.</p>

<h4><a name="M81">BACK REFERENCES</a></h4>

A back reference (AREs only) matches the same string matched by the
parenthesized subexpression specified by the number, so that (e.g.)
&ldquo;<b>([bc])\1</b>&rdquo; matches &ldquo;<b>bb</b>&rdquo; or
&ldquo;<b>cc</b>&rdquo; but not &ldquo;<b>bc</b>&rdquo;. The
subexpression must entirely precede the back reference in the RE.
Subexpressions are numbered in the order of their leading
parentheses. Non-capturing parentheses do not define
subexpressions. 

<p>There is an inherent historical ambiguity between octal
character-entry escapes and back references, which is resolved by
heuristics, as hinted at above. A leading zero always indicates an
octal escape. A single non-zero digit, not followed by another
digit, is always taken as a back reference. A multi-digit sequence
not starting with a zero is taken as a back reference if it comes
after a suitable subexpression (i.e. the number is in the legal
range for a back reference), and otherwise is taken as octal.</p>

<h3><a name="M82">METASYNTAX</a></h3>

In addition to the main syntax described above, there are some
special forms and miscellaneous syntactic facilities available. 

<p>Normally the flavor of RE being used is specified by
application-dependent means. However, this can be overridden by a
<i>director</i>. If an RE of any flavor begins with
&ldquo;<b>***:</b>&rdquo;, the rest of the RE is an ARE. If an RE
of any flavor begins with &ldquo;<b>***=</b>&rdquo;, the rest of
the RE is taken to be a literal string, with all characters
considered ordinary characters.</p>

<p>An ARE may begin with <i>embedded options</i>: a sequence
<b>(?</b><i>xyz</i><b>)</b> (where <i>xyz</i> is one or more
alphabetic characters) specifies options affecting the rest of the
RE. These supplement, and can override, any options specified by
the application. The available option letters are:</p>

<dl class="metasyntax">
<dt><a name="M83"><b>b</b></a></dt>

<dd>rest of RE is a BRE</dd>

<dt><a name="M84"><b>c</b></a></dt>

<dd>case-sensitive matching (usual default)</dd>

<dt><a name="M85"><b>e</b></a></dt>

<dd>rest of RE is an ERE</dd>

<dt><a name="M86"><b>i</b></a></dt>

<dd>case-insensitive matching (see <b>MATCHING</b>, below)</dd>

<dt><a name="M87"><b>m</b></a></dt>

<dd>historical synonym for <b>n</b></dd>

<dt><a name="M88"><b>n</b></a></dt>

<dd>newline-sensitive matching (see <b>MATCHING</b>, below)</dd>

<dt><a name="M89"><b>p</b></a></dt>

<dd>partial newline-sensitive matching (see <b>MATCHING</b>,
below)</dd>

<dt><a name="M90"><b>q</b></a></dt>

<dd>rest of RE is a literal (&ldquo;quoted&rdquo;) string, all
ordinary characters</dd>

<dt><a name="M91"><b>s</b></a></dt>

<dd>non-newline-sensitive matching (usual default)</dd>

<dt><a name="M92"><b>t</b></a></dt>

<dd>tight syntax (usual default; see below)</dd>

<dt><a name="M93"><b>w</b></a></dt>

<dd>inverse partial newline-sensitive (&ldquo;weird&rdquo;)
matching (see <b>MATCHING</b>, below)</dd>

<dt><a name="M94"><b>x</b></a></dt>

<dd>expanded syntax (see below)</dd>
</dl>

<p>Embedded options take effect at the <b>)</b> terminating the
sequence. They are available only at the start of an ARE, and may
not be used later within it.</p>

<p>In addition to the usual (<i>tight</i>) RE syntax, in which all
characters are significant, there is an <i>expanded</i> syntax,
available in all flavors of RE with the <b>-expanded</b> switch, or
in AREs with the embedded x option. In the expanded syntax,
white-space characters are ignored and all characters between a
<b>#</b> and the following newline (or the end of the RE) are
ignored, permitting paragraphing and commenting a complex RE. There
are three exceptions to that basic rule:</p>

<dl class="metasyntax">
<dd>&bull;&nbsp; a white-space character or &ldquo;<b>#</b>&rdquo;
preceded by &ldquo;<b>\</b>&rdquo; is retained</dd>

<dd>&bull;&nbsp; white space or &ldquo;<b>#</b>&rdquo; within a
bracket expression is retained</dd>

<dd>&bull;&nbsp; white space and comments are illegal within
multi-character symbols like the ARE &ldquo;<b>(?:</b>&rdquo; or
the BRE &ldquo;<b>\(</b>&rdquo;</dd>
</dl>

<p>Expanded-syntax white-space characters are blank, tab, newline,
and any character that belongs to the <i>space</i> character
class.</p>

<p>Finally, in an ARE, outside bracket expressions, the sequence
&ldquo;<b>(?#</b><i>ttt</i><b>)</b>&rdquo; (where <i>ttt</i> is any
text not containing a &ldquo;<b>)</b>&rdquo;) is a comment,
completely ignored. Again, this is not allowed between the
characters of multi-character symbols like
&ldquo;<b>(?:</b>&rdquo;. Such comments are more a historical
artifact than a useful facility, and their use is deprecated; use
the expanded syntax instead.</p>

<p><i>None</i> of these metasyntax extensions is available if the
application (or an initial &ldquo;<b>***=</b>&rdquo; director) has
specified that the user's input be treated as a literal string
rather than as an RE.</p>

<h3><a name="M95">MATCHING</a></h3>

In the event that an RE could match more than one substring of a
given string, the RE matches the one starting earliest in the
string. If the RE could match more than one substring starting at
that point, its choice is determined by its <i>preference</i>:
either the longest substring, or the shortest. 

<p>Most atoms, and all constraints, have no preference. A
parenthesized RE has the same preference (possibly none) as the RE.
A quantified atom with quantifier <b>{</b><i>m</i><b>}</b> or
<b>{</b><i>m</i><b>}?</b> has the same preference (possibly none)
as the atom itself. A quantified atom with other normal quantifiers
(including <b>{</b><i>m</i><b>,</b><i>n</i><b>}</b> with <i>m</i>
equal to <i>n</i>) prefers longest match. A quantified atom with
other non-greedy quantifiers (including
<b>{</b><i>m</i><b>,</b><i>n</i><b>}?</b> with <i>m</i> equal to
<i>n</i>) prefers shortest match. A branch has the same preference
as the first quantified atom in it which has a preference. An RE
consisting of two or more branches connected by the <b>|</b>
operator prefers longest match.</p>

<p>Subject to the constraints imposed by the rules for matching the
whole RE, subexpressions also match the longest or shortest
possible substrings, based on their preferences, with
subexpressions starting earlier in the RE taking priority over ones
starting later. Note that outer subexpressions thus take priority
over their component subexpressions.</p>

<p>Note that the quantifiers <b>{1,1}</b> and <b>{1,1}?</b> can be
used to force longest and shortest preference, respectively, on a
subexpression or a whole RE.</p>

<p>Match lengths are measured in characters, not collating
elements. An empty string is considered longer than no match at
all. For example, &ldquo;<b>bb*</b>&rdquo; matches the three middle
characters of &ldquo;<b>abbbc</b>&rdquo;,
&ldquo;<b>(week|wee)(night|knights)</b>&rdquo; matches all ten
characters of &ldquo;<b>weeknights</b>&rdquo;, when
&ldquo;<b>(.*).*</b>&rdquo; is matched against
&ldquo;<b>abc</b>&rdquo; the parenthesized subexpression matches
all three characters, and when &ldquo;<b>(a*)*</b>&rdquo; is
matched against &ldquo;<b>bc</b>&rdquo; both the whole RE and the
parenthesized subexpression match an empty string.</p>

<p>If case-independent matching is specified, the effect is much as
if all case distinctions had vanished from the alphabet. When an
alphabetic that exists in multiple cases appears as an ordinary
character outside a bracket expression, it is effectively
transformed into a bracket expression containing both cases, so
that <b>x</b> becomes &ldquo;<b>[xX]</b>&rdquo;. When it appears
inside a bracket expression, all case counterparts of it are added
to the bracket expression, so that &ldquo;<b>[x]</b>&rdquo; becomes
&ldquo;<b>[xX]</b>&rdquo; and &ldquo;<b>[^x]</b>&rdquo; becomes
&ldquo;<b>[^xX]</b>&rdquo;.</p>

<p>If newline-sensitive matching is specified, <b>.</b> and bracket
expressions using <b>^</b> will never match the newline character
(so that matches will never cross newlines unless the RE explicitly
arranges it) and <b>^</b> and <b>$</b> will match the empty string
after and before a newline respectively, in addition to matching at
beginning and end of string respectively. ARE <b>\A</b> and
<b>\Z</b> continue to match beginning or end of string
<i>only</i>.</p>

<p>If partial newline-sensitive matching is specified, this affects
<b>.</b> and bracket expressions as with newline-sensitive
matching, but not <b>^</b> and <b>$</b>.</p>

<p>If inverse partial newline-sensitive matching is specified, this
affects <b>^</b> and <b>$</b> as with newline-sensitive matching,
but not <b>.</b> and bracket expressions. This is not very useful
but is provided for symmetry.</p>

<h3><a name="M96">LIMITS AND COMPATIBILITY</a></h3>

No particular limit is imposed on the length of REs. Programs
intended to be highly portable should not employ REs longer than
256 bytes, as a POSIX-compliant implementation can refuse to accept
such REs. 

<p>The only feature of AREs that is actually incompatible with
POSIX EREs is that <b>\</b> does not lose its special significance
inside bracket expressions. All other ARE features use syntax which
is illegal or has undefined or unspecified effects in POSIX EREs;
the <b>***</b> syntax of directors likewise is outside the POSIX
syntax for both BREs and EREs.</p>

<p>Many of the ARE extensions are borrowed from Perl, but some have
been changed to clean them up, and a few Perl extensions are not
present. Incompatibilities of note include &ldquo;<b>\b</b>&rdquo;,
&ldquo;<b>\B</b>&rdquo;, the lack of special treatment for a
trailing newline, the addition of complemented bracket expressions
to the things affected by newline-sensitive matching, the
restrictions on parentheses and back references in lookahead
constraints, and the longest/shortest-match (rather than
first-match) matching semantics.</p>

<p>The matching rules for REs containing both normal and non-greedy
quantifiers have changed since early beta-test versions of this
package. (The new rules are much simpler and cleaner, but do not
work as hard at guessing the user's real intentions.)</p>

<p>Henry Spencer's original 1986 <i>regexp</i> package, still in
widespread use (e.g., in pre-8.1 releases of Tcl), implemented an
early version of today's EREs. There are four incompatibilities
between <i>regexp</i>'s near-EREs (&ldquo;RREs&rdquo; for short)
and AREs. In roughly increasing order of significance:</p>

<dl class="limits and compatibility">
<dd>&bull;&nbsp; In AREs, <b>\</b> followed by an alphanumeric
character is either an escape or an error, while in RREs, it was
just another way of writing the alphanumeric. This should not be a
problem because there was no reason to write such a sequence in
RREs.</dd>

<dd>&bull;&nbsp; <b>{</b> followed by a digit in an ARE is the
beginning of a bound, while in RREs, <b>{</b> was always an
ordinary character. Such sequences should be rare, and will often
result in an error because following characters will not look like
a valid bound.</dd>

<dd>&bull;&nbsp; In AREs, <b>\</b> remains a special character
within &ldquo;<b>[&nbsp;]</b>&rdquo;, so a literal <b>\</b> within
<b>[&nbsp;]</b> must be written &ldquo;<b>\\</b>&rdquo;. <b>\\</b>
also gives a literal <b>\</b> within <b>[&nbsp;]</b> in RREs, but
only truly paranoid programmers routinely doubled the
backslash.</dd>

<dd>&bull;&nbsp; AREs report the longest/shortest match for the RE,
rather than the first found in a specified search order. This may
affect some RREs which were written in the expectation that the
first match would be reported. (The careful crafting of RREs to
optimize the search order for fast matching is obsolete (AREs
examine all possible matches in parallel, and their performance is
largely insensitive to their complexity) but cases where the search
order was exploited to deliberately find a match which was
<i>not</i> the longest/shortest will need rewriting.)</dd>
</dl>

<h3><a name="M97">BASIC REGULAR EXPRESSIONS</a></h3>

BREs differ from EREs in several respects. &ldquo;<b>|</b>&rdquo;,
&ldquo;<b>+</b>&rdquo;, and <b>?</b> are ordinary characters and
there is no equivalent for their functionality. The delimiters for
bounds are <b>\{</b> and &ldquo;<b>\}</b>&rdquo;, with <b>{</b> and
<b>}</b> by themselves ordinary characters. The parentheses for
nested subexpressions are <b>\(</b> and &ldquo;<b>\)</b>&rdquo;,
with <b>(</b> and <b>)</b> by themselves ordinary characters.
<b>^</b> is an ordinary character except at the beginning of the RE
or the beginning of a parenthesized subexpression, <b>$</b> is an
ordinary character except at the end of the RE or the end of a
parenthesized subexpression, and <b>*</b> is an ordinary character
if it appears at the beginning of the RE or the beginning of a
parenthesized subexpression (after a possible leading
&ldquo;<b>^</b>&rdquo;). Finally, single-digit back references are
available, and <b>\&lt;</b> and <b>\&gt;</b> are synonyms for
&ldquo;<b>[[:&lt;:]]</b>&rdquo; and &ldquo;<b>[[:&gt;:]]</b>&rdquo;
respectively; no other escapes are available. 

<h3><a name="M98">SEE ALSO</a></h3>

<b><a href="../TclCmd/regexp.htm">RegExp</a></b>, <b><a href=
"../TclCmd/regexp.htm">regexp</a></b>, <b><a href=
"../TclCmd/regsub.htm">regsub</a></b>, <b><a href=
"../TclCmd/lsearch.htm">lsearch</a></b>, <b><a href=
"../TclCmd/switch.htm">switch</a></b>, <b><a href=
"../TkCmd/text.htm">text</a></b> 

<h3><a name="M99">KEYWORDS</a></h3>

<a href="../Keywords/M.htm#match">match</a>, <a href=
"../Keywords/R.htm#regular expression">regular expression</a>, <a
href="../Keywords/S.htm#string">string</a> 

<div class="copy">Copyright &copy; 1995-1997 Roger E. Critchlow Jr.
Copyright &copy; 1998 Sun Microsystems, Inc. Copyright &copy; 1999
Scriptics Corporation</div>
</body>
</html>

