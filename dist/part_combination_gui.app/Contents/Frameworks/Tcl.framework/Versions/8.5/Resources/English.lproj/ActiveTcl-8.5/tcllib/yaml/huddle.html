<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<meta name="generator" content="HTML Tidy, see www.w3.org">
<title>huddle - HUDDLE</title>
<meta name='Author' content='ActiveState'>
<link rel='stylesheet' type='text/css' href='../../aspn.css'>
</head>
<body>
<div class="doctools">
<div class="banner">
<table width="100%" border="0" cellspacing="0" cellpadding="3">
<tr>
<td align="left"><a target="_blank" href=
"http://www.activestate.com/activetcl"><img src=
"../../images/ActiveTcl.gif" border="0" align="left" alt=
"ActiveTcl"></a> </td>
<td align="center" class="heading">ActiveTcl User Guide</td>
<td align="right"><a target="_blank" href=
"http://www.activestate.com"><img src="../../images/AS_logo.gif"
border="0" align="right" alt="ActiveState Software Inc."></a> </td>
</tr>
</table>
</div>

<hr>
[ <a href="../../at.pkg_index.html">Main table Of Contents</a> | <a
href="../toc.html">Tcllib Table Of Contents</a> | <a href=
"../index.html">Tcllib Index</a> ] 

<hr>
<h1 class="title">huddle(n) 0.1.5 "HUDDLE"</h1>

<div id="name" class="section">
<h2><a name="name">Name</a></h2>

<p>huddle - Create and manipulate huddle object</p>
</div>

<div id="toc" class="section">
<h2><a name="toc">Table Of Contents</a></h2>

<ul class="toc">
<li class="section"><a href="#toc">Table Of Contents</a></li>

<li class="section"><a href="#synopsis">Synopsis</a></li>

<li class="section"><a href="#section1">Description</a></li>

<li class="section"><a href="#section2">COMMANDS</a></li>

<li class="section"><a href="#section3">TYPE CALLBACK</a></li>

<li class="section"><a href="#section4">How to add type</a></li>

<li class="section"><a href="#section5">WORKING SAMPLE</a></li>

<li class="section"><a href="#section6">LIMITATIONS</a></li>

<li class="section"><a href="#section7">BUGS, IDEAS,
FEEDBACK</a></li>

<li class="section"><a href="#see-also">See Also</a></li>

<li class="section"><a href="#keywords">Keywords</a></li>

<li class="section"><a href="#copyright">Copyright</a></li>
</ul>
</div>

<div id="synopsis" class="section">
<h2><a name="synopsis">Synopsis</a></h2>

<div class="synopsis">
<ul class="requirements">
<li>package require <b class="pkgname">Tcl 8.4</b></li>

<li>package require <b class="pkgname">huddle <span class=
"opt">?0.1.5?</span></b></li>
</ul>

<ul class="syntax">
<li><a href="#1"><b class="cmd">huddle create</b> <i class=
"arg">key</i> <i class="arg">value</i> <span class="opt">?<i class=
"arg">key value ...</i>?</span></a></li>

<li><a href="#2"><b class="cmd">huddle list</b> <span class=
"opt">?<i class="arg">value value ...</i>?</span></a></li>

<li><a href="#3"><b class="cmd">huddle get</b> <i class=
"arg">object</i> <i class="arg">key</i> <span class="opt">?<i
class="arg">key ...</i>?</span></a></li>

<li><a href="#4"><b class="cmd">huddle gets</b> <i class=
"arg">object</i> <i class="arg">key</i> <span class="opt">?<i
class="arg">key ...</i>?</span></a></li>

<li><a href="#5"><b class="cmd">huddle set</b> <i class=
"arg">objectVar</i> <i class="arg">key</i> <span class="opt">?<i
class="arg">key ...</i>?</span> <i class="arg">value</i></a></li>

<li><a href="#6"><b class="cmd">huddle remove</b> <i class=
"arg">object</i> <i class="arg">key</i> <span class="opt">?<i
class="arg">key ...</i>?</span></a></li>

<li><a href="#7"><b class="cmd">huddle combine</b> <i class=
"arg">object1</i> <i class="arg">object2</i> <span class="opt">?<i
class="arg">object3 ...</i>?</span></a></li>

<li><a href="#8"><b class="cmd">huddle equal</b> <i class=
"arg">object1</i> <i class="arg">object2</i></a></li>

<li><a href="#9"><b class="cmd">huddle append</b> <i class=
"arg">objectVar</i> <i class="arg">key</i> <i class="arg">value</i>
<span class="opt">?<i class="arg">key value
...</i>?</span></a></li>

<li><a href="#10"><b class="cmd">huddle append</b> <i class=
"arg">objectVar</i> <i class="arg">value</i> <span class="opt">?<i
class="arg">value ...</i>?</span></a></li>

<li><a href="#11"><b class="cmd">huddle keys</b> <i class=
"arg">object</i></a></li>

<li><a href="#12"><b class="cmd">huddle llength</b> <i class=
"arg">object</i></a></li>

<li><a href="#13"><b class="cmd">huddle type</b> <i class=
"arg">object</i> <span class="opt">?<i class="arg">key
key...</i>?</span></a></li>

<li><a href="#14"><b class="cmd">huddle strip</b> <i class=
"arg">object</i></a></li>

<li><a href="#15"><b class="cmd">huddle jsondump</b> <i class=
"arg">object</i> <span class="opt">?<i class=
"arg">offset</i>?</span> <span class="opt">?<i class=
"arg">newline</i>?</span> <span class="opt">?<i class=
"arg">begin_offset</i>?</span></a></li>

<li><a href="#16"><b class="cmd">huddle compile</b> <i class=
"arg">spec</i> <i class="arg">data</i></a></li>

<li><a href="#17"><b class="cmd">huddle isHuddle</b> <i class=
"arg">object</i></a></li>

<li><a href="#18"><b class="cmd">huddle checkHuddle</b> <i class=
"arg">object</i></a></li>

<li><a href="#19"><b class="cmd">huddle to_node</b> <i class=
"arg">object</i> <span class="opt">?<i class=
"arg">tag</i>?</span></a></li>

<li><a href="#20"><b class="cmd">huddle wrap</b> <i class=
"arg">tag</i> <i class="arg">src</i></a></li>

<li><a href="#21"><b class="cmd">huddle call</b> <i class=
"arg">tag</i> <i class="arg">command</i> <i class=
"arg">args</i></a></li>

<li><a href="#22"><b class="cmd">huddle addType</b> <i class=
"arg">callback</i></a></li>

<li><a href="#23"><b class="cmd"><a href=
"../index.html#key152">callback</a></b> <i class="arg">command</i>
<span class="opt">?<i class="arg">args</i>?</span></a></li>

<li><a href="#24"><b class="cmd">setting</b></a></li>

<li><a href="#25"><b class="cmd">get_sub</b> <i class="arg">src</i>
<i class="arg">key</i></a></li>

<li><a href="#26"><b class="cmd">strip</b> <i class=
"arg">src</i></a></li>

<li><a href="#27"><b class="cmd"><a href=
"../index.html#key662">set</a></b> <i class="arg">src</i> <i class=
"arg">key</i> <i class="arg">value</i></a></li>

<li><a href="#28"><b class="cmd"><a href=
"../index.html#key599">remove</a></b> <i class="arg">src</i> <i
class="arg">key</i> <i class="arg">value</i></a></li>
</ul>
</div>
</div>

<div id="section1" class="section">
<h2><a name="section1">Description</a></h2>

<p>Huddle provides a generic Tcl-based serialization/intermediary
format. Currently, each node is wrapped in a tag with simple type
information.</p>

<p>When converting huddle-notation to other serialization formats
like JSON or YAML this type information is used to select the
proper notation. And when going from JSON/YAML/... to huddle their
notation can be used to select the proper huddle type.</p>

<p>In that manner huddle can serve as a common intermediary
format.</p>

<pre class="example">
huddle-format: &gt;
  {HUDDLE {huddle-node}}
huddle-node: &gt;
  {tag content}
each content of tag means:
  s: (content is a) string
  L: list, each sub node is a huddle-node
  D: dict, each sub node is a huddle-node
confirmed:
  - JSON
  - YAML(generally, but cannot discribe YAML-tags)
limitation:
  - cannot discribe aliases from a node to other node.
</pre>

<p>The <b class="package">huddle</b> package returns data as a Tcl
<b class="cmd">dict</b>. Either the <b class="package">dict</b>
package or Tcl 8.5 is required for use.</p>
</div>

<div id="section2" class="section">
<h2><a name="section2">COMMANDS</a></h2>

<dl class="definitions">
<dt><a name="1"><b class="cmd">huddle create</b> <i class=
"arg">key</i> <i class="arg">value</i> <span class="opt">?<i class=
"arg">key value ...</i>?</span></a></dt>

<dd>
<p>Create a huddle object as a dict. It can contain other huddle
objects.</p>
</dd>

<dt><a name="2"><b class="cmd">huddle list</b> <span class=
"opt">?<i class="arg">value value ...</i>?</span></a></dt>

<dd>
<p>Create a huddle object as a list. It can contain other huddle
objects.</p>
</dd>

<dt><a name="3"><b class="cmd">huddle get</b> <i class=
"arg">object</i> <i class="arg">key</i> <span class="opt">?<i
class="arg">key ...</i>?</span></a></dt>

<dd>
<p>Almost the same as <b class="cmd">dict get</b>. Get a sub-object
from the huddle object. <i class="arg">key</i> can be used to
huddle-list's index.</p>
</dd>

<dt><a name="4"><b class="cmd">huddle gets</b> <i class=
"arg">object</i> <i class="arg">key</i> <span class="opt">?<i
class="arg">key ...</i>?</span></a></dt>

<dd>
<p>Get a sub-object from the huddle object, stripped.</p>
</dd>

<dt><a name="5"><b class="cmd">huddle set</b> <i class=
"arg">objectVar</i> <i class="arg">key</i> <span class="opt">?<i
class="arg">key ...</i>?</span> <i class="arg">value</i></a></dt>

<dd>
<p>Almost the same as <b class="cmd">dict set</b>. Set a sub-object
from the huddle object. <i class="arg">key</i> can be used to
huddle-list's index.</p>
</dd>

<dt><a name="6"><b class="cmd">huddle remove</b> <i class=
"arg">object</i> <i class="arg">key</i> <span class="opt">?<i
class="arg">key ...</i>?</span></a></dt>

<dd>
<p>Almost the same as <b class="cmd">dict remove</b>. Remove a
sub-object from the huddle object. <i class="arg">key</i> can be
used to huddle-list's index.</p>
</dd>

<dt><a name="7"><b class="cmd">huddle combine</b> <i class=
"arg">object1</i> <i class="arg">object2</i> <span class="opt">?<i
class="arg">object3 ...</i>?</span></a></dt>

<dd>
<p>Merging huddle objects given.</p>

<pre class="example">
% set aa [huddle create a b c d]
HUDDLE {D {a {s b} c {s d}}}
% set bb [huddle create a k l m]
HUDDLE {D {a {s k} l {s m}}}
% huddle combine $aa $bb
HUDDLE {D {a {s k} c {s d} l {s m}}}
</pre>
</dd>

<dt><a name="8"><b class="cmd">huddle equal</b> <i class=
"arg">object1</i> <i class="arg">object2</i></a></dt>

<dd>
<p>Comparing two huddle objects recursively. When to equal, returns
1, otherwise 0.</p>

<pre class="example">
% set aa [huddle create a b c d]
HUDDLE {D {a {s b} c {s d}}}
% set bb [huddle create c d a b]
HUDDLE {D {c {s d} a {s b}}}
% huddle equal $aa $bb
1
</pre>
</dd>

<dt><a name="9"><b class="cmd">huddle append</b> <i class=
"arg">objectVar</i> <i class="arg">key</i> <i class="arg">value</i>
<span class="opt">?<i class="arg">key value
...</i>?</span></a></dt>

<dt><a name="10"><b class="cmd">huddle append</b> <i class=
"arg">objectVar</i> <i class="arg">value</i> <span class="opt">?<i
class="arg">value ...</i>?</span></a></dt>

<dd>
<p>Appending child elements. When for dicts, giving key/value. When
for lists, giving values.</p>

<pre class="example">
% set aa [huddle create a b c d]
HUDDLE {D {a {s b} c {s d}}}
% huddle append aa a k l m
HUDDLE {D {a {s k} c {s d} l {s m}}}
% set bb [huddle list i j k l]
HUDDLE {L {{s i} {s j} {s k} {s l}}}
% huddle append bb g h i
HUDDLE {L {{s i} {s j} {s k} {s l} {s g} {s h} {s i}}}
</pre>
</dd>

<dt><a name="11"><b class="cmd">huddle keys</b> <i class=
"arg">object</i></a></dt>

<dd>
<p>The same as <b class="cmd">dict keys</b>.</p>
</dd>

<dt><a name="12"><b class="cmd">huddle llength</b> <i class=
"arg">object</i></a></dt>

<dd>
<p>The same as <b class="cmd">llength</b>.</p>
</dd>

<dt><a name="13"><b class="cmd">huddle type</b> <i class=
"arg">object</i> <span class="opt">?<i class="arg">key
key...</i>?</span></a></dt>

<dd>
<p>Return the element type of specified by keys. if <span class=
"opt">?key?</span> is not given, returns the type of root node.</p>

<dl class="options">
<dt><b class="option">string</b></dt>

<dd>
<p>the node is a tcl's string.</p>
</dd>

<dt><b class="option">dict</b></dt>

<dd>
<p>the node is a dict.</p>
</dd>

<dt><b class="option">list</b></dt>

<dd>
<p>the node is a list.</p>
</dd>
</dl>

<pre class="example">
% huddle type {HUDDLE {s str}}
string
% huddle type {HUDDLE {L {{s a} {s b} {s c}}}}
list
% huddle type {HUDDLE {D {aa {s b} cc {s d}}}} cc
string
</pre>
</dd>

<dt><a name="14"><b class="cmd">huddle strip</b> <i class=
"arg">object</i></a></dt>

<dd>
<p>Stripped all tags. Converted to normal Tcl's list/dict.</p>
</dd>

<dt><a name="15"><b class="cmd">huddle jsondump</b> <i class=
"arg">object</i> <span class="opt">?<i class=
"arg">offset</i>?</span> <span class="opt">?<i class=
"arg">newline</i>?</span> <span class="opt">?<i class=
"arg">begin_offset</i>?</span></a></dt>

<dd>
<p>dump a json-stream from the huddle-object.</p>

<dl class="options">
<dt><b class="option">offset ""</b></dt>

<dd>
<p>begin offset as spaces " ".</p>
</dd>
</dl>

<pre class="example">
# normal output has some indents. some strings are escaped.
% huddle jsondump {HUDDLE {L {{L {{s i} {s baa} {s \\k} {L {{s 1.0} {s true} {s /g} {s h}}} {L {{s g}}}}} {s t}}}}
[
  [
    "i",
    "baa",
    "\\k",
    [
      1.0,
      true,
      "\/g",
      "h"
    ],
    ["g"]
  ],
  "t"
]
# stripped output
% huddle jsondump {HUDDLE {D {dd {D {bb {D {a {s baa} c {s {d
a}}}} cc {D {g {s h}}}}} ee {D {i {s j} k {s 1} j {s { m\a}}}}}}} "" ""
{"dd": {"bb": {"a": "baa","c": "d\na"},"cc": {"g": "h"}},"ee": {"i": "j","k": 1,"j": " m\\a"}}
</pre>
</dd>

<dt><a name="16"><b class="cmd">huddle compile</b> <i class=
"arg">spec</i> <i class="arg">data</i></a></dt>

<dd>
<p>construct a huddle object from plain old tcl values. <i class=
"arg">spec</i> is defined as follows:</p>

<dl class="definitions">
<dt><b class="const">string</b></dt>

<dd>
<p>data is simply a string</p>
</dd>

<dt><b class="const">list</b></dt>

<dd>
<p>data is a tcl list of strings</p>
</dd>

<dt><b class="const">dict</b></dt>

<dd>
<p>data is a tcl dict of strings</p>
</dd>

<dt>list list</dt>

<dd>
<p>data is a tcl list of lists</p>
</dd>

<dt>list dict</dt>

<dd>
<p>data is a tcl list of dicts</p>
</dd>

<dt>dict xx list</dt>

<dd>
<p>data is a tcl dict where the value of key xx is a tcl list</p>
</dd>

<dt>dict * list</dt>

<dd>
<p>data is a tcl dict of lists <i class="arg">data</i> is plain old
tcl values</p>
</dd>
</dl>

<pre class="example">
% huddle compile {dict * list} {a {1 2 3} b {4 5}}
HUDDLE {D {a {L {{s 1} {s 2} {s 3}}} b {L {{s 4} {s 5}}}}}
% huddle compile {dict * {list {dict d list}}} {a {{c 1} {d {2 2 2} e 3}} b {{f 4 g 5}}}
HUDDLE {D {a {L {{D {c {s 1}}} {D {d {L {{s 2} {s 2} {s 2}}} e {s 3}}}}} b {L {{D {f {s 4} g {s 5}}}}}}}
</pre>
</dd>

<dt><a name="17"><b class="cmd">huddle isHuddle</b> <i class=
"arg">object</i></a></dt>

<dd>
<p>if <i class="arg">object</i> is a huddle, returns 1. the other,
returns 0.</p>
</dd>

<dt><a name="18"><b class="cmd">huddle checkHuddle</b> <i class=
"arg">object</i></a></dt>

<dd>
<p>if <i class="arg">object</i> is not a huddle, rises an
error.</p>
</dd>

<dt><a name="19"><b class="cmd">huddle to_node</b> <i class=
"arg">object</i> <span class="opt">?<i class=
"arg">tag</i>?</span></a></dt>

<dd>
<p>for type-callbacks.</p>

<p>if <i class="arg">object</i> is a huddle, returns root-node. the
other, returns <b class="cmd">[list s $object]</b>.</p>

<pre class="example">
% huddle to_node str
s str
% huddle to_node str !!str
!!str str
% huddle to_node {HUDDLE {s str}}
s str
% huddle to_node {HUDDLE {l {a b c}}}
l {a b c}
</pre>
</dd>

<dt><a name="20"><b class="cmd">huddle wrap</b> <i class=
"arg">tag</i> <i class="arg">src</i></a></dt>

<dd>
<p>for type-callbacks.</p>

<p>Create a huddle object from <i class="arg">src</i> with
specified <i class="arg">tag</i>.</p>

<pre class="example">
% huddle wrap "" str
HUDDLE str
% huddle wrap s str
HUDDLE {s str}
</pre>
</dd>

<dt><a name="21"><b class="cmd">huddle call</b> <i class=
"arg">tag</i> <i class="arg">command</i> <i class=
"arg">args</i></a></dt>

<dd>
<p>for type-callbacks.</p>

<p>devolving <i class="arg">command</i> to default <i class=
"arg">tag</i>-callback</p>
</dd>

<dt><a name="22"><b class="cmd">huddle addType</b> <i class=
"arg">callback</i></a></dt>

<dd>
<p>add a user-specified-type/tag to the huddle library. To see
"Additional Type".</p>

<dl class="options">
<dt><b class="option">callback</b></dt>

<dd>
<p>callback function name for additional type.</p>
</dd>
</dl>
</dd>
</dl>
</div>

<div id="section3" class="section">
<h2><a name="section3">TYPE CALLBACK</a></h2>

<p>The definition of callback for user-type.</p>

<dl class="definitions">
<dt><a name="23"><b class="cmd"><a href=
"../index.html#key152">callback</a></b> <i class="arg">command</i>
<span class="opt">?<i class="arg">args</i>?</span></a></dt>

<dd>
<dl class="options">
<dt><b class="option">command</b></dt>

<dd>
<p>huddle subcomand which is needed to reply by the callback.</p>
</dd>

<dt><b class="option">args</b></dt>

<dd>
<p>arguments of subcommand. The number of list of arguments is
different for each subcommand.</p>
</dd>
</dl>
</dd>
</dl>

<p>The callback procedure shuould reply the following
subcommands.</p>

<dl class="definitions">
<dt><a name="24"><b class="cmd">setting</b></a></dt>

<dd>
<p>only returns a fixed dict of the type infomation for setting the
user-tag.</p>

<dl class="definitions">
<dt><b class="const">type</b> typename</dt>

<dd>
<p>typename of the type</p>
</dd>

<dt><b class="const">method</b> {method1 method2 method3 ...}</dt>

<dd>
<p>method list as huddle subcommand. Then, you can call <b class=
"cmd">[huddle method1 ...]</b></p>
</dd>

<dt><b class="const">tag</b> {tag1 child/parent tag2 child/parent
...}</dt>

<dd>
<p>tag list for huddle-node as a dict. if the type has child-nodes,
use "parent", otherwise use "child".</p>
</dd>
</dl>
</dd>

<dt><a name="25"><b class="cmd">get_sub</b> <i class="arg">src</i>
<i class="arg">key</i></a></dt>

<dd>
<p>returns a sub node specified by <i class="arg">key</i>.</p>

<dl class="options">
<dt><b class="option">src</b></dt>

<dd>
<p>a node content in huddle object.</p>
</dd>
</dl>
</dd>

<dt><a name="26"><b class="cmd">strip</b> <i class=
"arg">src</i></a></dt>

<dd>
<p>returns stripped node contents. if the type has child nodes,
every node must be stripped.</p>
</dd>

<dt><a name="27"><b class="cmd"><a href=
"../index.html#key662">set</a></b> <i class="arg">src</i> <i class=
"arg">key</i> <i class="arg">value</i></a></dt>

<dd>
<p>sets a sub-node from the tagged-content, and returns self.</p>
</dd>

<dt><a name="28"><b class="cmd"><a href=
"../index.html#key599">remove</a></b> <i class="arg">src</i> <i
class="arg">key</i> <i class="arg">value</i></a></dt>

<dd>
<p>removes a sub-node from the tagged-content, and returns
self.</p>
</dd>
</dl>

<p><b class="cmd">strip</b> must be defined at all types. <b class=
"cmd">get_sub</b> must be defined at container types. <b class=
"cmd">set/remove</b> shuould be defined, if you call them.</p>

<pre class="example">
# callback sample for my-dict
proc my_dict_setting {command args} {
    switch -- $command {
        setting { ; # type definition
            return {
                type dict
                method {create keys}
                tag {d child D parent}
                constructor create
                str s
            }
            # type:   the type-name
            # method: add methods to huddle's subcommand.
            #          "get_sub/strip/set/remove/equal/append" called by huddle module.
            #          "strip" must be defined at all types.
            #          "get_sub" must be defined at container types.
            #          "set/remove/equal/append" shuould be defined, if you call them.
            # tag:    tag definition("child/parent" word is maybe obsoleted)
        }
        get_sub { ; # get a sub-node specified by "key" from the tagged-content
            foreach {src key} $args break
            return [dict get $src $key]
        }
        strip { ; # strip from the tagged-content
            foreach {src nop} $args break
            foreach {key val} $src {
                lappend result $key [huddle strip $val]
            }
            return $result
        }
        set { ; # set a sub-node from the tagged-content
            foreach {src key value} $args break
            dict set src $key $value
            return $src
        }
        remove { ; # remove a sub-node from the tagged-content
            foreach {src key value} $args break
            return [dict remove $src $key]
        }
        equal { ; # check equal for each node
            foreach {src1 src2} $args break
            if {[llength $src1] != [llength $src2]} {return 0}
            foreach {key1 val1} $src1 {
                if {![dict exists $src2 $key1]} {return 0}
                if {![huddle _equal_subs $val1 [dict get $src2 $key1]]} {return 0}
            }
            return 1
        }
        append { ; # append nodes
            foreach {str src list} $args break
            if {[llength $list] % 2} {error {wrong # args: should be "huddle append objvar ?key value ...?"}}
            set resultL $src
            foreach {key value} $list {
                if {$str ne ""} {
                    lappend resultL $key [huddle to_node $value $str]
                } else {
                    lappend resultL $key $value
                }
            }
            return [eval dict create $resultL]
        }
        create { ; # $args: all arguments after "huddle create"
            if {[llength $args] % 2} {error {wrong # args: should be "huddle create ?key value ...?"}}
            set resultL {}
            foreach {key value} $args {
                lappend resultL $key [huddle to_node $value]
            }
            return [huddle wrap D $resultL]
        }
        keys {
            foreach {src nop} $args break
            return [dict keys [lindex [lindex $src 1] 1]]
        }
        default {
            error "$command is not callback for dict"
        }
    }
}
</pre>

<pre class="example">
# inheritance sample from default dict-callback
proc ::yaml::_huddle_mapping {command args} {
    switch -- $command {
        setting { ; # type definition
            return {
                type dict
                method {mapping}
                tag {!!map parent}
                constructor mapping
                str !!str
            }
        }
        mapping { ; # $args: all arguments after "huddle mapping"
            if {[llength $args] % 2} {error {wrong # args: should be "huddle mapping ?key value ...?"}}
            set resultL {}
            foreach {key value} $args {
                lappend resultL $key [huddle to_node $value !!str]
            }
            return [huddle wrap !!map $resultL]
        }
        default { ; # devolving to default dict-callback
            return [huddle call D $command $args]
        }
    }
}
</pre>
</div>

<div id="section4" class="section">
<h2><a name="section4">How to add type</a></h2>

<p>You can add huddle-node types e.g. ::struct::tree. To do so,
first, define a callback-procedure for additional tagged-type. The
proc get argments as <i class="arg">command</i> and <span class=
"opt">?<i class="arg">args</i>?</span>. It has some
switch-sections.</p>

<p>And, addType subcommand will called.</p>

<pre class="example">
huddle addType my_dict_setting
</pre>
</div>

<div id="section5" class="section">
<h2><a name="section5">WORKING SAMPLE</a></h2>

<pre class="example">
# create as a dict
% set bb [huddle create a b c d]
HUDDLE {D {a {s b} c {s d}}}
# create as a list
% set cc [huddle list e f g h]
HUDDLE {L {{s e} {s f} {s g} {s h}}}
% set bbcc [huddle create bb $bb cc $cc]
HUDDLE {D {bb {D {a {s b} c {s d}}} cc {L {{s e} {s f} {s g} {s h}}}}}
% set folding [huddle list $bbcc p [huddle list q r] s]
HUDDLE {L {{D {bb {D {a {s b} c {s d}}} cc {L {{s e} {s f} {s g} {s h}}}}} {s p} {L {{s q} {s r}}} {s s}}}
# normal Tcl's notation
% huddle strip $folding
{bb {a b c d} cc {e f g h}} p {q r} s
# get a sub node
% huddle get $folding 0 bb
HUDDLE {D {a {s b} c {s d}}}
% huddle gets $folding 0 bb
a b c d
# overwrite a node
% huddle set folding 0 bb c kkk
HUDDLE {L {{D {bb {D {a {s b} c {s kkk}}} cc {L {{s e} {s f} {s g} {s h}}}}} {s p} {L {{s q} {s r}}} {s s}}}
# remove a node
% huddle remove $folding 2 1
HUDDLE {L {{D {bb {D {a {s b} c {s kkk}}} cc {L {{s e} {s f} {s g} {s h}}}}} {s p} {L {{s q}}} {s s}}}
% huddle strip $folding
{bb {a b c kkk} cc {e f g h}} p {q r} s
# dump as a JSON stream
% huddle jsondump $folding
[
  {
    "bb": {
      "a": "b",
      "c": "kkk"
    },
    "cc": [
      "e",
      "f",
      "g",
      "h"
    ]
  },
  "p",
  [
    "q",
    "r"
  ],
  "s"
]
</pre>
</div>

<div id="section6" class="section">
<h2><a name="section6">LIMITATIONS</a></h2>

<p>now printing.</p>
</div>

<div id="section7" class="section">
<h2><a name="section7">BUGS, IDEAS, FEEDBACK</a></h2>

<p>This document, and the package it describes, will undoubtedly
contain bugs and other problems. Please report such in the category
<em>huddle</em> of the <a href=
"http://sourceforge.net/tracker/?group_id=12883">Tcllib SF
Trackers</a>. Please also report any ideas for enhancements you may
have for either package and/or documentation.</p>
</div>

<div id="see-also" class="section">
<h2><a name="see-also">See Also</a></h2>

<p><a href="yaml.html">yaml</a></p>
</div>

<div id="keywords" class="section">
<h2><a name="keywords">Keywords</a></h2>

<p><a href="../index.html#key227">data exchange</a>, <a href=
"../index.html#key301">exchange format</a>, <a href=
"../index.html#key369">huddle</a>, <a href=
"../index.html#key412">json</a>, <a href=
"../index.html#key532">parsing</a>, <a href=
"../index.html#key737">text processing</a>, <a href=
"../index.html#key802">yaml</a></p>
</div>

<div id="copyright" class="section">
<h2><a name="copyright">Copyright</a></h2>

<p>Copyright &copy; 2008 KATO Kanryu
&lt;kanryu6@users.sourceforge.net&gt;</p>
</div>

<h4>Copyright &copy; 2012 <a href="http://www.activestate.com">for
compilation: ActiveState</a></h4>
</div>
</body>
</html>

