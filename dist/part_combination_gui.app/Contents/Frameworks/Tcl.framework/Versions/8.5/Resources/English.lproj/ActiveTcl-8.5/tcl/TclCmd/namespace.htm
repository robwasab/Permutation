<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<meta name="generator" content="HTML Tidy, see www.w3.org">
<meta name='Author' content='ActiveState'>
<link rel='stylesheet' type='text/css' href='../../aspn.css'>
<title>Tcl Built-In Commands - namespace manual page</title>
<link rel="stylesheet" href="../docs.css" type="text/css" media=
"all">
</head>
<body>
<div class="banner">
<table width="100%" border="0" cellspacing="0" cellpadding="3">
<tr>
<td align="left"><a target="_blank" href=
"http://www.activestate.com/activetcl"><img src=
"../../images/ActiveTcl.gif" border="0" align="left" alt=
"ActiveTcl"></a> </td>
<td align="center" class="heading">ActiveTcl User Guide</td>
<td align="right"><a target="_blank" href=
"http://www.activestate.com"><img src="../../images/AS_logo.gif"
border="0" align="right" alt="ActiveState Software Inc."></a> </td>
</tr>
</table>
</div>

<br>
<h2><a href="../contents.htm">Tcl/Tk Documentation</a>
<small>&gt;</small> <a href="contents.htm">TclCmd</a>
<small>&gt;</small> namespace</h2>

<h3><a href="../UserCmd/contents.htm">Tcl/Tk Applications</a> | <a
href="../TclCmd/contents.htm">Tcl Commands</a> | <a href=
"../TkCmd/contents.htm">Tk Commands</a> | <a href=
"../TclLib/contents.htm">Tcl Library</a> | <a href=
"../TkLib/contents.htm">Tk Library</a></h3>

<dl>
<dd><a href="namespace.htm#M2" name="L1039">NAME</a> 

<dl>
<dd>namespace - create and manipulate contexts for commands and
variables</dd>
</dl>
</dd>

<dd><a href="namespace.htm#M3" name="L1040">SYNOPSIS</a> 

<dl>
<dd><b>namespace</b> ?<i>subcommand</i>? ?<i>arg ...</i>?</dd>
</dl>
</dd>

<dd><a href="namespace.htm#M4" name="L1041">DESCRIPTION</a> 

<dl class="description">
<dd><a href="namespace.htm#M5" name="L1042"><b>namespace
children</b> ?<i>namespace</i>? ?<i>pattern</i>?</a></dd>

<dd><a href="namespace.htm#M6" name="L1043"><b>namespace code</b>
<i>script</i></a></dd>

<dd><a href="namespace.htm#M7" name="L1044"><b>namespace
current</b></a></dd>

<dd><a href="namespace.htm#M8" name="L1045"><b>namespace delete</b>
?<i>namespace namespace ...</i>?</a></dd>

<dd><a href="namespace.htm#M9" name="L1046"><b>namespace
ensemble</b> <i>subcommand</i> ?<i>arg ...</i>?</a></dd>

<dd><a href="namespace.htm#M10" name="L1047"><b>namespace eval</b>
<i>namespace arg</i> ?<i>arg ...</i>?</a></dd>

<dd><a href="namespace.htm#M11" name="L1048"><b>namespace
exists</b> <i>namespace</i></a></dd>

<dd><a href="namespace.htm#M12" name="L1049"><b>namespace
export</b> ?-<b>clear</b>? ?<i>pattern pattern ...</i>?</a></dd>

<dd><a href="namespace.htm#M13" name="L1050"><b>namespace
forget</b> ?<i>pattern pattern ...</i>?</a></dd>

<dd><a href="namespace.htm#M14" name="L1051"><b>namespace
import</b> ?<b>-force</b>? ?<i>pattern</i> <i>pattern
...</i>?</a></dd>

<dd><a href="namespace.htm#M15" name="L1052"><b>namespace
inscope</b> <i>namespace</i> <i>script</i> ?<i>arg
...</i>?</a></dd>

<dd><a href="namespace.htm#M16" name="L1053"><b>namespace
origin</b> <i>command</i></a></dd>

<dd><a href="namespace.htm#M17" name="L1054"><b>namespace
parent</b> ?<i>namespace</i>?</a></dd>

<dd><a href="namespace.htm#M18" name="L1055"><b>namespace path</b>
?<i>namespaceList</i>?</a></dd>

<dd><a href="namespace.htm#M19" name="L1056"><b>namespace
qualifiers</b> <i>string</i></a></dd>

<dd><a href="namespace.htm#M20" name="L1057"><b>namespace tail</b>
<i>string</i></a></dd>

<dd><a href="namespace.htm#M21" name="L1058"><b>namespace upvar</b>
<i>namespace</i> <i>otherVar myVar</i> ?<i>otherVar myVar</i>
...</a></dd>

<dd><a href="namespace.htm#M22" name="L1059"><b>namespace
unknown</b> ?<i>script</i>?</a></dd>

<dd><a href="namespace.htm#M23" name="L1060"><b>namespace which</b>
?-<b>command</b>? ?-<b>variable</b>? <i>name</i></a></dd>
</dl>
</dd>

<dd><a href="namespace.htm#M24" name="L1061">WHAT IS A
NAMESPACE?</a></dd>

<dd><a href="namespace.htm#M25" name="L1062">QUALIFIED
NAMES</a></dd>

<dd><a href="namespace.htm#M26" name="L1063">NAME
RESOLUTION</a></dd>

<dd><a href="namespace.htm#M27" name="L1064">IMPORTING
COMMANDS</a></dd>

<dd><a href="namespace.htm#M28" name="L1065">EXPORTING
COMMANDS</a></dd>

<dd><a href="namespace.htm#M29" name="L1066">SCOPED
SCRIPTS</a></dd>

<dd><a href="namespace.htm#M30" name="L1067">ENSEMBLES</a> 

<dl class="ensembles">
<dd><a href="namespace.htm#M31" name="L1068"><b>namespace ensemble
create</b> ?<i>option value ...</i>?</a></dd>

<dd><a href="namespace.htm#M32" name="L1069"><b>namespace ensemble
configure</b> <i>command</i> ?<i>option</i>? ?<i>value
...</i>?</a></dd>

<dd><a href="namespace.htm#M33" name="L1070"><b>namespace ensemble
exists</b> <i>command</i></a></dd>
</dl>
</dd>

<dd><a href="namespace.htm#M34" name="L1071">ENSEMBLE OPTIONS</a> 

<dl class="ensemble options">
<dd><a href="namespace.htm#M35" name="L1072"><b>-map</b></a></dd>

<dd><a href="namespace.htm#M36" name=
"L1073"><b>-prefixes</b></a></dd>

<dd><a href="namespace.htm#M37" name=
"L1074"><b>-subcommands</b></a></dd>

<dd><a href="namespace.htm#M38" name=
"L1075"><b>-unknown</b></a></dd>
</dl>

<dl class="ensemble options">
<dd><a href="namespace.htm#M39" name=
"L1076"><b>-command</b></a></dd>
</dl>

<dl class="ensemble options">
<dd><a href="namespace.htm#M40" name=
"L1077"><b>-namespace</b></a></dd>
</dl>
</dd>

<dd><a href="namespace.htm#M41" name="L1078">UNKNOWN HANDLER
BEHAVIOUR</a></dd>

<dd><a href="namespace.htm#M42" name="L1079">EXAMPLES</a></dd>

<dd><a href="namespace.htm#M43" name="L1080">SEE ALSO</a></dd>

<dd><a href="namespace.htm#M44" name="L1081">KEYWORDS</a></dd>
</dl>

<h3><a name="M2">NAME</a></h3>

namespace - create and manipulate contexts for commands and
variables 

<h3><a name="M3">SYNOPSIS</a></h3>

<b>namespace</b> ?<i>subcommand</i>? ?<i>arg ...</i>?<br>
<h3><a name="M4">DESCRIPTION</a></h3>

The <b>namespace</b> command lets you create, access, and destroy
separate contexts for commands and variables. See the section
<b>WHAT IS A NAMESPACE?</b> below for a brief overview of
namespaces. The legal values of <i>subcommand</i> are listed below.
Note that you can abbreviate the <i>subcommand</i>s. 

<dl class="description">
<dt><a name="M5"><b>namespace children</b> ?<i>namespace</i>?
?<i>pattern</i>?</a></dt>

<dd>Returns a list of all child namespaces that belong to the
namespace <i>namespace</i>. If <i>namespace</i> is not specified,
then the children are returned for the current namespace. This
command returns fully-qualified names, which start with a double
colon (<b>::</b>). If the optional <i>pattern</i> is given, then
this command returns only the names that match the glob-style
pattern. The actual pattern used is determined as follows: a
pattern that starts with double colon (<b>::</b>) is used directly,
otherwise the namespace <i>namespace</i> (or the fully-qualified
name of the current namespace) is prepended onto the pattern.</dd>

<dt><a name="M6"><b>namespace code</b> <i>script</i></a></dt>

<dd>Captures the current namespace context for later execution of
the script <i>script</i>. It returns a new script in which
<i>script</i> has been wrapped in a <b>namespace inscope</b>
command. The new script has two important properties. First, it can
be evaluated in any namespace and will cause <i>script</i> to be
evaluated in the current namespace (the one where the <b>namespace
code</b> command was invoked). Second, additional arguments can be
appended to the resulting script and they will be passed to
<i>script</i> as additional arguments. For example, suppose the
command <b>set script [namespace code {foo bar}]</b> is invoked in
namespace <b>::a::b</b>. Then <b>eval $script [list x y]</b> can be
executed in any namespace (assuming the value of <b>script</b> has
been passed in properly) and will have the same effect as the
command <b>::namespace eval ::a::b {foo bar x y}</b>. This command
is needed because extensions like Tk normally execute callback
scripts in the global namespace. A scoped command captures a
command together with its namespace context in a way that allows it
to be executed properly later. See the section <b>SCOPED
SCRIPTS</b> for some examples of how this is used to create
callback scripts.</dd>

<dt><a name="M7"><b>namespace current</b></a></dt>

<dd>Returns the fully-qualified name for the current namespace. The
actual name of the global namespace is &ldquo;&rdquo; (i.e., an
empty string), but this command returns <b>::</b> for the global
namespace as a convenience to programmers.</dd>

<dt><a name="M8"><b>namespace delete</b> ?<i>namespace namespace
...</i>?</a></dt>

<dd>Each namespace <i>namespace</i> is deleted and all variables,
procedures, and child namespaces contained in the namespace are
deleted. If a procedure is currently executing inside the
namespace, the namespace will be kept alive until the procedure
returns; however, the namespace is marked to prevent other code
from looking it up by name. If a namespace does not exist, this
command returns an error. If no namespace names are given, this
command does nothing.</dd>

<dt><a name="M9"><b>namespace ensemble</b> <i>subcommand</i>
?<i>arg ...</i>?</a></dt>

<dd>Creates and manipulates a command that is formed out of an
ensemble of subcommands. See the section <b>ENSEMBLES</b> below for
further details.</dd>

<dt><a name="M10"><b>namespace eval</b> <i>namespace arg</i>
?<i>arg ...</i>?</a></dt>

<dd>Activates a namespace called <i>namespace</i> and evaluates
some code in that context. If the namespace does not already exist,
it is created. If more than one <i>arg</i> argument is specified,
the arguments are concatenated together with a space between each
one in the same fashion as the <b><a href=
"../TclCmd/eval.htm">eval</a></b> command, and the result is
evaluated. 

<p>If <i>namespace</i> has leading namespace qualifiers and any
leading namespaces do not exist, they are automatically
created.</p>
</dd>

<dt><a name="M11"><b>namespace exists</b> <i>namespace</i></a></dt>

<dd>Returns <b>1</b> if <i>namespace</i> is a valid namespace in
the current context, returns <b>0</b> otherwise.</dd>

<dt><a name="M12"><b>namespace export</b> ?-<b>clear</b>?
?<i>pattern pattern ...</i>?</a></dt>

<dd>Specifies which commands are exported from a namespace. The
exported commands are those that can be later imported into another
namespace using a <b>namespace import</b> command. Both commands
defined in a namespace and commands the namespace has previously
imported can be exported by a namespace. The commands do not have
to be defined at the time the <b>namespace export</b> command is
executed. Each <i>pattern</i> may contain glob-style special
characters, but it may not include any namespace qualifiers. That
is, the pattern can only specify commands in the current
(exporting) namespace. Each <i>pattern</i> is appended onto the
namespace's list of export patterns. If the <b>-clear</b> flag is
given, the namespace's export pattern list is reset to empty before
any <i>pattern</i> arguments are appended. If no <i>pattern</i>s
are given and the <b>-clear</b> flag is not given, this command
returns the namespace's current export list.</dd>

<dt><a name="M13"><b>namespace forget</b> ?<i>pattern pattern
...</i>?</a></dt>

<dd>Removes previously imported commands from a namespace. Each
<i>pattern</i> is a simple or qualified name such as <b>x</b>,
<b>foo::x</b> or <b>a::b::p*</b>. Qualified names contain double
colons (<b>::</b>) and qualify a name with the name of one or more
namespaces. Each &ldquo;qualified pattern&rdquo; is qualified with
the name of an exporting namespace and may have glob-style special
characters in the command name at the end of the qualified name.
Glob characters may not appear in a namespace name. For each
&ldquo;simple pattern&rdquo; this command deletes the matching
commands of the current namespace that were imported from a
different namespace. For &ldquo;qualified patterns&rdquo;, this
command first finds the matching exported commands. It then checks
whether any of those commands were previously imported by the
current namespace. If so, this command deletes the corresponding
imported commands. In effect, this un-does the action of a
<b>namespace import</b> command.</dd>

<dt><a name="M14"><b>namespace import</b> ?<b>-force</b>?
?<i>pattern</i> <i>pattern ...</i>?</a></dt>

<dd>Imports commands into a namespace, or queries the set of
imported commands in a namespace. When no arguments are present,
<b>namespace import</b> returns the list of commands in the current
namespace that have been imported from other namespaces. The
commands in the returned list are in the format of simple names,
with no namespace qualifiers at all. This format is suitable for
composition with <b>namespace forget</b> (see <b>EXAMPLES</b>
below). When <i>pattern</i> arguments are present, each
<i>pattern</i> is a qualified name like <b>foo::x</b> or
<b>a::p*</b>. That is, it includes the name of an exporting
namespace and may have glob-style special characters in the command
name at the end of the qualified name. Glob characters may not
appear in a namespace name. All the commands that match a
<i>pattern</i> string and which are currently exported from their
namespace are added to the current namespace. This is done by
creating a new command in the current namespace that points to the
exported command in its original namespace; when the new imported
command is called, it invokes the exported command. This command
normally returns an error if an imported command conflicts with an
existing command. However, if the -<b>force</b> option is given,
imported commands will silently replace existing commands. The
<b>namespace import</b> command has snapshot semantics: that is,
only requested commands that are currently defined in the exporting
namespace are imported. In other words, you can import only the
commands that are in a namespace at the time when the <b>namespace
import</b> command is executed. If another command is defined and
exported in this namespace later on, it will not be imported.</dd>

<dt><a name="M15"><b>namespace inscope</b> <i>namespace</i>
<i>script</i> ?<i>arg ...</i>?</a></dt>

<dd>Executes a script in the context of the specified
<i>namespace</i>. This command is not expected to be used directly
by programmers; calls to it are generated implicitly when
applications use <b>namespace code</b> commands to create callback
scripts that the applications then register with, e.g., Tk widgets.
The <b>namespace inscope</b> command is much like the <b>namespace
eval</b> command except that the <i>namespace</i> must already
exist, and <b>namespace inscope</b> appends additional <i>arg</i>s
as proper list elements. 

<pre>
<b>namespace inscope ::foo $script $x $y $z</b>
</pre>

is equivalent to 

<pre>
<b>namespace eval ::foo [concat $script [list $x $y $z]]</b>
</pre>

thus additional arguments will not undergo a second round of
substitution, as is the case with <b>namespace eval</b>.</dd>

<dt><a name="M16"><b>namespace origin</b> <i>command</i></a></dt>

<dd>Returns the fully-qualified name of the original command to
which the imported command <i>command</i> refers. When a command is
imported into a namespace, a new command is created in that
namespace that points to the actual command in the exporting
namespace. If a command is imported into a sequence of namespaces
<i>a, b,...,n</i> where each successive namespace just imports the
command from the previous namespace, this command returns the
fully-qualified name of the original command in the first
namespace, <i>a</i>. If <i>command</i> does not refer to an
imported command, the command's own fully-qualified name is
returned.</dd>

<dt><a name="M17"><b>namespace parent</b>
?<i>namespace</i>?</a></dt>

<dd>Returns the fully-qualified name of the parent namespace for
namespace <i>namespace</i>. If <i>namespace</i> is not specified,
the fully-qualified name of the current namespace's parent is
returned.</dd>

<dt><a name="M18"><b>namespace path</b>
?<i>namespaceList</i>?</a></dt>

<dd>Returns the command resolution path of the current namespace.
If <i>namespaceList</i> is specified as a list of named namespaces,
the current namespace's command resolution path is set to those
namespaces and returns the empty list. The default command
resolution path is always empty. See the section <b>NAME
RESOLUTION</b> below for an explanation of the rules regarding name
resolution.</dd>

<dt><a name="M19"><b>namespace qualifiers</b>
<i>string</i></a></dt>

<dd>Returns any leading namespace qualifiers for <i>string</i>.
Qualifiers are namespace names separated by double colons
(<b>::</b>). For the <i>string</i> <b>::foo::bar::x</b>, this
command returns <b>::foo::bar</b>, and for <b>::</b> it returns an
empty string. This command is the complement of the <b>namespace
tail</b> command. Note that it does not check whether the namespace
names are, in fact, the names of currently defined namespaces.</dd>

<dt><a name="M20"><b>namespace tail</b> <i>string</i></a></dt>

<dd>Returns the simple name at the end of a qualified string.
Qualifiers are namespace names separated by double colons
(<b>::</b>). For the <i>string</i> <b>::foo::bar::x</b>, this
command returns <b>x</b>, and for <b>::</b> it returns an empty
string. This command is the complement of the <b>namespace
qualifiers</b> command. It does not check whether the namespace
names are, in fact, the names of currently defined namespaces.</dd>

<dt><a name="M21"><b>namespace upvar</b> <i>namespace</i>
<i>otherVar myVar</i> ?<i>otherVar myVar</i> ...</a></dt>

<dd>This command arranges for one or more local variables in the
current procedure to refer to variables in <i>namespace</i>. The
namespace name is resolved as described in section <b>NAME
RESOLUTION</b>. The command <b>namespace upvar $ns a b</b> has the
same behaviour as <b>upvar 0 ${ns}::a b</b>, with the sole
exception of the resolution rules used for qualified namespace or
variable names. <b>namespace upvar</b> returns an empty
string.</dd>

<dt><a name="M22"><b>namespace unknown</b> ?<i>script</i>?</a></dt>

<dd>Sets or returns the unknown command handler for the current
namespace. The handler is invoked when a command called from within
the namespace cannot be found (in either the current namespace or
the global namespace). The <i>script</i> argument, if given, should
be a well formed list representing a command name and optional
arguments. When the handler is invoked, the full invocation line
will be appended to the script and the result evaluated in the
context of the namespace. The default handler for all namespaces is
<b>::unknown</b>. If no argument is given, it returns the handler
for the current namespace.</dd>

<dt><a name="M23"><b>namespace which</b> ?-<b>command</b>?
?-<b>variable</b>? <i>name</i></a></dt>

<dd>Looks up <i>name</i> as either a command or variable and
returns its fully-qualified name. For example, if <i>name</i> does
not exist in the current namespace but does exist in the global
namespace, this command returns a fully-qualified name in the
global namespace. If the command or variable does not exist, this
command returns an empty string. If the variable has been created
but not defined, such as with the <b><a href=
"../TclCmd/variable.htm">variable</a></b> command or through a
<b><a href="../TclCmd/trace.htm">trace</a></b> on the variable,
this command will return the fully-qualified name of the variable.
If no flag is given, <i>name</i> is treated as a command name. See
the section <b>NAME RESOLUTION</b> below for an explanation of the
rules regarding name resolution.</dd>
</dl>

<h3><a name="M24">WHAT IS A NAMESPACE?</a></h3>

A namespace is a collection of commands and variables. It
encapsulates the commands and variables to ensure that they will
not interfere with the commands and variables of other namespaces.
Tcl has always had one such collection, which we refer to as the
<i>global namespace</i>. The global namespace holds all global
variables and commands. The <b>namespace eval</b> command lets you
create new namespaces. For example, 

<pre>
<b>namespace eval</b> Counter {
   <b>namespace export</b> bump
   variable num 0

   proc bump {} {
      variable num
      incr num
   }
}
</pre>

creates a new namespace containing the variable <b>num</b> and the
procedure <b>bump</b>. The commands and variables in this namespace
are separate from other commands and variables in the same program.
If there is a command named <b>bump</b> in the global namespace,
for example, it will be different from the command <b>bump</b> in
the <b>Counter</b> namespace. 

<p>Namespace variables resemble global variables in Tcl. They exist
outside of the procedures in a namespace but can be accessed in a
procedure via the <b><a href=
"../TclCmd/variable.htm">variable</a></b> command, as shown in the
example above.</p>

<p>Namespaces are dynamic. You can add and delete commands and
variables at any time, so you can build up the contents of a
namespace over time using a series of <b>namespace eval</b>
commands. For example, the following series of commands has the
same effect as the namespace definition shown above:</p>

<pre>
<b>namespace eval</b> Counter {
   variable num 0
   proc bump {} {
      variable num
      return [incr num]
   }
}
<b>namespace eval</b> Counter {
   proc test {args} {
      return $args
   }
}
<b>namespace eval</b> Counter {
    rename test ""
}
</pre>

Note that the <b>test</b> procedure is added to the <b>Counter</b>
namespace, and later removed via the <b><a href=
"../TclCmd/rename.htm">rename</a></b> command. 

<p>Namespaces can have other namespaces within them, so they nest
hierarchically. A nested namespace is encapsulated inside its
parent namespace and can not interfere with other namespaces.</p>

<h3><a name="M25">QUALIFIED NAMES</a></h3>

Each namespace has a textual name such as <b><a href=
"../TclCmd/history.htm">history</a></b> or <b>::safe::interp</b>.
Since namespaces may nest, qualified names are used to refer to
commands, variables, and child namespaces contained inside
namespaces. Qualified names are similar to the hierarchical path
names for Unix files or Tk widgets, except that <b>::</b> is used
as the separator instead of <b>/</b> or <b>.</b>. The topmost or
global namespace has the name &ldquo;&rdquo; (i.e., an empty
string), although <b>::</b> is a synonym. As an example, the name
<b>::safe::interp::create</b> refers to the command <b>create</b>
in the namespace <b><a href="../TclCmd/interp.htm">interp</a></b>
that is a child of namespace <b>::safe</b>, which in turn is a
child of the global namespace, <b>::</b>. 

<p>If you want to access commands and variables from another
namespace, you must use some extra syntax. Names must be qualified
by the namespace that contains them. From the global namespace, we
might access the <b>Counter</b> procedures like this:</p>

<pre>
Counter::bump 5
Counter::Reset
</pre>

We could access the current count like this: 

<pre>
puts "count = $Counter::num"
</pre>

When one namespace contains another, you may need more than one
qualifier to reach its elements. If we had a namespace <b>Foo</b>
that contained the namespace <b>Counter</b>, you could invoke its
<b>bump</b> procedure from the global namespace like this: 

<pre>
Foo::Counter::bump 3
</pre>

<p>You can also use qualified names when you create and rename
commands. For example, you could add a procedure to the <b>Foo</b>
namespace like this:</p>

<pre>
proc Foo::Test {args} {return $args}
</pre>

And you could move the same procedure to another namespace like
this: 

<pre>
rename Foo::Test Bar::Test
</pre>

<p>There are a few remaining points about qualified names that we
should cover. Namespaces have nonempty names except for the global
namespace. <b>::</b> is disallowed in simple command, variable, and
namespace names except as a namespace separator. Extra colons in
any separator part of a qualified name are ignored; i.e. two or
more colons are treated as a namespace separator. A trailing
<b>::</b> in a qualified variable or command name refers to the
variable or command named {}. However, a trailing <b>::</b> in a
qualified namespace name is ignored.</p>

<h3><a name="M26">NAME RESOLUTION</a></h3>

In general, all Tcl commands that take variable and command names
support qualified names. This means you can give qualified names to
such commands as <b><a href="../TclCmd/set.htm">set</a></b>, <b><a
href="../TclCmd/proc.htm">proc</a></b>, <b><a href=
"../TclCmd/rename.htm">rename</a></b>, and <b><a href=
"../TclCmd/interp.htm">interp alias</a></b>. If you provide a
fully-qualified name that starts with a <b>::</b>, there is no
question about what command, variable, or namespace you mean.
However, if the name does not start with a <b>::</b> (i.e., is
<i>relative</i>), Tcl follows basic rules for looking it up:
Variable names are always resolved by looking first in the current
namespace, and then in the global namespace. Command names are also
always resolved by looking in the current namespace first. If not
found there, they are searched for in every namespace on the
current namespace's command path (which is empty by default). If
not found there, command names are looked up in the global
namespace (or, failing that, are processed by the <b><a href=
"../TclCmd/unknown.htm">unknown</a></b> command.) Namespace names,
on the other hand, are always resolved by looking in only the
current namespace. 

<p>In the following example,</p>

<pre>
set traceLevel 0
<b>namespace eval</b> Debug {
   printTrace $traceLevel
}
</pre>

Tcl looks for <b>traceLevel</b> in the namespace <b>Debug</b> and
then in the global namespace. It looks up the command
<b>printTrace</b> in the same way. If a variable or command name is
not found in either context, the name is undefined. To make this
point absolutely clear, consider the following example: 

<pre>
set traceLevel 0
<b>namespace eval</b> Foo {
   variable traceLevel 3

   <b>namespace eval</b> Debug {
      printTrace $traceLevel
   }
}
</pre>

Here Tcl looks for <b>traceLevel</b> first in the namespace
<b>Foo::Debug</b>. Since it is not found there, Tcl then looks for
it in the global namespace. The variable <b>Foo::traceLevel</b> is
completely ignored during the name resolution process. 

<p>You can use the <b>namespace which</b> command to clear up any
question about name resolution. For example, the command:</p>

<pre>
<b>namespace eval</b> Foo::Debug {<b>namespace which</b> -variable traceLevel}
</pre>

returns <b>::traceLevel</b>. On the other hand, the command, 

<pre>
<b>namespace eval</b> Foo {<b>namespace which</b> -variable traceLevel}
</pre>

returns <b>::Foo::traceLevel</b>. 

<p>As mentioned above, namespace names are looked up differently
than the names of variables and commands. Namespace names are
always resolved in the current namespace. This means, for example,
that a <b>namespace eval</b> command that creates a new namespace
always creates a child of the current namespace unless the new
namespace name begins with <b>::</b>.</p>

<p>Tcl has no access control to limit what variables, commands, or
namespaces you can reference. If you provide a qualified name that
resolves to an element by the name resolution rule above, you can
access the element.</p>

<p>You can access a namespace variable from a procedure in the same
namespace by using the <b><a href=
"../TclCmd/variable.htm">variable</a></b> command. Much like the
<b><a href="../TclCmd/global.htm">global</a></b> command, this
creates a local link to the namespace variable. If necessary, it
also creates the variable in the current namespace and initializes
it. Note that the <b><a href="../TclCmd/global.htm">global</a></b>
command only creates links to variables in the global namespace. It
is not necessary to use a <b><a href=
"../TclCmd/variable.htm">variable</a></b> command if you always
refer to the namespace variable using an appropriate qualified
name.</p>

<h3><a name="M27">IMPORTING COMMANDS</a></h3>

Namespaces are often used to represent libraries. Some library
commands are used so frequently that it is a nuisance to type their
qualified names. For example, suppose that all of the commands in a
package like BLT are contained in a namespace called <b>Blt</b>.
Then you might access these commands like this: 

<pre>
Blt::graph .g -background red
Blt::table . .g 0,0
</pre>

If you use the <b>graph</b> and <b>table</b> commands frequently,
you may want to access them without the <b>Blt::</b> prefix. You
can do this by importing the commands into the current namespace,
like this: 

<pre>
<b>namespace import</b> Blt::*
</pre>

This adds all exported commands from the <b>Blt</b> namespace into
the current namespace context, so you can write code like this: 

<pre>
graph .g -background red
table . .g 0,0
</pre>

The <b>namespace import</b> command only imports commands from a
namespace that that namespace exported with a <b>namespace
export</b> command. 

<p>Importing <i>every</i> command from a namespace is generally a
bad idea since you do not know what you will get. It is better to
import just the specific commands you need. For example, the
command</p>

<pre>
<b>namespace import</b> Blt::graph Blt::table
</pre>

imports only the <b>graph</b> and <b>table</b> commands into the
current context. 

<p>If you try to import a command that already exists, you will get
an error. This prevents you from importing the same command from
two different packages. But from time to time (perhaps when
debugging), you may want to get around this restriction. You may
want to reissue the <b>namespace import</b> command to pick up new
commands that have appeared in a namespace. In that case, you can
use the <b>-force</b> option, and existing commands will be
silently overwritten:</p>

<pre>
<b>namespace import</b> -force Blt::graph Blt::table
</pre>

If for some reason, you want to stop using the imported commands,
you can remove them with a <b>namespace forget</b> command, like
this: 

<pre>
<b>namespace forget</b> Blt::*
</pre>

This searches the current namespace for any commands imported from
<b>Blt</b>. If it finds any, it removes them. Otherwise, it does
nothing. After this, the <b>Blt</b> commands must be accessed with
the <b>Blt::</b> prefix. 

<p>When you delete a command from the exporting namespace like
this:</p>

<pre>
rename Blt::graph ""
</pre>

the command is automatically removed from all namespaces that
import it. 

<h3><a name="M28">EXPORTING COMMANDS</a></h3>

You can export commands from a namespace like this: 

<pre>
<b>namespace eval</b> Counter {
   <b>namespace export</b> bump reset
   variable Num 0
   variable Max 100

   proc bump {{by 1}} {
      variable Num
      incr Num $by
      Check
      return $Num
   }
   proc reset {} {
      variable Num
      set Num 0
   }
   proc Check {} {
      variable Num
      variable Max
      if {$Num &gt; $Max} {
         error "too high!"
      }
   }
}
</pre>

The procedures <b>bump</b> and <b>reset</b> are exported, so they
are included when you import from the <b>Counter</b> namespace,
like this: 

<pre>
<b>namespace import</b> Counter::*
</pre>

However, the <b>Check</b> procedure is not exported, so it is
ignored by the import operation. 

<p>The <b>namespace import</b> command only imports commands that
were declared as exported by their namespace. The <b>namespace
export</b> command specifies what commands may be imported by other
namespaces. If a <b>namespace import</b> command specifies a
command that is not exported, the command is not imported.</p>

<h3><a name="M29">SCOPED SCRIPTS</a></h3>

The <b>namespace code</b> command is the means by which a script
may be packaged for evaluation in a namespace other than the one in
which it was created. It is used most often to create event
handlers, Tk bindings, and traces for evaluation in the global
context. For instance, the following code indicates how to direct a
variable <b><a href="../TclCmd/trace.htm">trace</a></b> callback
into the current namespace: 

<pre>
<b>namespace eval</b> a {
   variable b
   proc theTraceCallback { n1 n2 op } {
      upvar 1 $n1 var
      puts "the value of $n1 has changed to $var"
      return
   }
   trace add variable b write [<b>namespace code</b> theTraceCallback]
}
set a::b c
</pre>

<p>When executed, it prints the message:</p>

<pre>
the value of a::b has changed to c
</pre>

<h3><a name="M30">ENSEMBLES</a></h3>

The <b>namespace ensemble</b> is used to create and manipulate
ensemble commands, which are commands formed by grouping
subcommands together. The commands typically come from the current
namespace when the ensemble was created, though this is
configurable. Note that there may be any number of ensembles
associated with any namespace (including none, which is true of all
namespaces by default), though all the ensembles associated with a
namespace are deleted when that namespace is deleted. The link
between an ensemble command and its namespace is maintained however
the ensemble is renamed. 

<p>Three subcommands of the <b>namespace ensemble</b> command are
defined:</p>

<dl class="ensembles">
<dt><a name="M31"><b>namespace ensemble create</b> ?<i>option value
...</i>?</a></dt>

<dd>Creates a new ensemble command linked to the current namespace,
returning the fully qualified name of the command created. The
arguments to <b>namespace ensemble create</b> allow the
configuration of the command as if with the <b>namespace ensemble
configure</b> command. If not overridden with the <b>-command</b>
option, this command creates an ensemble with exactly the same name
as the linked namespace. See the section <b>ENSEMBLE OPTIONS</b>
below for a full list of options supported and their effects.</dd>

<dt><a name="M32"><b>namespace ensemble configure</b>
<i>command</i> ?<i>option</i>? ?<i>value ...</i>?</a></dt>

<dd>Retrieves the value of an option associated with the ensemble
command named <i>command</i>, or updates some options associated
with that ensemble command. See the section <b>ENSEMBLE OPTIONS</b>
below for a full list of options supported and their effects.</dd>

<dt><a name="M33"><b>namespace ensemble exists</b>
<i>command</i></a></dt>

<dd>Returns a boolean value that describes whether the command
<i>command</i> exists and is an ensemble command. This command only
ever returns an error if the number of arguments to the command is
wrong.</dd>
</dl>

<p>When called, an ensemble command takes its first argument and
looks it up (according to the rules described below) to discover a
list of words to replace the ensemble command and subcommand with.
The resulting list of words is then evaluated (with no further
substitutions) as if that was what was typed originally (i.e. by
passing the list of words through <b><a href=
"../TclLib/Eval.htm">Tcl_EvalObjv</a></b>) and returning the result
of the command. Note that it is legal to make the target of an
ensemble rewrite be another (or even the same) ensemble command.
The ensemble command will not be visible through the use of the
<b><a href="../TclCmd/uplevel.htm">uplevel</a></b> or <b><a href=
"../TclCmd/info.htm">info level</a></b> commands.</p>

<h4><a name="M34">ENSEMBLE OPTIONS</a></h4>

The following options, supported by the <b>namespace ensemble
create</b> and <b>namespace ensemble configure</b> commands,
control how an ensemble command behaves: 

<dl class="ensemble options">
<dt><a name="M35"><b>-map</b></a></dt>

<dd>When non-empty, this option supplies a dictionary that provides
a mapping from subcommand names to a list of prefix words to
substitute in place of the ensemble command and subcommand words
(in a manner similar to an alias created with <b><a href=
"../TclCmd/interp.htm">interp alias</a></b>; the words are not
reparsed after substitution); if the first word of any target is
not fully qualified when set, it is assumed to be relative to the
<i>current</i> namespace and changed to be exactly that (that is,
it is always fully qualified when read). When this option is empty,
the mapping will be from the local name of the subcommand to its
fully-qualified name. Note that when this option is non-empty and
the <b>-subcommands</b> option is empty, the ensemble subcommand
names will be exactly those words that have mappings in the
dictionary.</dd>

<dt><a name="M36"><b>-prefixes</b></a></dt>

<dd>This option (which is enabled by default) controls whether the
ensemble command recognizes unambiguous prefixes of its
subcommands. When turned off, the ensemble command requires exact
matching of subcommand names.</dd>

<dt><a name="M37"><b>-subcommands</b></a></dt>

<dd>When non-empty, this option lists exactly what subcommands are
in the ensemble. The mapping for each of those commands will be
either whatever is defined in the <b>-map</b> option, or to the
command with the same name in the namespace linked to the ensemble.
If this option is empty, the subcommands of the namespace will
either be the keys of the dictionary listed in the <b>-map</b>
option or the exported commands of the linked namespace at the time
of the invocation of the ensemble command.</dd>

<dt><a name="M38"><b>-unknown</b></a></dt>

<dd>When non-empty, this option provides a partial command (to
which all the words that are arguments to the ensemble command,
including the fully-qualified name of the ensemble, are appended)
to handle the case where an ensemble subcommand is not recognized
and would otherwise generate an error. When empty (the default) an
error (in the style of <b><a href=
"../TclLib/GetIndex.htm">Tcl_GetIndexFromObj</a></b>) is generated
whenever the ensemble is unable to determine how to implement a
particular subcommand. See <b>UNKNOWN HANDLER BEHAVIOUR</b> for
more details.</dd>
</dl>

<p>The following extra option is allowed by <b>namespace ensemble
create</b>:</p>

<dl class="ensemble options">
<dt><a name="M39"><b>-command</b></a></dt>

<dd>This write-only option allows the name of the ensemble created
by <b>namespace ensemble create</b> to be anything in any existing
namespace. The default value for this option is the fully-qualified
name of the namespace in which the <b>namespace ensemble create</b>
command is invoked.</dd>
</dl>

<p>The following extra option is allowed by <b>namespace ensemble
configure</b>:</p>

<dl class="ensemble options">
<dt><a name="M40"><b>-namespace</b></a></dt>

<dd>This read-only option allows the retrieval of the
fully-qualified name of the namespace which the ensemble was
created within.</dd>
</dl>

<h4><a name="M41">UNKNOWN HANDLER BEHAVIOUR</a></h4>

If an unknown handler is specified for an ensemble, that handler is
called when the ensemble command would otherwise return an error
due to it being unable to decide which subcommand to invoke. The
exact conditions under which that occurs are controlled by the
<b>-subcommands</b>, <b>-map</b> and <b>-prefixes</b> options as
described above. 

<p>To execute the unknown handler, the ensemble mechanism takes the
specified <b>-unknown</b> option and appends each argument of the
attempted ensemble command invocation (including the ensemble
command itself, expressed as a fully qualified name). It invokes
the resulting command in the scope of the attempted call. If the
execution of the unknown handler terminates normally, the ensemble
engine reparses the subcommand (as described below) and tries to
dispatch it again, which is ideal for when the ensemble's
configuration has been updated by the unknown subcommand handler.
Any other kind of termination of the unknown handler is treated as
an error.</p>

<p>The result of the unknown handler is expected to be a list (it
is an error if it is not). If the list is an empty list, the
ensemble command attempts to look up the original subcommand again
and, if it is not found this time, an error will be generated just
as if the <b>-unknown</b> handler was not there (i.e. for any
particular invocation of an ensemble, its unknown handler will be
called at most once.) This makes it easy for the unknown handler to
update the ensemble or its backing namespace so as to provide an
implementation of the desired subcommand and reparse.</p>

<p>When the result is a non-empty list, the words of that list are
used to replace the ensemble command and subcommand, just as if
they had been looked up in the <b>-map</b>. It is up to the unknown
handler to supply all namespace qualifiers if the implementing
subcommand is not in the namespace of the caller of the ensemble
command. Also note that when ensemble commands are chained (e.g. if
you make one of the commands that implement an ensemble subcommand
into an ensemble, in a manner similar to the <b><a href=
"../TkCmd/text.htm">text</a></b> widget's tag and mark subcommands)
then the rewrite happens in the context of the caller of the
outermost ensemble. That is to say that ensembles do not in
themselves place any namespace contexts on the Tcl call stack.</p>

<p>Where an empty <b>-unknown</b> handler is given (the default),
the ensemble command will generate an error message based on the
list of commands that the ensemble has defined (formatted similarly
to the error message from <b><a href=
"../TclLib/GetIndex.htm">Tcl_GetIndexFromObj</a></b>). This is the
error that will be thrown when the subcommand is still not
recognized during reparsing. It is also an error for an
<b>-unknown</b> handler to delete its namespace.</p>

<h3><a name="M42">EXAMPLES</a></h3>

Create a namespace containing a variable and an exported command: 

<pre>
<b>namespace eval</b> foo {
   variable bar 0
   proc grill {} {
      variable bar
      puts "called [incr bar] times"
   }
   <b>namespace export</b> grill
}
</pre>

<p>Call the command defined in the previous example in various
ways.</p>

<pre>
# Direct call
::foo::grill

# Use the command resolution path to find the name
<b>namespace eval</b> boo {
   <b>namespace path</b> ::foo
   grill
}

# Import into current namespace, then call local alias
<b>namespace import</b> foo::grill
grill

# Create two ensembles, one with the default name and one with a
# specified name.  Then call through the ensembles.
<b>namespace eval</b> foo {
   <b>namespace ensemble</b> create
   <b>namespace ensemble</b> create -command ::foobar
}
foo grill
foobar grill
</pre>

<p>Look up where the command imported in the previous example came
from:</p>

<pre>
puts "grill came from [<b>namespace origin</b> grill]"
</pre>

<p>Remove all imported commands from the current namespace:</p>

<pre>
namespace forget {*}[namespace import]
</pre>

<h3><a name="M43">SEE ALSO</a></h3>

<b><a href="../TclCmd/interp.htm">interp</a></b>, <b><a href=
"../TclCmd/upvar.htm">upvar</a></b>, <b><a href=
"../TclCmd/variable.htm">variable</a></b> 

<h3><a name="M44">KEYWORDS</a></h3>

<a href="../Keywords/C.htm#command">command</a>, <a href=
"../Keywords/E.htm#ensemble">ensemble</a>, <a href=
"../Keywords/E.htm#exported">exported</a>, <a href=
"../Keywords/I.htm#internal">internal</a>, <a href=
"../Keywords/V.htm#variable">variable</a> 

<div class="copy">Copyright &copy; 1995-1997 Roger E. Critchlow Jr.
Copyright &copy; 1993-1997 Bell Labs Innovations for Lucent
Technologies Copyright &copy; 1997 Sun Microsystems, Inc. Copyright
&copy; 2000 Scriptics Corporation. Copyright &copy; 2004-2005 Donal
K. Fellows.</div>
</body>
</html>

